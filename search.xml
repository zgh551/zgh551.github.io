<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>3D Object Detector 3DSSD</title>
    <url>/2024/08/16/3D-ObjectDetector-3DSSD/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>3DSSD是基于点的单阶段3D目标检测网络，该模型的提出背景是在3D单阶段目标检测器大都是基于体素，其在转换过程中会丢失信息，而基于点的检测器大都是两阶段网络，精度虽然高，但是推理性能差。而此时，基于点的单阶段网络还未充分探索。作者基于点基础，提出了一个轻量级且高效的单阶段网络(3DSSD)，可以很好地在精度和效率之间保持平衡。 <img data-src="https://i.imgur.com/6IPCPg1.png" alt="网络框图" /> 作者通过分析两阶段网络各个部分耗时情况，发现SA层对于提取点得特征是必要的，但FP和细化模块确实限制了基于点的方法的效率。 <img data-src="https://i.imgur.com/FVDI9t1.png" alt="各阶段时间" /></p>
<span id="more"></span>
<h2 id="backbone">Backbone</h2>
<figure>
<img data-src="https://i.imgur.com/gL42xwh.png" alt="Backbone: (左)KITTI (右)nuScenes" /><figcaption aria-hidden="true">Backbone: (左)KITTI (右)nuScenes</figcaption>
</figure>
<h2 id="融合采样">融合采样</h2>
<p>F-FPS采样可以保留大都数前景点，但由于采样点数量的限制，很多背景点都被过滤掉（背景点语义特征与前景点语义特征相隔较大），这虽然对回归检测框有好处，但是背景点太少的话对分类任务不太友好（样本不均衡）。基于这一点考虑，作者将D-FPS和F-FPS进行融合，以保证有足够的前景点用于回归，以及足够的背景点用于分类，最终的采样点由D-FPS和F-FPS组成。</p>
<h2 id="cg层">CG层</h2>
<p>为了降低计算成本，并发挥融合采样的优势，作者提出在预测头之前加一个候选生成层，该层是SA层的变体。 因为D-FPS中的点大都是负样本点，对于边界框框回归是无用的。因此只使用F-FPS中的点作为初始中心点，这些初始中心点在其相对位置的监督下偏移到相应示例，如下图所示： <img data-src="https://i.imgur.com/8zQAWXX.png" /> 将这些平移操作后的新点称为候选点，将这些候选点作为CG层的中心点，而为何使用候选点而不是原始点作为中心点是从性能角度考虑的。 接下来，从来自D-FPS和F-FPS的<code>整个点集</code>中找到每个<code>候选点</code>在预定义阈值范围内的<code>周围点</code>。将他们的标准化位置和语义特征连接作为输入，并应用MLP层提取特征。这些特征将会被送到预测头用于回归和分类。</p>
<h2 id="anchor-free回归">Anchor Free回归</h2>
<p>对于回归分支需要回归的主要有中心点坐标、大小以及偏转角。</p>
<ul>
<li>中心点 候选点到标注中心的距离<span class="math inline">\((d_x,d_y,d_z)\)</span></li>
<li>大小 候选点预测到的框大小与对应的Gt bbox的大小偏差<span class="math inline">\((d_l,d_w,d_h)\)</span></li>
<li>偏转角 每个候选点预测的角度与实例Gt bbox的转角的偏移，这里引入了bin+res的形式进行回归（这个可参考<a href="https://zgh551.github.io/2024/08/14/3D-ObjectDetector-PointRCNN/">PointRCNN</a>，就是把角度划分成不同的区域(12)，然后引入分类和回归损失）。</li>
</ul>
<h2 id="d中心分配策略">3D中心分配策略</h2>
<p>在训练过程中，需要给每一个候选点分配一个标签，在2D检测器中通常采用IOU，设定一个阈值，超过某个阈值的作为正样本，或者是采样掩膜的方式来给每个像素分配一个标签。这里借鉴<span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzE5MDQuMDEzNTUucGRm">FCOS<i class="fa fa-external-link-alt"></i></span>中心域的思想来给每个候选点分配一个标签，其可以产生连续的中心域标签，可以更好的进行框回归。 <img data-src="https://i.imgur.com/MwXEirt.png" alt="红色到蓝色表示1到0" /></p>
<p>如上图所示，离中心点越近其值接近于1，越远则接近于0. <span class="math display">\[centerness^* = \sqrt{\frac{\min(l*,r*)}{\max(l*,r*)}\times\frac{\min(t*,b*)}{\max(t*,b*)}}\]</span></p>
<h3 id="扩展到3维表示">扩展到3维表示</h3>
<p><span class="math display">\[l_{ctrness} = \sqrt[3]{\frac{\min(f,b)}{\max(f,b)}\times\frac{\min(l,r)}{\max(l,r)}\times\frac{\min(t,d)}{\max(t,d)}}\]</span></p>
<p>其中，$(f, b, l, r, t, d) <span class="math inline">\(表示中心点到前后左右上下表面的距离。 首先判断候选点在哪个真实框里面，得到\)</span>_{mask}$，其值非0即1。最后的分类标签是两者的乘积。 <span class="math display">\[u = \mathcal{l}_{ctrness}*\mathcal{l}_{mask}\]</span></p>
<h2 id="损失函数">损失函数</h2>
<p>损失函数主要包含分类、回归和偏移损失三部分。 <span class="math display">\[
L=\frac{1}{N_c}\sum_i{L_c(s_i,u_i)} + \lambda_1\frac{1}{N_p}\sum_i{[u_i&gt;0]L_r} + \lambda_2\frac{1}{N_p^*}L_s
\]</span></p>
<ol type="1">
<li><span class="math inline">\(N_c\)</span>：表示总的候选点数量；</li>
<li><span class="math inline">\(N_p\)</span>：表示正候选点数量，正候选点是位于前景实例中的候选点；</li>
</ol>
<h3 id="回归损失">回归损失</h3>
<p>回归损失包含 中心点距离损失(<span class="math inline">\(L_{dist}\)</span>)、候选框大小损失(<span class="math inline">\(L_{size}\)</span>)、角度损失(<span class="math inline">\(L_{angle}\)</span>)和角点位置损失(<span class="math inline">\(L_{corner}\)</span>)四部分。</p>
<h4 id="smooth_l1">smooth_L1</h4>
<p>中心点距离损失(<span class="math inline">\(L_{dist}\)</span>)和候选框大小损失(<span class="math inline">\(L_{size}\)</span>)采用smooth_L1损失 <span class="math display">\[
smooth_{L1}=\begin{cases}0.5x^2 &amp; \text{if} \lvert x \rvert &lt; 1\\
\lvert x \rvert - 0.5 &amp;\text{otherwise} \end{cases}
\]</span></p>
<h4 id="基于bin">基于bin</h4>
<p>角度损失(<span class="math inline">\(L_{angle}\)</span>)采用bin + res 策略，损失表示如下： <span class="math display">\[L_{angle}=L_c(d^a_c,t^a_{c})+ D(d_r^a,t_r^a)\]</span></p>
<h4 id="角点损失">角点损失</h4>
<p>计算预测框的8个角点与真实角点之间的距离损失。 <span class="math display">\[L_{corner}=\sum_{m=1}^{8}\|P_m-G_m\|\]</span></p>
<h3 id="偏移损失">偏移损失</h3>
<p>偏移损失应用在候选点生成（CG层中）的监督任务中，作者利用了smooth-l1损失函数来计算，用于度量预测的偏移值与候选点到真实中心点实际距离的差异。</p>
<h2 id="实验数据">实验数据</h2>
<h3 id="性能数据">性能数据</h3>
<figure>
<img data-src="https://i.imgur.com/iIQxk38.png" alt="性能" /><figcaption aria-hidden="true">性能</figcaption>
</figure>
<h3 id="精度数据">精度数据</h3>
<figure>
<img data-src="https://i.imgur.com/wkBf9kh.png" alt="精度" /><figcaption aria-hidden="true">精度</figcaption>
</figure>
<ul>
<li>L：表示激光雷达</li>
<li>R：表示RGB图像</li>
</ul>
<h2 id="参考">参考</h2>
<ol type="1">
<li><span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzIwMDIuMTAxODc=">3DSSD: Point-based 3D Single Stage Object Detector<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>3D Object Detector</category>
        <category>3DSSD</category>
      </categories>
      <tags>
        <tag>3D Object Detector</tag>
        <tag>LiDAR</tag>
      </tags>
  </entry>
  <entry>
    <title>3D Object Detector-表示方法</title>
    <url>/2024/08/07/3D-ObjectDetector-Express/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<figure>
<img data-src="https://i.imgur.com/0RO0rIZ.png" alt="表示方法" /><figcaption aria-hidden="true">表示方法</figcaption>
</figure>
<span id="more"></span>
<h2 id="显性表示">显性表示</h2>
<h3 id="体素">体素</h3>
<figure>
<img data-src="https://s2.loli.net/2024/08/12/nlCgoYaUVJ9QAiw.png" alt="体素" /><figcaption aria-hidden="true">体素</figcaption>
</figure>
<p>相对于2D对象表示使用像素，对应的3D表示可以使用体素表示，由若干个规则的立方体在三维空间中放置。为了表示三维物体的形状，体素中可以存储几何占有率、体积、密度和符号距离等信息，便于渲染。体素本身不包含位置信息，可以通过体素间的相对位置推导位置信息。</p>
<figure>
<img data-src="https://s2.loli.net/2024/08/12/DMpI5oeVECnZhf7.png" alt="像素与体素" /><figcaption aria-hidden="true">像素与体素</figcaption>
</figure>
<p>由于体素表示的规则性，可以配合标准的卷积神经网络。将三维几何物体表示为体素上二元变量的概率分布。 尽管体素网格非常适合3D卷积网络，但其通常内存效率低下，内存随着分辨率呈立方增加。</p>
<h3 id="点云">点云</h3>
<figure>
<img data-src="https://s2.loli.net/2024/08/12/DnYgbPRq24OpVwm.png" alt="点云" /><figcaption aria-hidden="true">点云</figcaption>
</figure>
<h3 id="多边形网格polygon-mesh">多边形网格(Polygon Mesh)</h3>
<figure>
<img data-src="https://s2.loli.net/2024/08/12/l9QjnTJ5Sz6PdOK.png" alt="多边形" /><figcaption aria-hidden="true">多边形</figcaption>
</figure>
<figure>
<img data-src="https://s2.loli.net/2024/08/12/DWXyNkgAIbrJlGF.png" alt="多边形表示" /><figcaption aria-hidden="true">多边形表示</figcaption>
</figure>
<h2 id="隐式表示">隐式表示</h2>
<p>隐式表示是一种对各种信号进行参数化的新方法，传统的信号表示通常是离散的，而隐式表示将信号参数化为一个连续函数，将信号的域映射到该坐标上的属性的值，并且该函数通常不是可解析性的，即不可能学下将自然图像参数化为数学公式的函数。隐式表示通过神经网络来近似信号函数。</p>
<ul>
<li><p>不与空间分辨率相耦合 例如，图像与像素数量相耦合的方式。隐式神经表示是连续函数，因此参数化信号所需的内存与空间分辨率无关，只与底层信号的复杂性相关。另一个推论是，隐式表示具有“无限分辨率”——它们可以在任意空间分辨率下进行采样。所以隐式表示解决了在显示表示中显存的限制，使得超分辨率成为可能；</p></li>
<li><p>表征能力更强 跨神经隐式表示的泛化等同于学习函数空间上的先验，通过学习神经网络权重上的先验实现。学习后的隐式表示可以通过不同的坐标输入映射到任意属性值。</p></li>
<li><p>泛化性高 神经隐式表示学习函数空间上的先验，然后根据提取的先验以及输入的特征，可以得到不同的目标信号。</p></li>
<li><p>易于学习 基于神经网络的隐式神经表示易于与各种网络结构结合，能够快速的学习先验，拟合学习对象。与传统的表示形式(如网格、点云或体素)相比，神经隐式表征可以灵活地融合到可微分的基于学习的管道中。</p></li>
</ul>
<h3 id="占用函数occupancy-function">占用函数(Occupancy Function)</h3>
<figure>
<img data-src="https://s2.loli.net/2024/08/13/rwVIU8D16GJyfOX.png" alt="占用函数" /><figcaption aria-hidden="true">占用函数</figcaption>
</figure>
<h3 id="符号距离函数singned-distance-function">符号距离函数(Singned Distance Function)</h3>
<figure>
<img data-src="https://s2.loli.net/2024/08/13/7NHAUsY5vSE1mpQ.png" alt="符号距离函数" /><figcaption aria-hidden="true">符号距离函数</figcaption>
</figure>
<p>如果大家对隐式表示感兴趣，后续会做详细的论文解读。</p>
]]></content>
      <categories>
        <category>3D Object Detector</category>
        <category>对象表示</category>
      </categories>
      <tags>
        <tag>3D Object Detector</tag>
        <tag>LiDAR</tag>
      </tags>
  </entry>
  <entry>
    <title>3D Object Detector IPOD</title>
    <url>/2024/08/15/3D-ObjectDetector-IPOD/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<figure>
<img data-src="https://i.imgur.com/50FMneL.png" alt="网络框图" /><figcaption aria-hidden="true">网络框图</figcaption>
</figure>
<ol type="1">
<li>第一个子采样网络用于过滤掉大多数的背景点；</li>
<li>第二阶段是基于点基础的候选框生成；</li>
<li>第三个组成部分是网络架构，由主干网络、proposal特征生成模块和边界框预测网络组成，它对生成的候选框进行分类和回归；</li>
</ol>
<span id="more"></span>
<h2 id="proposal特征生成模块">proposal特征生成模块</h2>
<p>通过结合位置信息和上下文特征来生成从内部点的质心到目标实例对象中心的偏移量。将预测的残差添加回位置信息，以使特征几何变换更加鲁棒。</p>
<figure>
<img data-src="https://i.imgur.com/NCBqQfR.png" alt="proposal" /><figcaption aria-hidden="true">proposal</figcaption>
</figure>
<h2 id="backbone和bbox回归">Backbone和bbox回归</h2>
<figure>
<img data-src="https://i.imgur.com/R80Gskn.png" alt="Backbone" /><figcaption aria-hidden="true">Backbone</figcaption>
</figure>
<h3 id="backbone">Backbone</h3>
<p>主干网络以原始点云数据<span class="math inline">\((x,y,z,r)\)</span>作为输入，通过堆叠SA层和FP层模块来提取每个点的局部和全局特征。</p>
<h3 id="bounding-box预测网络">Bounding-box预测网络</h3>
<p>它将proposal特征生成模块中的特征作为输入。产生分类和回归预测。</p>
<h2 id="实验数据">实验数据</h2>
<figure>
<img data-src="https://i.imgur.com/icjWCAD.png" alt="实验数据" /><figcaption aria-hidden="true">实验数据</figcaption>
</figure>
<h2 id="参考">参考</h2>
<ol type="1">
<li><span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzE4MTIuMDUyNzY=">IPOD: Intensive Point-based Object Detector for Point Cloud<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>3D Object Detector</category>
        <category>IPOD</category>
      </categories>
      <tags>
        <tag>3D Object Detector</tag>
        <tag>LiDAR</tag>
      </tags>
  </entry>
  <entry>
    <title>3D Object Detector Base LiDAR</title>
    <url>/2024/08/11/3D-ObjectDetector-LiDAR/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>先进的3D对象检测方法提出了各种从稀疏的点云数据中学习辨别特征的方法:</p>
<ol type="1">
<li>将点云投影到鸟瞰图，并利用2D CNN学习点云特征以生成3D预测框；</li>
<li>将点云分组为体素，并使用3D CNN学习体素的特征来生成3D框；</li>
<li>直接采样点云数据，并使用MLP学习点云特征来生成3D框；</li>
</ol>
<p><img data-src="https://i.imgur.com/QYni6kX.jpeg" /></p>
<span id="more"></span>
<h2 id="存在问题">存在问题</h2>
<ol type="1">
<li>鸟瞰图投影或体素化表示都会因为数据量化遭受信息丢失；</li>
<li>3D CNN的内存利用率和计算效率都很低；</li>
</ol>
<figure>
<img data-src="https://s2.loli.net/2024/08/14/7rUVHFtwIG43nyW.png" alt="基于LiDAR的3D对象检测模型时间顺序" /><figcaption aria-hidden="true">基于LiDAR的3D对象检测模型时间顺序</figcaption>
</figure>
<h2 id="d对象检测的数据表示">3D对象检测的数据表示</h2>
<ol type="1">
<li>与像素规则分布的图像相比，点云数据是稀疏且不规则的3D表示，需要特定设计的模型进行特征提取。</li>
<li>距离图像 是密集和紧凑的表示形式，但是距离图像包含3D信息而不是RGB通道数值。因此直接使用传统的卷积神经网络可能不是最优的解决方案。</li>
</ol>
<h2 id="基于点的对象检测器">基于点的对象检测器</h2>
<figure>
<img data-src="https://s2.loli.net/2024/08/14/mWHKGtZNMnTPirc.png" alt="基于点3D对象检测方法图示" /><figcaption aria-hidden="true">基于点3D对象检测方法图示</figcaption>
</figure>
<figure>
<img data-src="https://s2.loli.net/2024/08/14/IxVDJeG5lBqOXUC.png" alt="基于点的检测器分类" /><figcaption aria-hidden="true">基于点的检测器分类</figcaption>
</figure>
<h3 id="点采样算法">点采样算法</h3>
<h4 id="fpsfarthest-point-sampling-or-d-fpsdistance-farthest-point-sampling">FPS(Farthest Point Sampling) or D-FPS(Distance-Farthest Point Sampling)</h4>
<p>最远点采样在PointNet++网络中首次提出，并在基于点的检测器中被广泛采用，其基本思想如下： 给定一个输入点集<span class="math inline">\(\{x_1, x_2, ..., x_n\}\)</span>，使用FPS算法去选择输入点的子集 <span class="math inline">\(\{x_{i_1}, x_{i_2}, ..., x_{i_m}\}\)</span>。</p>
<ol type="1">
<li>随机从<span class="math inline">\(\{x_1, x_2, ..., x_n\}\)</span>中选择一个点<span class="math inline">\(x_{i_1}\)</span>;</li>
<li>从剩余的点集中查找与点<span class="math inline">\(x_{i_1}\)</span>距离最远的点<span class="math inline">\(x_{i_2}\)</span>；</li>
<li>以此类推，从剩余的点集中查找与集合 <span class="math inline">\(\{x_{i_1}, x_{i_2}, ..., x_{i_{j-1}}\}\)</span>中的点距离最远的点<span class="math inline">\(x_{i_j}\)</span>；</li>
</ol>
<figure>
<img data-src="https://s2.loli.net/2024/08/14/HUWEfamkTJjiodB.png" alt="采样过程演示" /><figcaption aria-hidden="true">采样过程演示</figcaption>
</figure>
<h4 id="segmentation-guided-filter">Segmentation Guided Filter</h4>
<p><code>IPOD</code> 模型中首次提出，基于语义的引导过滤采样。</p>
<figure>
<img data-src="https://s2.loli.net/2024/08/14/EP1HDAQCigTVlWZ.png" alt="图(a)表示图像上的语义分割结果，图(b)表示在点云上投影分割结果；图(c)NMS后正样本基于点的候选框" /><figcaption aria-hidden="true">图(a)表示图像上的语义分割结果，图(b)表示在点云上投影分割结果；图(c)NMS后正样本基于点的候选框</figcaption>
</figure>
<h5 id="选择正样本点">选择正样本点</h5>
<ol type="1">
<li>首先滤除背景点，采用2D语义分割网络预测前景像素，然后使用给定的相机矩阵将这些像素投影到点云中作为掩膜来收集正样本点。</li>
<li>基于这些正样本点的中心，生成具有多个尺度，角度和偏移的proposals，如下图，基于BEV视图，基于2种anchors生成6个proposals。这些proposal可以覆盖汽车对象的大部分关键点。</li>
</ol>
<figure>
<img data-src="https://s2.loli.net/2024/08/14/XSKbjPLJARoF23z.png" alt="with BEV view generate proposal on each point" /><figcaption aria-hidden="true">with BEV view generate proposal on each point</figcaption>
</figure>
<h5 id="减少冗余的proposals">减少冗余的proposals</h5>
<p>采用 <strong>non-maximum suppression (NMS)</strong> 去除多余的proposals,其中每个proposal的core值是其内部点的语义分割值之和，尽量选择包含更多点的proposal，IoU的值计算基于每个proposal在BEV视图下的投影。</p>
<h5 id="减少歧义proposals">减少歧义proposals</h5>
<p>如下图所示，使用内部点的中心和预定义的特定类别的archor大小替换AB为C</p>
<p><img data-src="https://s2.loli.net/2024/08/14/7ROKQSh5erfkx96.png" /></p>
<p>在训练期间，为proposal分配目标标签时存在一些歧义点。如果只考虑proposal和GT box的IoU值来标注正负标签，可能是不合适。</p>
<p><img data-src="https://s2.loli.net/2024/08/14/aFcGrPC5q8nzvMs.png" /></p>
<p>提出 <strong>PointsIoU</strong> ，通过计算两个Box交集的点数与并集的点数之商。</p>
<h4 id="fusion-sampling">Fusion Sampling</h4>
<ul>
<li>Feature-FPS 3DSSD模型中首次提出，其采用空间距离和语义特征距离作为FPS的标准 <span class="math display">\[C(A,B) = \lambda L_d(A,B) + L_f(A,B)\]</span> 其中， <span class="math inline">\(L_d(A,B)\)</span>表示 <span class="math inline">\(L2\)</span>(x,y,z)距离，<span class="math inline">\(L_f(A,B)\)</span>表示 <span class="math inline">\(L2\)</span>语义特征距离。</li>
</ul>
<figure>
<img data-src="https://s2.loli.net/2024/08/14/p6Oo8qrYjkdWR5C.png" alt="不同采样策略的点召回" /><figcaption aria-hidden="true">不同采样策略的点召回</figcaption>
</figure>
<figure>
<img data-src="https://s2.loli.net/2024/08/14/ZcufLOYTPBnQGMe.png" alt="Fusion Sanpling" /><figcaption aria-hidden="true">Fusion Sanpling</figcaption>
</figure>
<p>如上图所示，3DSSD是中提出的Fusion Sampling策略，即在SA层中同时应用 F-FPS 和 D-FPS，保留足够的正样本点用于位置定位，同时保留足够的负样本点用于分类任务。</p>
<h3 id="voxel-base">Voxel-Base</h3>
<p>基于体素的采样</p>
<h3 id="targeted-fps">Targeted-FPS</h3>
<p>随机采样</p>
<h3 id="fps-refine">FPS + Refine</h3>
<p>坐标细化 特征提取算法</p>
<h3 id="mlpmaxpool">MLP+MaxPool</h3>
<h3 id="graph-nn">Graph NN</h3>
<h3 id="transformer">Transformer</h3>
<h2 id="总结">总结</h2>
<p>目前大多数的基于点的方法，点云采样是其推理时间的瓶颈，无法满足自动驾驶对实时性的要求。</p>
<h2 id="参考">参考</h2>
<ol type="1">
<li><span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzIyMDYuMDk0NzQ=">3D Object Detection for Autonomous Driving: A Comprehensive Survey<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>3D Object Detector</category>
        <category>Base LiDAR</category>
      </categories>
      <tags>
        <tag>3D Object Detector</tag>
        <tag>LiDAR</tag>
      </tags>
  </entry>
  <entry>
    <title>3D Object Detector Point-GNN</title>
    <url>/2024/08/17/3D-ObjectDetector-Point-GNN/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>如下是三种常见的点云表示和处理方法: <img data-src="https://i.imgur.com/sI3M4V6.png" alt="点云数据表示" /></p>
<p>如下图所示，网络架构主要由三部分组成：图构建、T次迭代GNN和边界框合并和评分。</p>
<figure>
<img data-src="https://i.imgur.com/t9YbwlP.png" alt="网络架构" /><figcaption aria-hidden="true">网络架构</figcaption>
</figure>
<span id="more"></span>
<h2 id="图构建">图构建</h2>
<h3 id="点云表示">点云表示</h3>
<p>定义一个包含 <span class="math inline">\(N\)</span>个点的点云集合<span class="math inline">\(P = \{ p_1,..., p_N \}\)</span>，其中， 每个点<span class="math inline">\(p_i=(x_i,s_i)\)</span>包含3D坐标信息<span class="math inline">\(x_i \in \mathcal{R}^3\)</span>和一个长度为<span class="math inline">\(k\)</span>的向量表示点的属性的状态信息 <span class="math inline">\(s_i \in \mathcal{R}^k\)</span>。状态值<span class="math inline">\(s_i\)</span>可以是激光的反射强度或者周围对象特征的编码。 使用点<span class="math inline">\(P\)</span>作为顶点以固定半径<span class="math inline">\(r\)</span>连接其邻近点构建图<span class="math inline">\(G=(P,E)\)</span>，其中 <span class="math display">\[E = \{(p_i,p_j) | \|x_i-x_j\|_2 &lt; r\}\]</span></p>
<h3 id="cell-list查找算法">Cell list查找算法</h3>
<p>通过使用单元列表查找给定截止距离内的点对，我们可以有效地解决问题，运行时间复杂度为<span class="math inline">\(\mathcal{O}(cN)\)</span>，其中<span class="math inline">\(c\)</span>是半径内邻居的最大数量。</p>
<figure>
<img data-src="https://i.imgur.com/9PhIEmm.png" alt="cell list查找算法" /><figcaption aria-hidden="true">cell list查找算法</figcaption>
</figure>
<p>具体做法如下:</p>
<ol type="1">
<li>将空间划分为多个小的单元格(cell)。</li>
<li>将每个点都存储在对应的单元格中。</li>
<li>对于需要查找邻域的某个点,只需要检查该点所在单元格及其周围邻居单元格内的点,就可以高效地找到在给定截断距离内的所有点对。 这种基于cell list的方法可以大大提高邻域搜索的效率,避免了逐一检查所有点对的开销。</li>
</ol>
<h3 id="体素下采样算法">体素下采样算法</h3>
<blockquote>
<p>实际点云包含数万个点，哪怕基于上述的cell list查找算法，仍然会带来巨大的计算负担。</p>
</blockquote>
<p>故，作者提出基于体素的下采样点云，得到<span class="math inline">\(\hat{P}\)</span>来进行图构建。 其中，体素下采样指的是：</p>
<ol type="1">
<li>将原始的点云数据划分成多个三维体素(voxel)。</li>
<li>对于每个非空的体素,选择该体素内的一个代表性点作为下采样后的点。通常选择该体素内点的平均位置或中心点。</li>
</ol>
<p>这样做的目的是:</p>
<ol type="1">
<li>降低点云的数据量,加快后续的图构建和计算过程。</li>
<li>消除原始点云中可能存在的噪声和不均匀分布,使得图结构更加稳定。</li>
</ol>
<blockquote>
<p>注：这里的体素仅用于降低点云的密度，并不用作点云的表示，仍然使用图来表示下采样后的点云。</p>
</blockquote>
<h4 id="如何在体素网格中保留原始点云信息">如何在体素网格中保留原始点云信息？</h4>
<p>将原始点云的信息编码(encode)到体素网格的初始状态值<span class="math inline">\(s_i\)</span>中，具体操作如下:</p>
<ol type="1">
<li>对于体素网格中的每个顶点,搜索其半径为<span class="math display">\[r_0\]</span>的邻域内的原始点云数据。</li>
<li>对于每个顶点的邻域点云数据,使用神经网络模型提取它们的局部特征，不仅要保存它的平均属性,还要提取它所包含的原始点云数据的局部几何特征。这里使用了一种能够处理无序点集的神经网络架构(backbone),如PointNet或PointNet++。
<ul>
<li>利用MLP(多层感知机)对每个点云数据点的反射强度和相对坐标进行嵌入编码。这可以学习到每个点的局部特征表示。</li>
<li>然后使用Max pooling对这些局部特征进行聚合,得到每个体素的特征向量。这种聚合操作可以捕获体素内部点云数据的最显著特征。</li>
<li>将这些聚合后的特征向量作为体素网格中每个顶点的初始状态值。这样可以在后续的优化过程中,利用这些丰富的局部特征信息来指导网格的优化。</li>
</ul></li>
<li>将提取的局部特征编码到对应的体素中,以此来保留原始点云的细节信息。</li>
</ol>
<h2 id="具备自动注册功能的图神经网络">具备自动注册功能的图神经网络</h2>
<h3 id="图神经网络消息传递">图神经网络消息传递</h3>
<p>典型的图神经网络通过聚合沿边的特征来细化顶点特征。</p>
<p><img data-src="https://i.imgur.com/qTW2aMc.png" /> <img data-src="https://i.imgur.com/q59Ru8B.png" /></p>
<p>第<span class="math inline">\(t+1\)</span>次迭代中，以如下形式更新每个顶点的特征：</p>
<p><span class="math display">\[e_{ij}^{t} = f^t(v_i^t, v_j^t)\]</span> <span class="math display">\[v_{i}^{t+1} = g^{t}(\rho(\{ e_{ij}^t |(i,j) \in E\}), v_i^t )\]</span></p>
<ol type="1">
<li><span class="math inline">\(v^t\)</span>：表示第t次迭代的顶点特征；</li>
<li><span class="math inline">\(e^t\)</span>：表示第t次迭代的边沿特征；</li>
<li><span class="math inline">\(f^t(.)\)</span>：计算两个顶点间的边沿特征；</li>
<li><span class="math inline">\(\rho^t(.)\)</span>：是一个集合函数，聚合每个顶点的边沿特征；</li>
<li><span class="math inline">\(g^t(.)\)</span>：采用聚合的边沿特征来更新顶点特征；</li>
</ol>
<h3 id="针对对象检测的改进">针对对象检测的改进</h3>
<p>我们设计 GNN 来细化顶点的状态，以包含有关顶点所属对象的信息。为了实现这个目标，优化了上述公式，使用它的邻近状态更新顶点的状态： <span class="math display">\[s_{i}^{t+1} = g^{t}(\rho(\{ f^t(x_j-x_i, s_j^t) |(i,j) \in E\}), s_i^t )\]</span> 使用相对坐标作为函数<span class="math inline">\(f^t(.)\)</span>的输入来提取边沿特征。使用相对坐标可以消除整个点云的全局平移对特征提取的影响，但其对邻域内的平移仍然是敏感的。</p>
<blockquote>
<p>当顶点添加一个小的平移，其邻域内的局部特征仍然是相似的，但是邻域内的相对坐标都变化了，这就引起了函数<span class="math inline">\(f^t(.)\)</span>的输入方差变大。</p>
</blockquote>
<p>为了减少平移方差，使用中心顶点的结构特征而不是其坐标来对齐邻近节点的坐标。因为中心顶点的已经从上一次迭代中捕获了邻近点的结构特征信息，使用它预测对齐偏移，提出如下 自动注册机制： <span class="math display">\[\varDelta{x}_{i}^{t} = h^{t}(s_i^t)\]</span> <span class="math display">\[s_{i}^{t+1} = g^{t}(\rho(\{ f^t(x_j-x_i+\varDelta{x}_{i}^{t}, s_j^t) |(i,j) \in E\}), s_i^t )\]</span> 关于模型中的<span class="math inline">\(f^t(.)\)</span>、<span class="math inline">\(h^t(.)\)</span>和<span class="math inline">\(g^t(.)\)</span>使用 <code>多层感知器(MLP)</code> 去学习函数参数，并在函数<span class="math inline">\(g^t(.)\)</span>内添加<code>残差连接</code>。 <span class="math inline">\(\rho^t(.)\)</span>函数选择 <code>MAX</code> 用于提升鲁棒性。 图神经网络单次迭代步骤如下： <span class="math display">\[\varDelta{x}_{i}^{t} = \mathbf{MLP}_h^{t}(s_i^t)\]</span> <span class="math display">\[e_{ij}^{t} = \mathbf{MLP}_f^{t}([x_j-x_i+\varDelta{x}, s_j^t])\]</span> <span class="math display">\[s_{i}^{t+1} = \mathbf{MLP}_g^{t}(\mathbf{Max}(\{e_{ij}|(i,j) \in E\})) + s_i^t\]</span></p>
<ol type="1">
<li>每次迭代中使用不同的<span class="math inline">\(\mathbf{MLP}^{t}\)</span>,各个迭代之间不共享；</li>
<li>经过多次迭代后，使用顶点的状态值去预测类别和对象的边界框；</li>
<li>多类分类分支负责预测对象类别的概率。</li>
<li>定位分支负责预测每个对象类别的边界框坐标。</li>
</ol>
<p><img data-src="https://i.imgur.com/IkZCpG4.png" /></p>
<h2 id="边界框的合并与评分">边界框的合并与评分</h2>
<figure>
<img data-src="https://i.imgur.com/HHn7hDY.png" alt="NMS算法" /><figcaption aria-hidden="true">NMS算法</figcaption>
</figure>
<p><span class="math display">\[o_i=\frac{1}{l_iw_ih_i}\prod_{v\in\{v_i^l,v_i^w,v_i^h\}}\max_{p_j\in{b_i}}(v^Tx_j)-\min_{p_j\in{b_i}}(v^Tx_j)\]</span></p>
<h2 id="实验数据">实验数据</h2>
<figure>
<img data-src="https://i.imgur.com/twDelef.png" alt="实验数据" /><figcaption aria-hidden="true">实验数据</figcaption>
</figure>
]]></content>
      <categories>
        <category>3D Object Detector</category>
        <category>Point-GNN</category>
      </categories>
      <tags>
        <tag>3D Object Detector</tag>
        <tag>LiDAR</tag>
        <tag>Graph Nueral Network</tag>
        <tag>GNN</tag>
      </tags>
  </entry>
  <entry>
    <title>3D Object Detector PointNet++</title>
    <url>/2024/08/13/3D-ObjectDetector-PointNet++/</url>
    <content><![CDATA[<figure>
<img data-src="https://s2.loli.net/2024/08/14/GICOxSBjTH3MNrf.png" alt="网络框图" /><figcaption aria-hidden="true">网络框图</figcaption>
</figure>
<span id="more"></span>
<h2 id="sampling-layer">Sampling layer</h2>
<p>使用 FPS(farthest point sampling)算法从输入点集<span class="math inline">\(\{ x_1, x_2,...,x_n\}\)</span>中选择子集<span class="math inline">\(\{ x_{i_1},x_{i_2},...,x_{i_m} \}\)</span></p>
<h2 id="grouping-layer">Grouping layer</h2>
<p>该层输入为大小为<span class="math inline">\(N \times (d+C)\)</span>的点集和大小为<span class="math inline">\(N&#39; \times d\)</span>的质心集的坐标，输出是大小为 <span class="math inline">\(N&#39; \times K \times (d+C)\)</span>的点集组，其中每组对应一个局部区域，<span class="math inline">\(K\)</span>是质心点在邻域内的点数。 &gt; <span class="math inline">\(K\)</span>是随着组变化的，但是后续的PointNet层能够将灵活数量的点转换为固定长度的局部区域特征向量。</p>
<h3 id="球查询">球查询</h3>
<p>以样本点为球心，按照给定搜索半径R得到一个球形搜索区域，然后从该区域提取K个邻近点。</p>
<p><img data-src="https://s2.loli.net/2024/08/14/gjLItqAXGU7P6SC.png" /></p>
<p>给定领域中点的个数不足K个或者多余K个如何处理？</p>
<ul>
<li>如果不足K个，则直接对某个点重采样，凑够K个；</li>
<li>如果大于K个，则选取距离最小的前K个。 对于稀疏网络而言，样本分布不均匀，如何处理？</li>
<li>PointNet++提出了多尺度方法MSG和多层级方法<code>MRG</code>，这个见后面具体介绍。</li>
</ul>
<h2 id="pointnet-layer">PointNet layer</h2>
<p>该层中，输入数据大小为<span class="math inline">\(N&#39; \times K \times (d+C)\)</span>的<span class="math inline">\(N&#39;\)</span>个局部区域，输出大小为<span class="math inline">\(N&#39; \times (d+C&#39;)\)</span>，其每个局部区域都是由质心和对质心邻域进行编码的局部特征进行抽象的。</p>
<ul>
<li>特征提取时，未采用T-Net，那如何保证特征旋转不变性？</li>
</ul>
<p>PointNet++未像PointNet一样采用T-Net，而是采用局部相对坐标，就是对每个采样点及其K个领域点的空间坐标进行变换。 &gt; 这里变换只针对坐标，其他特征不变 通过使用相对坐标和点特征，我们可以捕获局部区域中的点对点关系。</p>
<h2 id="interpolate">interpolate</h2>
<p>主要针对分割网络，因为分割结果需要对每一个点云分配一个语义标签。但是目前只获取到了下采样后点云的特征，那插值的作用就是得到下采样过程中忽视的点云的特征。</p>
<figure>
<img data-src="https://i.imgur.com/AjgwIC1.png" alt="插值公式" /><figcaption aria-hidden="true">插值公式</figcaption>
</figure>
<h2 id="稀疏点云处理">稀疏点云处理</h2>
<figure>
<img data-src="https://i.imgur.com/DFnmgfU.png" alt="点云场景" /><figcaption aria-hidden="true">点云场景</figcaption>
</figure>
<p>如果按照同一领域半径去寻找领域点，那对于稀疏的地方局部特征其实是比较差的，为了解决这一问题，作者提出了MSG和MRG两种方式。</p>
<figure>
<img data-src="https://i.imgur.com/vDoFmBe.png" alt="(a)Multi-scale grouping (MSG); (b) Multiresolution grouping (MRG)" /><figcaption aria-hidden="true">(a)Multi-scale grouping (MSG); (b) Multiresolution grouping (MRG)</figcaption>
</figure>
<h3 id="msg">MSG</h3>
<p>多尺度进行采样，即前面提到的grouping layer不采用同一个半径R，而是采用不同的半径和采样个数，然后每次采样的特征都经过pointnet layer提取到特征后再进行融合。</p>
<figure>
<img data-src="https://i.imgur.com/PQCBjvJ.png" alt="MSG" /><figcaption aria-hidden="true">MSG</figcaption>
</figure>
<h3 id="mrg">MRG</h3>
<p>多层级进行采样，主要是考虑到如果对每一个采样点都进行MSG，计算量太大。MRG采用两个pointnet layer对特征进行提取和聚合。</p>
<figure>
<img data-src="https://i.imgur.com/Nuo5WND.png" alt="MRG" /><figcaption aria-hidden="true">MRG</figcaption>
</figure>
<h2 id="实验结果">实验结果</h2>
<figure>
<img data-src="https://i.imgur.com/iLs1Giw.png" alt="实验数据" /><figcaption aria-hidden="true">实验数据</figcaption>
</figure>
<blockquote>
<p>DP表示训练期间随机输入dropout.</p>
</blockquote>
]]></content>
      <categories>
        <category>3D Object Detector</category>
        <category>PointNet++</category>
      </categories>
      <tags>
        <tag>3D Object Detector</tag>
        <tag>LiDAR</tag>
      </tags>
  </entry>
  <entry>
    <title>3D Object Detector PointNet</title>
    <url>/2024/08/12/3D-ObjectDetector-PointNet/</url>
    <content><![CDATA[<figure>
<img data-src="https://s2.loli.net/2024/08/14/u6cbaUOS5k29lpN.png" alt="斯坦福" /><figcaption aria-hidden="true">斯坦福</figcaption>
</figure>
<figure>
<img data-src="https://s2.loli.net/2024/08/14/PEtF4XDLnedfIry.png" alt="应用领域" /><figcaption aria-hidden="true">应用领域</figcaption>
</figure>
<span id="more"></span>
<h2 id="理论分析">理论分析</h2>
<h3 id="点云存在两个问题">点云存在两个问题</h3>
<h4 id="无序性">无序性</h4>
<p>点云是一组无序的向量，其中点的不同排序，结果应该一致。 <img data-src="https://s2.loli.net/2024/08/14/m6ROVc2pqUlag8Q.png" alt="无序性" /></p>
<p>如何解决？</p>
<ul>
<li>方式一：按照一定规则对点集进行排序;</li>
<li>方式二：将点集的所有排列作为增强数据，训练一个循环网络;</li>
<li>方式三：利用一个对称函数将所有信息进行聚合; 其中， 方式一看似简单，但是在高维空间中，实际上不存在一个在一般意义上相对于点扰动稳定的排序方式。 方式二被证明对于长度小的序列(几十个)有较好的鲁棒性，但对于动不动上千的点云数据不太合适。 因此，PointNet采用方式三，具体三种方式的精度对比如下：</li>
</ul>
<figure>
<img data-src="https://s2.loli.net/2024/08/14/kofRgVOS2Pptzjd.png" alt="实现顺序不变性的三种方法" /><figcaption aria-hidden="true">实现顺序不变性的三种方法</figcaption>
</figure>
<p>文章的主要思想是对集合中的变换元素应用对称函数来近似定义在点集上的通用函数： <span class="math display">\[f({x_1,...,x_n})\approx g(h(x_1),...,h(x_n))\]</span> 其中，<span class="math inline">\(h\)</span>函数使用 MLP 网络近似，<span class="math inline">\(g\)</span>函数使用 单变量函数与 MaxPool 函数的组合。</p>
<p>常见的对称函数有:</p>
<ul>
<li>求和函数 <span class="math display">\[g(x_1,x_2,...,x_n) = x_1 + x_2 + ... + x_n\]</span></li>
<li>求最大值函数 <span class="math display">\[g(x_1,x_2,...,x_n) = \max \{ x_1,x_2,...,x_n \}\]</span> 通过一系列的<span class="math inline">\(h\)</span>函数可以捕获点集合的不同属性(3D结构特征等) 故 PointNet 选择采用多层感知机(MLP)和最大池化(MaxPool)算子构建网络框架。</li>
</ul>
<figure>
<img data-src="https://s2.loli.net/2024/08/14/QFgs96A1okcEDwR.png" alt="MLP" /><figcaption aria-hidden="true">MLP</figcaption>
</figure>
<h4 id="旋转变换后分类结果一致">旋转变换后分类结果一致</h4>
<p>要做到旋转的一致性，PointNet引入T-Net得到一个旋转矩阵，对输入特征进行自动对齐。将正则化项添加到我们的softmax训练损失中，即将特征变换矩阵约束为接近正交矩阵（正交变换不会丢失输入中的信息）。</p>
<p><img data-src="https://s2.loli.net/2024/08/14/pFd8gTPwhsOr3vL.png" /> <img data-src="https://s2.loli.net/2024/08/14/TJIg8oe5U3Ayvsx.png" /></p>
<p>实验发现，通过添加正则化项，优化变得更加稳定，并且模型也获得了更好的性能。</p>
<p><img data-src="https://s2.loli.net/2024/08/14/Tk5Pb6eltBfqEnv.png" /></p>
<p>使用输入变换精度可以提升0.8%，而增加正则损失对高维度的变换是有效的。</p>
<h2 id="鲁棒性好">鲁棒性好</h2>
<p><img data-src="https://s2.loli.net/2024/08/14/37IcEnkjMt9YSa2.png" /></p>
<h2 id="实验结果">实验结果</h2>
<figure>
<img data-src="https://s2.loli.net/2024/08/14/mvyhd4YpqS92WGH.png" alt="分类结果" /><figcaption aria-hidden="true">分类结果</figcaption>
</figure>
<figure>
<img data-src="https://s2.loli.net/2024/08/14/irh4pde5QSWl6v2.png" alt="分割结果" /><figcaption aria-hidden="true">分割结果</figcaption>
</figure>
<h2 id="网络结构">网络结构</h2>
<p><img data-src="https://s2.loli.net/2024/08/14/d2aDmFjMe6Z3Qc1.png" /></p>
<ul>
<li>分类网路只使用global特征进行预测；</li>
<li>语义分割网络使用local和global特征进行预测；</li>
</ul>
<h3 id="share-mlp">Share MLP</h3>
<p>PointNet使用二维卷积网络来实现Shared MLP。</p>
<p><img data-src="https://s2.loli.net/2024/08/14/qFk36xvbHUaRdjp.png" /></p>
<h2 id="网络代码">网络代码</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_model</span>(<span class="params">point_cloud, is_training, bn_decay=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; Classification PointNet, input is BxNx3, output Bx40 &quot;&quot;&quot;</span></span><br><span class="line">    batch_size = point_cloud.get_shape()[<span class="number">0</span>].value</span><br><span class="line">    num_point = point_cloud.get_shape()[<span class="number">1</span>].value</span><br><span class="line">    end_points = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;transform_net1&#x27;</span>) <span class="keyword">as</span> sc:</span><br><span class="line">        transform = input_transform_net(point_cloud, is_training, bn_decay, K=<span class="number">3</span>)</span><br><span class="line">    point_cloud_transformed = tf.matmul(point_cloud, transform)</span><br><span class="line">    input_image = tf.expand_dims(point_cloud_transformed, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    net = tf_util.conv2d(input_image, <span class="number">64</span>, [<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">                         padding=<span class="string">&#x27;VALID&#x27;</span>, stride=[<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                         bn=<span class="literal">True</span>, is_training=is_training,</span><br><span class="line">                         scope=<span class="string">&#x27;conv1&#x27;</span>, bn_decay=bn_decay)</span><br><span class="line">    net = tf_util.conv2d(net, <span class="number">64</span>, [<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                         padding=<span class="string">&#x27;VALID&#x27;</span>, stride=[<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                         bn=<span class="literal">True</span>, is_training=is_training,</span><br><span class="line">                         scope=<span class="string">&#x27;conv2&#x27;</span>, bn_decay=bn_decay)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;transform_net2&#x27;</span>) <span class="keyword">as</span> sc:</span><br><span class="line">        transform = feature_transform_net(net, is_training, bn_decay, K=<span class="number">64</span>)</span><br><span class="line">    end_points[<span class="string">&#x27;transform&#x27;</span>] = transform</span><br><span class="line">    net_transformed = tf.matmul(tf.squeeze(net, axis=[<span class="number">2</span>]), transform)</span><br><span class="line">    net_transformed = tf.expand_dims(net_transformed, [<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    net = tf_util.conv2d(net_transformed, <span class="number">64</span>, [<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                         padding=<span class="string">&#x27;VALID&#x27;</span>, stride=[<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                         bn=<span class="literal">True</span>, is_training=is_training,</span><br><span class="line">                         scope=<span class="string">&#x27;conv3&#x27;</span>, bn_decay=bn_decay)</span><br><span class="line">    net = tf_util.conv2d(net, <span class="number">128</span>, [<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                         padding=<span class="string">&#x27;VALID&#x27;</span>, stride=[<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                         bn=<span class="literal">True</span>, is_training=is_training,</span><br><span class="line">                         scope=<span class="string">&#x27;conv4&#x27;</span>, bn_decay=bn_decay)</span><br><span class="line">    net = tf_util.conv2d(net, <span class="number">1024</span>, [<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                         padding=<span class="string">&#x27;VALID&#x27;</span>, stride=[<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                         bn=<span class="literal">True</span>, is_training=is_training,</span><br><span class="line">                         scope=<span class="string">&#x27;conv5&#x27;</span>, bn_decay=bn_decay)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Symmetric function: max pooling</span></span><br><span class="line">    net = tf_util.max_pool2d(net, [num_point,<span class="number">1</span>],</span><br><span class="line">                             padding=<span class="string">&#x27;VALID&#x27;</span>, scope=<span class="string">&#x27;maxpool&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    net = tf.reshape(net, [batch_size, -<span class="number">1</span>])</span><br><span class="line">    net = tf_util.fully_connected(net, <span class="number">512</span>, bn=<span class="literal">True</span>, is_training=is_training,</span><br><span class="line">                                  scope=<span class="string">&#x27;fc1&#x27;</span>, bn_decay=bn_decay)</span><br><span class="line">    net = tf_util.dropout(net, keep_prob=<span class="number">0.7</span>, is_training=is_training,</span><br><span class="line">                          scope=<span class="string">&#x27;dp1&#x27;</span>)</span><br><span class="line">    net = tf_util.fully_connected(net, <span class="number">256</span>, bn=<span class="literal">True</span>, is_training=is_training,</span><br><span class="line">                                  scope=<span class="string">&#x27;fc2&#x27;</span>, bn_decay=bn_decay)</span><br><span class="line">    net = tf_util.dropout(net, keep_prob=<span class="number">0.7</span>, is_training=is_training,</span><br><span class="line">                          scope=<span class="string">&#x27;dp2&#x27;</span>)</span><br><span class="line">    net = tf_util.fully_connected(net, <span class="number">40</span>, activation_fn=<span class="literal">None</span>, scope=<span class="string">&#x27;fc3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> net, end_points</span><br></pre></td></tr></table></figure>
<h3 id="t-net">T-Net</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">input_transform_net</span>(<span class="params">point_cloud, is_training, bn_decay=<span class="literal">None</span>, K=<span class="number">3</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; Input (XYZ) Transform Net, input is BxNx3 gray image</span></span><br><span class="line"><span class="string">        Return:</span></span><br><span class="line"><span class="string">            Transformation matrix of size 3xK &quot;&quot;&quot;</span></span><br><span class="line">    batch_size = point_cloud.get_shape()[<span class="number">0</span>].value</span><br><span class="line">    num_point = point_cloud.get_shape()[<span class="number">1</span>].value</span><br><span class="line"></span><br><span class="line">    input_image = tf.expand_dims(point_cloud, -<span class="number">1</span>)</span><br><span class="line">    net = tf_util.conv2d(input_image, <span class="number">64</span>, [<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">                         padding=<span class="string">&#x27;VALID&#x27;</span>, stride=[<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                         bn=<span class="literal">True</span>, is_training=is_training,</span><br><span class="line">                         scope=<span class="string">&#x27;tconv1&#x27;</span>, bn_decay=bn_decay)</span><br><span class="line">    net = tf_util.conv2d(net, <span class="number">128</span>, [<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                         padding=<span class="string">&#x27;VALID&#x27;</span>, stride=[<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                         bn=<span class="literal">True</span>, is_training=is_training,</span><br><span class="line">                         scope=<span class="string">&#x27;tconv2&#x27;</span>, bn_decay=bn_decay)</span><br><span class="line">    net = tf_util.conv2d(net, <span class="number">1024</span>, [<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                         padding=<span class="string">&#x27;VALID&#x27;</span>, stride=[<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                         bn=<span class="literal">True</span>, is_training=is_training,</span><br><span class="line">                         scope=<span class="string">&#x27;tconv3&#x27;</span>, bn_decay=bn_decay)</span><br><span class="line">    net = tf_util.max_pool2d(net, [num_point,<span class="number">1</span>],</span><br><span class="line">                             padding=<span class="string">&#x27;VALID&#x27;</span>, scope=<span class="string">&#x27;tmaxpool&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    net = tf.reshape(net, [batch_size, -<span class="number">1</span>])</span><br><span class="line">    net = tf_util.fully_connected(net, <span class="number">512</span>, bn=<span class="literal">True</span>, is_training=is_training,</span><br><span class="line">                                  scope=<span class="string">&#x27;tfc1&#x27;</span>, bn_decay=bn_decay)</span><br><span class="line">    net = tf_util.fully_connected(net, <span class="number">256</span>, bn=<span class="literal">True</span>, is_training=is_training,</span><br><span class="line">                                  scope=<span class="string">&#x27;tfc2&#x27;</span>, bn_decay=bn_decay)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;transform_XYZ&#x27;</span>) <span class="keyword">as</span> sc:</span><br><span class="line">        <span class="keyword">assert</span>(K==<span class="number">3</span>)</span><br><span class="line">        weights = tf.get_variable(<span class="string">&#x27;weights&#x27;</span>, [<span class="number">256</span>, <span class="number">3</span>*K],</span><br><span class="line">                                  initializer=tf.constant_initializer(<span class="number">0.0</span>),</span><br><span class="line">                                  dtype=tf.float32)</span><br><span class="line">        biases = tf.get_variable(<span class="string">&#x27;biases&#x27;</span>, [<span class="number">3</span>*K],</span><br><span class="line">                                 initializer=tf.constant_initializer(<span class="number">0.0</span>),</span><br><span class="line">                                 dtype=tf.float32)</span><br><span class="line">        biases += tf.constant([<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>], dtype=tf.float32)</span><br><span class="line">        transform = tf.matmul(net, weights)</span><br><span class="line">        transform = tf.nn.bias_add(transform, biases)</span><br><span class="line"></span><br><span class="line">    transform = tf.reshape(transform, [batch_size, <span class="number">3</span>, K])</span><br><span class="line">    <span class="keyword">return</span> transform</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>3D Object Detector</category>
        <category>PointNet</category>
      </categories>
      <tags>
        <tag>3D Object Detector</tag>
        <tag>LiDAR</tag>
      </tags>
  </entry>
  <entry>
    <title>3D Object Detector PointRCNN</title>
    <url>/2024/08/14/3D-ObjectDetector-PointRCNN/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>PointRCNN 将目标检测任务分为两个阶段： 第一阶段：借助点云分割为前景点和背景，并以自下而上的方式直接从点云生成少量高质量的目标候选框； 第二阶段：再对候选目标框进行优化调整，细化目标框的边界。</p>
<figure>
<img data-src="https://i.imgur.com/vjhaAba.png" alt="网络框图" /><figcaption aria-hidden="true">网络框图</figcaption>
</figure>
<span id="more"></span>
<h2 id="第一阶段">第一阶段</h2>
<p>首先从原始点云数据中通过神经网络生成高度可信的3D边界框，该操作进一步缩小了3D边界框的搜索范围，让第二阶段重点强化这些候选框的细节。</p>
<figure>
<img data-src="https://i.imgur.com/ZRLf9rx.png" alt="backbone" /><figcaption aria-hidden="true">backbone</figcaption>
</figure>
<h3 id="backbone网络">Backbone网络</h3>
<p>使用<code>PointNet++(MSG)</code>作为骨干网络，输出逐点的特征。添加一个分割头用于估计前景掩码，一个Box回归头用于生成3D候选框。</p>
<h3 id="前景点分割网络">前景点分割网络</h3>
<p>由于对室外场景来说，前景点的数量通常远小于背景点的数量，因此分割网络使用 Focus Loss(焦点损失) 函数来处理类别不平衡的问题。</p>
<figure>
<img data-src="https://i.imgur.com/0I8vtBI.png" alt="12" /><figcaption aria-hidden="true">12</figcaption>
</figure>
<p><span class="math display">\[\mathcal{L}_{focal} = -\alpha_{t}(1-p_{t})^{\lambda}\log(p_{t})\]</span> 其中， <span class="math display">\[
p_{t} = \begin{cases}
p &amp; \text{前景} \\
1-p &amp; \text{背景}
\end{cases}
\]</span> 在训练点云分割时，保持原论文的默认参数，<span class="math inline">\(\alpha_{t}=0.25\)</span>，<span class="math inline">\(\lambda=2\)</span>。</p>
<h3 id="基于bin的3d-box回归网络">基于bin的3D Box回归网络</h3>
<p>为了约束生成的3D候选框，提出了基于bin的回归损失来评估对象的3D边界框。使用该方法模型训练时可以更快收敛。</p>
<figure>
<img data-src="https://i.imgur.com/w8GPWoq.png" alt="基于Bin的定位图示" /><figcaption aria-hidden="true">基于Bin的定位图示</figcaption>
</figure>
<p><code>bin</code>可以直观理解为刻度尺上的一个刻度，相对于直接使用回归任务对x和z进行学习，不如将这些变量视为一个整数(分类任务)和一个浮点数(回归任务)分别学习效果好。 其中，目标对象中心点位置可分解为如下表示： <span class="math display">\[bin_x^{(p)}=\lfloor \frac{x^p-x^{(p)}+\mathcal{S}}{\delta} \rfloor, bin_z^{(p)}=\lfloor \frac{z^p-z^{(p)}+\mathcal{S}}{\delta} \rfloor\]</span> <span class="math display">\[{res_u^{(p)} \atop u\in\set{x,z}}=\frac{1}{C}\big(u^p-u^{(p)}+\mathcal{S}-(bin_u^{(p)}*\delta+\frac{\delta}{2})\big)\]</span> <span class="math display">\[res_y^{(p)}=y^p-y^{(p)}\]</span> 其中，</p>
<ol type="1">
<li><span class="math inline">\((x^{(p)},y^{(p)},z^{(p)})\)</span>：表示受关注的前景点坐标；</li>
<li><span class="math inline">\((x^p,y^p,z^p)\)</span>：表示前景点对应对象的中心坐标；</li>
<li><span class="math inline">\(bin_{x}^{(p)}\)</span>和<span class="math inline">\(bin_z^{(p)}\)</span>：表示沿<span class="math inline">\(X\)</span>和<span class="math inline">\(Z\)</span>轴分配的Ground-Truthbin；</li>
<li><span class="math inline">\(res_{x}^{(p)}\)</span>和<span class="math inline">\(res_z^{(p)}\)</span>：表示在被分配的bin中进一步细化位置的Ground-Truth残差；</li>
<li><span class="math inline">\(\mathcal{C}\)</span>：表示bin长度的标准化系数，即归一化到[-1,1]区间，原文中<span class="math inline">\(\mathcal{C}=\delta\)</span>；</li>
</ol>
<h4 id="表达式推导">表达式推导</h4>
<p>考虑x轴方向的表示<span class="math inline">\(bin_x^{(p)}=\lfloor \frac{x^p-x^{(p)}+\mathcal{S}}{\delta} \rfloor\)</span> 则量化后的中心点相对位置表示如下： <span class="math display">\[\lfloor x^p-x^{(p)} \rfloor = bin_x^{(p)}*\delta-\mathcal{S}\]</span> 实际中心点的相对位置为<span class="math inline">\(x^p-x^{(p)}\)</span> 则残差可表示为 <span class="math display">\[res_x^{(p)} = x^p-x^{(p)} - \lfloor x^p-x^{(p)} \rfloor\]</span> 代入得 <span class="math display">\[res_x^{(p)} = x^p-x^{(p)} - bin_x^{(p)}*\delta+\mathcal{S} \in [0,\delta)\]</span> 由于<span class="math inline">\(x^p-x^{(p)} \geqq \lfloor x^p-x^{(p)} \rfloor\)</span>，故<span class="math inline">\(res_x^{(p)} \geqq 0\)</span> 为了方便计算，将数据分布限制在正负区间，故对残差减去<span class="math inline">\(\frac{\delta}{2}\)</span>得 <span class="math display">\[res_x^{(p)} = x^p-x^{(p)}+\mathcal{S} -（bin_x^{(p)}*\delta+\frac{\delta}{2}） \in [-\frac{\delta}{2},\frac{\delta}{2})\]</span> 考虑到超参数<span class="math inline">\(\delta\)</span>的范围是不定的，需对残差输出做标准化处理，即 <span class="math display">\[res_x^{(p)} = \frac{1}{\delta}\big(x^p-x^{(p)}+\mathcal{S}-bin_x^{(p)}*\delta+\frac{\delta}{2}）\big) \in [-\frac{1}{2},\frac{1}{2})\]</span></p>
<h4 id="ground-truth-计算">Ground-Truth 计算</h4>
<p>参考官方代码库参数设置，<span class="math inline">\(S=3\)</span>,<span class="math inline">\(\delta=0.5\)</span>，假设真实的目标中心相对前景点的坐标为<span class="math inline">\((2.125,1.375)\)</span>，则对应的bin和res计算如下： X轴： <span class="math display">\[bin_x^{(p)}=\lfloor\frac{2.125-0+3}{0.5}\rfloor=10\]</span> <span class="math display">\[res_x^{(p)}=\frac{1}{0.5}(2.125-0+3-(10*0.5+0.25))=-0.25\]</span> 同理Z轴计算如下： <span class="math display">\[bin_z^{(p)}=\lfloor\frac{1.375-0+3}{0.5}\rfloor=8\]</span> <span class="math display">\[res_z^{(p)}=\frac{1}{0.5}(1.375-0+3-(8*0.5+0.25))=0.25\]</span></p>
<figure>
<img data-src="https://i.imgur.com/7mQkKBl.png" alt="回归计算图示" /><figcaption aria-hidden="true">回归计算图示</figcaption>
</figure>
<h4 id="方位角计算">方位角计算</h4>
<h5 id="第一阶段-1">第一阶段</h5>
<p>在第一阶段，考虑方位角的表示，将<span class="math inline">\(2\pi\)</span>划分为<span class="math inline">\(n\)</span>个bin，原文中<span class="math inline">\(n=12\)</span>，则<span class="math inline">\(\delta=\frac{\pi}{6}\)</span>，<span class="math inline">\(S=0\)</span>，故 <span class="math display">\[
bin_{\theta}^{(p)}=\lfloor \frac{\theta^p-\theta^{(p)}+S}{\delta} \rfloor
\]</span> 量化方位角位角表示为<span class="math inline">\(\lfloor \theta^p-\theta^{(p)} \rfloor=bin_{\theta}^{(p)}*\delta - \mathcal{S}\)</span>，原始方位角偏差表示为<span class="math inline">\({\theta}^p-{\theta}^{(p)}\)</span> 故残差可表示为 <span class="math display">\[
res_{\theta}^{(p)}=\theta^p-\theta^{(p)} - \lfloor \frac{\theta^p-\theta^{(p)}}{\delta} \rfloor
\]</span> 代入得 <span class="math display">\[
res_{\theta}^{(p)}=\theta^p-\theta^{(p)}+\mathcal{S}-bin_{\theta}^{(p)}*\delta \in [0,\delta)
\]</span> 减去偏执<span class="math inline">\(\frac{\delta}{2}\)</span>，保证数据正负分布 <span class="math display">\[res_{\theta}^{(p)}=\theta^p-\theta^{(p)}+\mathcal{S}-bin_{\theta}^{(p)}*\delta-\frac{\delta}{2} \in [-\frac{\delta}{2},\frac{\delta}{2})\]</span> 标准化处理得，除以系数<span class="math inline">\(\frac{\delta}{2}\)</span>得 <span class="math display">\[{res_{\theta}^{(p)}}=\frac{2}{\delta}\big(\theta^p-\theta^{(p)}+\mathcal{S}-(bin_x^{(p)}*\delta+\frac{\delta}{2})\big)\in[-1,1)\]</span></p>
<h4 id="第二阶段">第二阶段</h4>
<figure>
<img data-src="https://i.imgur.com/9dADvbT.png" alt="方位角示图" /><figcaption aria-hidden="true">方位角示图</figcaption>
</figure>
<p>在第二阶段，进一步细化时，考虑方位角的表示，将<span class="math inline">\(\frac{\pi}{2}\)</span>划分为<span class="math inline">\(n\)</span>个bin，原文中<span class="math inline">\(n=12\)</span>，则<span class="math inline">\(\delta=\frac{\pi}{24}\)</span>，<span class="math inline">\(S=\frac{\pi}{4}\)</span>，故 <span class="math display">\[bin_{\theta}^{(p)}=\lfloor \frac{\theta^p-\theta^{(p)}+S}{\delta} \rfloor\]</span> 量化方位角位角表示为<span class="math inline">\(\lfloor \theta^p-\theta^{(p)} \rfloor=bin_{\theta}^{(p)}*\delta - \mathcal{S}\)</span>，原始方位角偏差表示为<span class="math inline">\({\theta}^p-{\theta}^{(p)}\)</span> 故残差可表示为 <span class="math display">\[res_{\theta}^{(p)}=\theta^p-\theta^{(p)} - \lfloor \frac{\theta^p-\theta^{(p)}}{\delta} \rfloor\]</span> 代入得 <span class="math display">\[res_{\theta}^{(p)}=\theta^p-\theta^{(p)}+\mathcal{S}-bin_{\theta}^{(p)}*\delta \in [0,\delta)\]</span> 减去偏执<span class="math inline">\(\frac{\delta}{2}\)</span>，保证数据正负分布 <span class="math display">\[res_{\theta}^{(p)}=\theta^p-\theta^{(p)}+\mathcal{S}-bin_{\theta}^{(p)}*\delta-\frac{\delta}{2} \in [-\frac{\delta}{2},\frac{\delta}{2})\]</span> 标准化处理得，除以系数<span class="math inline">\(\frac{\delta}{2}\)</span>得 <span class="math display">\[{res_{\theta}^{(p)}}=\frac{2}{\delta}\big(\theta^p-\theta^{(p)}+\mathcal{S}-(bin_x^{(p)}*\delta+\frac{\delta}{2})\big)\in[-1,1)\]</span></p>
<h4 id="box回归流程">Box回归流程</h4>
<figure>
<img data-src="https://i.imgur.com/b9JL9bs.png" alt="76 channel regression" /><figcaption aria-hidden="true">76 channel regression</figcaption>
</figure>
<p>如下图所示，计算完真值bin和res后，作者将bin视为分类任务进行学习，也就是将bin看作是一个个类别(共12类)，将res视为回归任务。</p>
<figure>
<img data-src="https://i.imgur.com/kSAlhfQ.png" alt="RPN-ProposalLayer" /><figcaption aria-hidden="true">RPN-ProposalLayer</figcaption>
</figure>
<p>推理阶段，对于基于bin预测的参数<span class="math inline">\(x,z,\theta\)</span>，首先选择预测置信度最高的bin中心。 整体3D边界框回归损失<span class="math inline">\(\mathcal{L}_{reg}\)</span>表示如下：</p>
<ul>
<li>基于bin的回归 <span class="math display">\[\mathcal{L}_{bin}^{(p)}=\sum_{u\in\set{x,z,\theta}}{\mathcal{F}_{cls}(\widehat{bin}_u^{(p)},bin_u^{(p)}) + \mathcal{F}_{reg}(\widehat{res}_u^{(p)},res_u^{(p)})}\]</span></li>
<li>直接回归 <span class="math display">\[\mathcal{L}_{res}^{(p)}=\sum_{v\in\set{y,h,w,l}}{\mathcal{F}_{cls}(\widehat{res}_v^{(p)},res_v^{(p)})}\]</span></li>
<li>总体回归 <span class="math display">\[\mathcal{L}_{reg}=\frac{1}{N_{pos}}\sum_{p\in{pos}}{(\mathcal{L}_{bin}^{(p)}+\mathcal{L}_{res}^{(p)})}\]</span> 其中， <span class="math inline">\(N_{pos}\)</span>：表示前景点的数量； <span class="math inline">\(\widehat{bin}_u^{(p)} \text{和} \widehat{res}_u^{(p)}\)</span>：表示预测的bin分配和前景点p的残差； <span class="math inline">\({bin}_u^{(p)} \text{和} {res}_u^{(p)}\)</span>：表示计算的bin和res目标真值； <span class="math inline">\(\mathcal{F}_{cls}\)</span>：表示交叉熵分类损失； <span class="math inline">\(\mathcal{F}_{reg}\)</span>：表示平滑L1损失；</li>
</ul>
<h4 id="删除冗余proposal">删除冗余Proposal</h4>
<p>就算每个前景点预测一个proposal Box，仍然会输出很多Box，所以下一步就是如何去除冗余的预测框数量。</p>
<figure>
<img data-src="https://i.imgur.com/N8ckrGn.png" alt="Proposal Box" /><figcaption aria-hidden="true">Proposal Box</figcaption>
</figure>
<h4 id="基于距离的nms">基于距离的NMS</h4>
<p>基于鸟瞰视图的IoU进行NMS，以生成少量高质量的proposals。</p>
<ul>
<li>训练阶段 使用IoU=0.85阈值做NMS计算，保留300个proposal来训练第二阶段子网络。</li>
<li>推理阶段 使用IoU=0.80阈值做NMS计算，保留前100个用于细化第二阶段子网络。</li>
</ul>
<p><img data-src="https://i.imgur.com/kyfKYpu.png" /></p>
<h4 id="相关代码">相关代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decode_bbox_target</span>(<span class="params">roi_box3d, pred_reg, loc_scope, loc_bin_size, num_head_bin, anchor_size,</span></span><br><span class="line"><span class="params">                       get_xz_fine=<span class="literal">True</span>, get_y_by_bin=<span class="literal">False</span>, loc_y_scope=<span class="number">0.5</span>, loc_y_bin_size=<span class="number">0.25</span>, get_ry_fine=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param roi_box3d: (N, 7)</span></span><br><span class="line"><span class="string">    :param pred_reg: (N, C)</span></span><br><span class="line"><span class="string">    :param loc_scope:</span></span><br><span class="line"><span class="string">    :param loc_bin_size:</span></span><br><span class="line"><span class="string">    :param num_head_bin:</span></span><br><span class="line"><span class="string">    :param anchor_size:</span></span><br><span class="line"><span class="string">    :param get_xz_fine:</span></span><br><span class="line"><span class="string">    :param get_y_by_bin:</span></span><br><span class="line"><span class="string">    :param loc_y_scope:</span></span><br><span class="line"><span class="string">    :param loc_y_bin_size:</span></span><br><span class="line"><span class="string">    :param get_ry_fine:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    anchor_size = anchor_size.to(roi_box3d.get_device())</span><br><span class="line">    per_loc_bin_num = <span class="built_in">int</span>(loc_scope / loc_bin_size) * <span class="number">2</span></span><br><span class="line">    loc_y_bin_num = <span class="built_in">int</span>(loc_y_scope / loc_y_bin_size) * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># recover xz localization</span></span><br><span class="line">    x_bin_l, x_bin_r = <span class="number">0</span>, per_loc_bin_num</span><br><span class="line">    z_bin_l, z_bin_r = per_loc_bin_num, per_loc_bin_num * <span class="number">2</span></span><br><span class="line">    start_offset = z_bin_r</span><br><span class="line"></span><br><span class="line">    x_bin = torch.argmax(pred_reg[:, x_bin_l: x_bin_r], dim=<span class="number">1</span>)</span><br><span class="line">    z_bin = torch.argmax(pred_reg[:, z_bin_l: z_bin_r], dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    pos_x = x_bin.<span class="built_in">float</span>() * loc_bin_size + loc_bin_size / <span class="number">2</span> - loc_scope</span><br><span class="line">    pos_z = z_bin.<span class="built_in">float</span>() * loc_bin_size + loc_bin_size / <span class="number">2</span> - loc_scope</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> get_xz_fine:</span><br><span class="line">        x_res_l, x_res_r = per_loc_bin_num * <span class="number">2</span>, per_loc_bin_num * <span class="number">3</span></span><br><span class="line">        z_res_l, z_res_r = per_loc_bin_num * <span class="number">3</span>, per_loc_bin_num * <span class="number">4</span></span><br><span class="line">        start_offset = z_res_r</span><br><span class="line"></span><br><span class="line">        x_res_norm = torch.gather(pred_reg[:, x_res_l: x_res_r], dim=<span class="number">1</span>, index=x_bin.unsqueeze(dim=<span class="number">1</span>)).squeeze(dim=<span class="number">1</span>)</span><br><span class="line">        z_res_norm = torch.gather(pred_reg[:, z_res_l: z_res_r], dim=<span class="number">1</span>, index=z_bin.unsqueeze(dim=<span class="number">1</span>)).squeeze(dim=<span class="number">1</span>)</span><br><span class="line">        x_res = x_res_norm * loc_bin_size</span><br><span class="line">        z_res = z_res_norm * loc_bin_size</span><br><span class="line"></span><br><span class="line">        pos_x += x_res</span><br><span class="line">        pos_z += z_res</span><br><span class="line"></span><br><span class="line">    <span class="comment"># recover y localization</span></span><br><span class="line">    <span class="keyword">if</span> get_y_by_bin:</span><br><span class="line">        y_bin_l, y_bin_r = start_offset, start_offset + loc_y_bin_num</span><br><span class="line">        y_res_l, y_res_r = y_bin_r, y_bin_r + loc_y_bin_num</span><br><span class="line">        start_offset = y_res_r</span><br><span class="line"></span><br><span class="line">        y_bin = torch.argmax(pred_reg[:, y_bin_l: y_bin_r], dim=<span class="number">1</span>)</span><br><span class="line">        y_res_norm = torch.gather(pred_reg[:, y_res_l: y_res_r], dim=<span class="number">1</span>, index=y_bin.unsqueeze(dim=<span class="number">1</span>)).squeeze(dim=<span class="number">1</span>)</span><br><span class="line">        y_res = y_res_norm * loc_y_bin_size</span><br><span class="line">        pos_y = y_bin.<span class="built_in">float</span>() * loc_y_bin_size + loc_y_bin_size / <span class="number">2</span> - loc_y_scope + y_res</span><br><span class="line">        pos_y = pos_y + roi_box3d[:, <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        y_offset_l, y_offset_r = start_offset, start_offset + <span class="number">1</span></span><br><span class="line">        start_offset = y_offset_r</span><br><span class="line"></span><br><span class="line">        pos_y = roi_box3d[:, <span class="number">1</span>] + pred_reg[:, y_offset_l]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># recover ry rotation</span></span><br><span class="line">    ry_bin_l, ry_bin_r = start_offset, start_offset + num_head_bin</span><br><span class="line">    ry_res_l, ry_res_r = ry_bin_r, ry_bin_r + num_head_bin</span><br><span class="line"></span><br><span class="line">    ry_bin = torch.argmax(pred_reg[:, ry_bin_l: ry_bin_r], dim=<span class="number">1</span>)</span><br><span class="line">    ry_res_norm = torch.gather(pred_reg[:, ry_res_l: ry_res_r], dim=<span class="number">1</span>, index=ry_bin.unsqueeze(dim=<span class="number">1</span>)).squeeze(dim=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> get_ry_fine:</span><br><span class="line">        <span class="comment"># divide pi/2 into several bins</span></span><br><span class="line">        angle_per_class = (np.pi / <span class="number">2</span>) / num_head_bin</span><br><span class="line">        ry_res = ry_res_norm * (angle_per_class / <span class="number">2</span>)</span><br><span class="line">        ry = (ry_bin.<span class="built_in">float</span>() * angle_per_class + angle_per_class / <span class="number">2</span>) + ry_res - np.pi / <span class="number">4</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        angle_per_class = (<span class="number">2</span> * np.pi) / num_head_bin</span><br><span class="line">        ry_res = ry_res_norm * (angle_per_class / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># bin_center is (0, 30, 60, 90, 120, ..., 270, 300, 330)</span></span><br><span class="line">        ry = (ry_bin.<span class="built_in">float</span>() * angle_per_class + ry_res) % (<span class="number">2</span> * np.pi)</span><br><span class="line">        ry[ry &gt; np.pi] -= <span class="number">2</span> * np.pi</span><br><span class="line"></span><br><span class="line">    <span class="comment"># recover size</span></span><br><span class="line">    size_res_l, size_res_r = ry_res_r, ry_res_r + <span class="number">3</span></span><br><span class="line">    <span class="keyword">assert</span> size_res_r == pred_reg.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    size_res_norm = pred_reg[:, size_res_l: size_res_r]</span><br><span class="line">    hwl = size_res_norm * anchor_size + anchor_size</span><br><span class="line"></span><br><span class="line">    <span class="comment"># shift to original coords</span></span><br><span class="line">    roi_center = roi_box3d[:, <span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">    shift_ret_box3d = torch.cat((pos_x.view(-<span class="number">1</span>, <span class="number">1</span>), pos_y.view(-<span class="number">1</span>, <span class="number">1</span>), pos_z.view(-<span class="number">1</span>, <span class="number">1</span>), hwl, ry.view(-<span class="number">1</span>, <span class="number">1</span>)), dim=<span class="number">1</span>)</span><br><span class="line">    ret_box3d = shift_ret_box3d</span><br><span class="line">    <span class="keyword">if</span> roi_box3d.shape[<span class="number">1</span>] == <span class="number">7</span>:</span><br><span class="line">        roi_ry = roi_box3d[:, <span class="number">6</span>]</span><br><span class="line">        ret_box3d = rotate_pc_along_y_torch(shift_ret_box3d, - roi_ry)</span><br><span class="line">        ret_box3d[:, <span class="number">6</span>] += roi_ry</span><br><span class="line">    ret_box3d[:, [<span class="number">0</span>, <span class="number">2</span>]] += roi_center[:, [<span class="number">0</span>, <span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret_box3d</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="第二阶段-1">第二阶段</h2>
<p>在获得第一阶段生成的一系列3D边界框后，我们需要进一步优化Box的位置和朝向细节。为了学习每个proposal的局部特征，作者提出了根据每个3D预选框的位置，从第一阶段汇集3D点(xyz, depth, intensity)和相应的点特征，便于后续更好得进行框得细节优化。</p>
<h3 id="区域池化">区域池化</h3>
<h4 id="扩大候选框范围">扩大候选框范围</h4>
<p>如下图所示，将候选框得范围扩大一个常数<span class="math inline">\(\eta\)</span>，表达如下：</p>
<ul>
<li>第一阶段生成的候选框 <span class="math display">\[b_i=(x_i,y_i,z_i,h_i,w_i,l_i,\theta_i)\]</span></li>
<li>扩大<span class="math inline">\(\eta\)</span>后的候选框 <span class="math display">\[b_i^e=(x_i, y_i, z_i, h_i+\eta, w_i+\eta, l_i+\eta, \theta_i)\]</span></li>
</ul>
<figure>
<img data-src="https://i.imgur.com/Diaxp82.png" alt="扩大候选框" /><figcaption aria-hidden="true">扩大候选框</figcaption>
</figure>
<figure>
<img data-src="https://i.imgur.com/qcigbhB.png" alt="扩大范围对性能的影响" /><figcaption aria-hidden="true">扩大范围对性能的影响</figcaption>
</figure>
<h4 id="特征聚合roi_pooling">特征聚合(ROI_Pooling)</h4>
<figure>
<img data-src="https://i.imgur.com/qwA8Ymp.png" alt="ROI Pooling and transformation" /><figcaption aria-hidden="true">ROI Pooling and transformation</figcaption>
</figure>
<p>对扩大后的候选框内的所有点进行特征聚合，主要包括：</p>
<ol type="1">
<li>原始点云坐标<span class="math inline">\((x,y,z)\)</span>；</li>
<li>激光反射强度<span class="math inline">\(intensity\)</span>；</li>
<li>原始点云深度信息(d)；</li>
<li>原始点的类别信息(前景点，背景点)m；</li>
<li>第一阶段由PointNet++网络生成的<span class="math inline">\(C\)</span>维特征向量；</li>
</ol>
<h3 id="标准坐标变换">标准坐标变换</h3>
<p>标准坐标系统的定义：</p>
<ol type="1">
<li>坐标原点是候选框的中心；</li>
<li>X和Z轴近似与地面平行，X轴指向候选框的朝向；</li>
<li>Y轴垂直向下；</li>
</ol>
<figure>
<img data-src="https://i.imgur.com/TeRLPcZ.png" alt="标准坐标变换" /><figcaption aria-hidden="true">标准坐标变换</figcaption>
</figure>
<h4 id="局部特征">局部特征</h4>
<p>尽管标准坐标变换能够提升局部空间特征学习的稳定性，但却不可避免得丢失了每个物体得深度信息。例如，由于激光雷达传感器的角度扫描分辨率固定，远处物体的点通常要比附近物体少得多。为了补偿丢失的深度信息，作者引入了点到传感器的距离信息，并加入到点的特征中： <span class="math display">\[d^{(p)}=\sqrt{(x^{(p)})^2,(y^{(p)})^2,(z^{(p)})^2 }\]</span></p>
<h3 id="候选框细化的特征学习">候选框细化的特征学习</h3>
<p>如下图所示，通过结合变换后的局部空间点<span class="math inline">\(\tilde{p}\)</span>和以及他们的来自第一阶段的全局语义特征<span class="math inline">\(f^{(p)}\)</span>，来进一步细化框和置信度。</p>
<p><img data-src="https://i.imgur.com/UFJtQI0.png" /></p>
<figure>
<img data-src="https://i.imgur.com/7Ou7d2W.png" alt="feature merge" /><figcaption aria-hidden="true">feature merge</figcaption>
</figure>
<p>进一步获得用于置信度分类和框细化的判别性特征向量。</p>
<p><img data-src="https://i.imgur.com/PlexIPj.png" /> <img data-src="https://i.imgur.com/G3Nb70B.png" alt="SA" /> <img data-src="https://i.imgur.com/3f8EokP.png" alt="Box Reg" /></p>
<h3 id="候选框细化损失">候选框细化损失</h3>
<p>作者继续采用基于bin的回归损失来细化候选框，如果真实框的3D IoU大于0.55，则将其分配给3D候选框用以框的细化学习。同时，3D候选框和相应的3D真实框转换到标准坐标系统下，即 - 3D proposal Box <span class="math display">\[b_{i}=(x_{i},y_{i},z_{i},h_{i},w_{i},l_{i},\theta{i})\]</span> - 3D ground-truth Box <span class="math display">\[b_{i}=(x_{i}^{gt},y_{i}^{gt},z_{i}^{gt},h_{i}^{gt},w_{i}^{gt},l_{i}^{gt},\theta{i}^{gt})\]</span> 相应坐标变换后为： - 3D proposal Box(CT) <span class="math display">\[\tilde{b_{i}}=(0,0,0,h_{i},w_{i},l_{i},0)\]</span> - 3D ground-truth Box(CT) <span class="math display">\[\tilde{b_{i}}=(x_{i}^{gt}-x_i,y_{i}^{gt}-y_i,z_{i}^{gt}-z_i,h_{i}^{gt},w_{i}^{gt},l_{i}^{gt},\theta{i}^{gt}-\theta_i)\]</span> 第<span class="math inline">\(i\)</span>个候选框的中心位置训练目标<span class="math inline">\((bin_{\vartriangle{x}}^i,bin_{\vartriangle{z}}^i,res_{\vartriangle{x}}^i,res_{\vartriangle{z}}^i,res_{\vartriangle{y}}^i)\)</span>设置与之前的相同，除了使用较小的搜索范围<span class="math inline">\(\mathcal{S}\)</span>来细化3D候选框的位置。至于3D Box的大小任然直接回归残差<span class="math inline">\((res_{\vartriangle{h}}^i,res_{\vartriangle{w}}^i,res_{\vartriangle{l}}^i)\)</span>。</p>
<h4 id="细化损失">细化损失</h4>
<p><span class="math display">\[\mathcal{L}_{refine}=\frac{1}{\lVert\mathcal{B}\rVert}\sum_{i \in \mathcal{B}}{\mathcal{F}_{cls}(prob_i,label_i)} + \frac{1}{\lVert\mathcal{B_{pos}}\rVert}\sum_{i \in \mathcal{B_{pos}}}{(\tilde{\mathcal{L}}_{bin}^{i}+\tilde{\mathcal{L}}_{res}^{i})}\]</span> 其中 <span class="math inline">\(\mathcal{B}\)</span>：第一阶段的候选框集合； <span class="math inline">\(\mathcal{B_{pos}}\)</span>：保留用于回归的正候选框；</p>
<p>最后基于鸟瞰视角的定向NMS，其IoU阈值=0.01，去除重叠的边界框。</p>
<h2 id="实验数据">实验数据</h2>
<p><img data-src="https://i.imgur.com/aNhRcqU.png" /></p>
<h2 id="参考">参考</h2>
<ol type="1">
<li><span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzE4MTIuMDQyNDQ=">PointRCNN: 3D Object Proposal Generation and Detection from Point Cloud<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>3D Object Detector</category>
        <category>PointRCNN</category>
      </categories>
      <tags>
        <tag>3D Object Detector</tag>
        <tag>LiDAR</tag>
      </tags>
  </entry>
  <entry>
    <title>3D Object Detector Introduce</title>
    <url>/2024/08/06/3D-ObjectDetector/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>在自动驾驶领域，感知系统是必不可少的模块，通常使用多模态数据(激光雷达的点云、摄像头的图片、高清地图等)作为输入，预测道路上关键元素的几何形状和语义信息，为目标跟踪、轨迹预测和路径规划模块提供可靠的观察结果。 为了全面了解行驶环境，涉及许多视觉任务，包括：对象检测、跟踪、车道线检测、语义分割和实例分割。其中，3D对象检测是自动驾驶感知系统最不可或缺的任务。 3D对象检测的目标：</p>
<ol type="1">
<li>位置：(x, y, z)</li>
<li>大小：(l, w , h)</li>
<li>朝向： (<span class="math inline">\(\theta\)</span>)</li>
<li>类别： (轿车、自行车、行人...)</li>
</ol>
<p>相对于2D对象检测，其只在图像上生成边界框，而忽略物体与当前车辆的实际距离信息。3D对象检测重点关注于现实世界3维坐标系中的对象位置和识别。通过3D对象检测预测的几何信息可以直接测量当前车辆于关键对象之间的距离。</p>
<figure>
<img data-src="https://i.imgur.com/vPtnare.jpeg" alt="保时捷" /><figcaption aria-hidden="true">保时捷</figcaption>
</figure>
<span id="more"></span>
<h2 id="d对象检测是什么">3D对象检测是什么？</h2>
<p>简单讲就是从传感器数据中预测3D对象的边界框，使用简洁的数学公式表达通用的3D对象检测如下： <span class="math display">\[\beta = f_{det}(\Gamma_{sensor})\]</span> 其中</p>
<ol type="1">
<li><span class="math inline">\(\beta = \{B_1, B_2,...,B_N \}\)</span>：表示场景中 N 个 3D对象的集合；</li>
<li><span class="math inline">\(f_{det}\)</span>：表示3D对象检测模型；</li>
<li><span class="math inline">\(\Gamma_{sensor}\)</span>：表示一个或多个传感器的输入数据；</li>
</ol>
<h3 id="如何表示3d对象的边界框">如何表示3D对象的边界框</h3>
<p>通常3D对象被表示为包含该对象的3D长方体，即： <span class="math display">\[B = [x_c,y_c,z_c,l,w,h,\theta,class]\]</span> 其中，</p>
<ol type="1">
<li><span class="math inline">\([x_c,y_c,z_c]\)</span>：表示长方体的3D中心坐标；</li>
<li><span class="math inline">\([l,w,h]\)</span>：表示长方体的长、宽、高；</li>
<li><span class="math inline">\(\theta\)</span>： 表示航向角，即地平面上长方体的偏航角；</li>
<li><span class="math inline">\(class\)</span>：表示3D对象的类别，例如：汽车、自行车、行人...；</li>
</ol>
<h3 id="如何表示传感器输入">如何表示传感器输入</h3>
<p>有许多类型传感器可以为3D对象检测提供原始数据，其中，激光雷达(LiDAR)、摄像头和毫米波雷达是三个最广泛使用的传感器类型。</p>
<h4 id="d毫米波雷达">3D毫米波雷达</h4>
<h5 id="优点">优点</h5>
<ol type="1">
<li>检测范围长；</li>
<li>适用不同的天气条件；</li>
<li>可提供额外的相对速度测量；</li>
</ol>
<h5 id="缺点">缺点</h5>
<ol type="1">
<li>测量受物体散射影响；</li>
<li>静止目标和地物杂波混在一起，难以区分；</li>
<li>横穿车辆和行人多普勒为零或很低，难以检测；</li>
<li>高处物体和地面目标不能区分，容易造成误刹，影响安全性；</li>
<li>角度分辨率低，远处目标位置精度低，误差大；</li>
<li>点云稀疏，难以识别目标类型。</li>
</ol>
<h5 id="数据格式">数据格式</h5>
<p><span class="math display">\[[r,\theta,v] \to [x,y,v_x,v_y]\]</span> <img data-src="https://s2.loli.net/2024/08/12/e12MGRlA75JdYTB.png" alt="集合表示" /></p>
<h4 id="d毫米波雷达-1">4D毫米波雷达</h4>
<h5 id="优点-1">优点</h5>
<ol type="1">
<li>最远探测距离大幅提高，可达300多米，比激光雷达和视觉传感器都要远；</li>
<li>4D毫米波雷达水平角度分辨率较高，通常可以达到1°的角度分辨率；</li>
<li>4D毫米波雷达可以测量俯仰角度，可达到2°的角度分辨率，可在150m处区分地物和立交桥；</li>
<li>多普勒为零或很低的横穿车辆和行人, 通过高精度的水平角和俯仰角可以有效识别目标；</li>
<li>目标点云更密集，信息更丰富，更适合与深度学习框架结合。</li>
</ol>
<h5 id="数据格式-1">数据格式</h5>
<figure>
<img data-src="https://s2.loli.net/2024/08/12/pzrVPio7sFJ42aK.png" alt="球坐标系" /><figcaption aria-hidden="true">球坐标系</figcaption>
</figure>
<p>其中，图像中的每个像素在球坐标系中由径向距离(<span class="math inline">\(r\)</span>), 方位角(<span class="math inline">\(\theta\)</span>), 倾斜角(<span class="math inline">\(\varphi\)</span>)表示。</p>
<p><span class="math inline">\([r,\theta,\varphi,v] \to [x,y,z,v_x,v_y]\)</span></p>
<h4 id="摄像头">摄像头</h4>
<h5 id="优点-2">优点</h5>
<ol type="1">
<li>价格便宜；</li>
<li>理解语义信息(红绿灯)；</li>
</ol>
<h5 id="缺点-1">缺点</h5>
<ol type="1">
<li>只能捕获外观信息；</li>
<li>不能够直接获取场景的3D结构信息，从图像估计的深度通常误差很大；</li>
<li>受极端天气(雾天，雨天)和时间(白天，晚上)的影响；</li>
</ol>
<h5 id="数据格式-2">数据格式</h5>
<p><span class="math display">\[\Gamma_{cam} \in R^{[w,h,3]} \]</span> 其中，每个像素由 [red, green, blue] 组成。</p>
<h4 id="激光雷达">激光雷达</h4>
<h5 id="优点-3">优点</h5>
<ol type="1">
<li>可以获得场景较高细粒度的3D结构信息；</li>
<li>不易受天气和时间的影响；</li>
</ol>
<h5 id="缺点-2">缺点</h5>
<ol type="1">
<li>价格贵；</li>
<li>机械式的寿命短；</li>
</ol>
<h5 id="数据格式-3">数据格式</h5>
<h6 id="距离图像">距离图像</h6>
<p>在一个扫描周期内，一次发射m一束光束，进行n次测量，可以生成如下距离图像。 <span class="math display">\[\Gamma_{range} \in R^{[m,n,3]} \]</span></p>
<figure>
<img data-src="https://s2.loli.net/2024/08/12/pzrVPio7sFJ42aK.png" alt="球坐标系" /><figcaption aria-hidden="true">球坐标系</figcaption>
</figure>
<p>其中，图像中的每个像素在球坐标系中由径向距离(<span class="math inline">\(r\)</span>), 方位角(<span class="math inline">\(\theta\)</span>), 倾斜角(<span class="math inline">\(\varphi\)</span>)表示。</p>
<figure>
<img data-src="https://s2.loli.net/2024/08/12/D3ty4xrdYFu1QwU.png" alt="激光雷达扫描方式" /><figcaption aria-hidden="true">激光雷达扫描方式</figcaption>
</figure>
<h6 id="点云数据">点云数据</h6>
<p>点云数据可以由球坐标系转笛卡尔坐标系。 <span class="math display">\[[r,\theta,\varphi] \to [x,y,z]\]</span> 点云可以表示为 <span class="math display">\[\Gamma_{point} \in R^{[N,3]} \]</span> 其中，<span class="math inline">\(N\)</span>表示场景中点数，每个点包含$[x,y,z]$3个坐标通道。</p>
<figure>
<img data-src="https://s2.loli.net/2024/08/12/nR9lFHLGaIXsBft.png" alt="点云表示" /><figcaption aria-hidden="true">点云表示</figcaption>
</figure>
<h4 id="传感器数据汇总">传感器数据汇总</h4>
<p>如下图所示，自动驾驶车辆可以融合多类型传感器数据，输入3D对象检测网络，检测网络负责预测3D边界框。 <img data-src="https://s2.loli.net/2024/08/12/aCDQS2nU5TruLVt.png" alt="传感器数据链路" /></p>
<h4 id="对比2d对象检测">对比2D对象检测</h4>
<p>3D对象检测借鉴了许多2D领域的设计范式：</p>
<ol type="1">
<li>Anchors: 一组预定义的框;</li>
<li>NMS: 非极大值抑制;</li>
<li>ROI: 生成一组可能包含目标物体的候选区域;</li>
<li>Refinement: 预测阶段对粗略的检测结果进行进一步的优化和提升的过程，例如，特征融合、残差网络、注意力机制等;</li>
</ol>
<p>但是，从很多方面来讲，3D检测并不是2D检测方法对3D空间的简单适配，存在有如下特征：</p>
<ol type="1">
<li>数据表示多样性 3D检测必须处理异构的数据表示(点云、图像、距离图像等)，对于点云输入的检测网络需要采用新型算子和网络来处理不规则的点数据，混合点云和图像数据的检测网络需要采用特殊的融合机制(前融合，特征融合、后融合)。</li>
<li>视角的多样性 3D对象检测网络通常利用不同的投影试图来生成对象预测，与从透视图(近大远小)中检测对象的2D对象检测方法相反，3D对象检测必须考虑不同的试图来检测3D对象，例如鸟瞰图、点视图、圆柱视图。</li>
<li>精度要求高 3D对象检测对3D空间中的对象精准定位有着更高的要求，分米级的定位误差可能会导致行人和自行车等小物体的检测失败，而2D对象检测几个像素的定位误差仍能保持较高的IoU。</li>
</ol>
<h4 id="对比室内场景">对比室内场景</h4>
<ol type="1">
<li>点云分布不同 室内场景点云在扫描表面分布更均匀，点数更多，对于自动驾驶场景，大多数点落在传感器附近，远处的3D对象只能扫描到几个点；</li>
<li>计算实时性 自动驾驶场景下感知必须是实时的，以避免发生事故。因此所采用的算法必须计算高效，否则无法实际应用。</li>
</ol>
]]></content>
      <categories>
        <category>3D Object Detector</category>
        <category>Introduce</category>
      </categories>
      <tags>
        <tag>3D Object Detector</tag>
        <tag>LiDAR</tag>
      </tags>
  </entry>
  <entry>
    <title>Graph Nueral Network</title>
    <url>/2024/08/18/GraphNeuralNetwork/</url>
    <content><![CDATA[<h2 id="应用领域">应用领域</h2>
<p><img data-src="https://i.imgur.com/yhg8Q4N.png" alt="图(a)道路网络 ；图(b)分子结构；图(c)电路图" /> <img data-src="https://i.imgur.com/TtTcROe.png" alt="图(d)飞机点云图" /> <img data-src="https://i.imgur.com/EpXSl6d.png" alt="图(a)社交网络-无向；图(b)论文引用网络-有向；图(c)知识图谱-有向-异构" /></p>
<span id="more"></span>
<h3 id="任务目标">任务目标</h3>
<p>可以根据预测目标是节点、边沿还是整个图的属性来进行广泛的分组。</p>
<h4 id="图级别任务">图级别任务</h4>
<ul>
<li>回归任务 预测某个分子的熔点；</li>
<li>分类任务 预测某个分子是否具有毒性； 特定分子是否溶于水；</li>
</ul>
<figure>
<img data-src="https://i.imgur.com/QiouUeB.png" alt="Graph分类" /><figcaption aria-hidden="true">Graph分类</figcaption>
</figure>
<h4 id="节点级任务">节点级任务</h4>
<p>网络使用图结构和节点嵌入为图的每个节点分配一个标签（分类）或一个或多个值（回归）。 例如，上述飞机的点云图，预测节点是属于机身还是机翼；</p>
<figure>
<img data-src="https://i.imgur.com/7DJb1rc.png" alt="Node分类" /><figcaption aria-hidden="true">Node分类</figcaption>
</figure>
<h4 id="边沿预测任务">边沿预测任务</h4>
<p>网络预测节点 n 和 m 之间是否应该存在边。 例如，在社交网络环境中，网络可能会预测两个人是否认识并喜欢对方，如果是的话，建议他们进行联系。 了解蛋白质网络中的一些相互作用，并希望预测任何其他相互作用的存在；</p>
<figure>
<img data-src="https://i.imgur.com/lxYizxU.png" alt="边沿预测" /><figcaption aria-hidden="true">边沿预测</figcaption>
</figure>
<h4 id="图表示学习">图表示学习</h4>
<p>我们还可以在图上使用深度学习来发现有用的内部表示，这些表示随后可以促进一系列下游任务。 例如，我们可以通过在大型分子结构语料库上训练深度学习系统来寻求建立分子的基础模型。目标是，一旦经过训练，这样的基础模型就可以通过使用小型标记数据集来针对特定任务进行微调。</p>
<h2 id="图表示">图表示</h2>
<ul>
<li>节点嵌入： 存储节点处的信息，例如社交网络中，每个人都可以通过包含兴趣、年龄和学历等信息组成的固定长度向量表征；</li>
<li>边沿嵌入：存储边沿处的信息，例如道路网络中，每个边沿可以包含道路长度、车道数、事故频率和限速等信息表征； 图由一组<span class="math inline">\(\mathbf{N}\)</span>个点相互连接组成的<span class="math inline">\(\mathbf{E}\)</span>个边沿组成，可以使用3个矩阵<span class="math inline">\((\mathbf{A}, \mathbf{X}, \mathbf{E})\)</span>对其进行编码，分别代表<code>图结构</code>、<code>节点嵌入</code>和<code>边沿嵌入</code>。</li>
</ul>
<figure>
<img data-src="https://i.imgur.com/JIho9IF.png" alt="数据嵌入" /><figcaption aria-hidden="true">数据嵌入</figcaption>
</figure>
<h3 id="邻接矩阵">邻接矩阵</h3>
<p>图的结构可以使用邻接矩阵表示节点间的连接关系。无向图，该矩阵始终是对称的。</p>
<p><img data-src="https://i.imgur.com/pkj1KrF.png" /></p>
<blockquote>
<p>如果图很大如何存储？</p>
</blockquote>
<p>对于大型稀疏图来说，使用邻接矩阵存储会浪费大量内存，因为大部分元素都是0。 存储为连接列表 (m, n) 是一种更节省内存的方法，尤其适用于图节点数量众多但边相对较少的情况。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">edge_list = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">4</span>)]</span><br></pre></td></tr></table></figure>
<h3 id="节点嵌入矩阵">节点嵌入矩阵</h3>
<p>第<span class="math inline">\(\mathbf{n}\)</span>个节点具有一个长度为<span class="math inline">\(\mathbf{D}\)</span>的节点嵌入向量<span class="math inline">\(\mathbf{x}^n\)</span> ，将这些嵌入向量连接到一起并存储到<span class="math inline">\(\mathbf{D}\times\mathbf{N}\)</span>的节点数据矩阵<span class="math inline">\(\mathbf{X}\)</span>中。</p>
<h3 id="边沿嵌入矩阵">边沿嵌入矩阵</h3>
<p>第<span class="math inline">\(\mathbf{e}\)</span>个边沿具有一个长度为<span class="math inline">\(\mathbf{D}_E\)</span>的边沿嵌入向量<span class="math inline">\(\mathbf{e}^e\)</span>，将这些嵌入向量连接到一起并存储到<span class="math inline">\(\mathbf{D}_E\times\mathbf{E}\)</span>的节点数据矩阵<span class="math inline">\(\mathbf{E}\)</span>中。</p>
<h2 id="等变性和不变性">等变性和不变性</h2>
<p>图中节点的索引顺序是任意的，节点索引的排列不会影响到图的表达，任何模型都必须尊重这一属性。</p>
<h3 id="节点索引的排序">节点索引的排序</h3>
<p>可以使用一个排列矩阵<span class="math inline">\(P\)</span>表示节点的重新排序，其每行和每列只包含一个1。 例如，实现排列顺序从 <span class="math inline">\((A,B,C,D,E) \to (C,E,A,D,B)\)</span>，则相应的排列矩阵表示如下： <span class="math display">\[
P = \begin{pmatrix}
   0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
   0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 0
\end{pmatrix}\]</span></p>
<p>可以通过矩阵<span class="math inline">\(P\)</span>实现对矩阵<span class="math inline">\(X\)</span>的重新排列 <span class="math display">\[\tilde{X}=XP\]</span> 对于邻接矩阵<span class="math inline">\(A\)</span>，行列都会被排列 <span class="math display">\[\tilde{A}=P^TAP\]</span></p>
<h3 id="不变性">不变性</h3>
<figure>
<img data-src="https://i.imgur.com/40m2RJE.png" alt="不变性" /><figcaption aria-hidden="true">不变性</figcaption>
</figure>
<p>当将深度学习应用于图结构数据时，我们需要以数字形式表示图结构，以便将其输入神经网络，这需要我们为节点分配顺序。然而，我们选择的具体顺序是任意的，因此确保图的任何全局属性不依赖于此顺序非常重要。换句话说，网络预测必须对节点标签重新排序保持不变， <span class="math display">\[y(\tilde{X},\tilde{A})=y(X,A)\]</span> 其中，<span class="math inline">\(y(.)\)</span>函数是网络的输出。</p>
<h3 id="等变性">等变性</h3>
<figure>
<img data-src="https://i.imgur.com/0ShUBEv.png" alt="等变性" /><figcaption aria-hidden="true">等变性</figcaption>
</figure>
<p>我们可能还想做出与各个节点相关的预测。在这种情况下，如果我们对节点标签重新排序，则相应的预测应该显示相同的重新排序，以便给定的预测始终与相同的节点相关联，而不管顺序的选择如何。换句话说，节点预测应该与节点标签重新排序是等变的。这可以表示为 <span class="math display">\[\bf{y}(\tilde{X},\tilde{A}) = \bf{y}(X,A)P\]</span> 其中，<span class="math inline">\(\bf{y}(.)\)</span>函数是网络输出的向量，每个节点一个元素.</p>
<h2 id="消息传递">消息传递</h2>
<p>在应用深度神经网络在图结构数据时，在节点标签排列情况下，确保等变性和不变性是设计网络时的关键考虑因素。 - 节点级预测网络：要求整个网络保持等变性； - 图级别任务：对于不同的输入排列，要求最后一层要保持不变性； - 确保每一层都是高度灵活的非线性函数，并且其参数可微； - 图的输入尺寸是变化的，固定长度表示是不合适的，需要能处理可变长度输入； - 参数共享;</p>
<h3 id="卷积滤波">卷积滤波</h3>
<p>为了开发满足上述要求的网络框架，可以从卷积神经网络中寻求灵感； - 图像可以视为图结构数据的特定实例； - 节点：像素 - 边沿：图像中的相邻的像素对；</p>
<p><img data-src="https://i.imgur.com/AQOAPy0.png" /></p>
<p>卷积滤波器更新<span class="math inline">\(l+1\)</span>层像素表达式如下： <span class="math display">\[z_i^{(l+1)}=f\large(\sum_jw_jz_j^{(l)} + b\large)\]</span> 上述表达可知，如果<span class="math inline">\(l+1\)</span>层的像素重新排列，其输出并不具备 等变性，因为其权重向量。 尝试如下修改： <span class="math display">\[z_i^{(l+1)}=f\large(w_{neigh}\sum_jz_j^{(l)} + w_{self}z_i^{(l)}+ b\large)\]</span> 上述表达式，可以解释为通过从邻近节点传递到节点<span class="math display">\[i\]</span>的消息传递来收集来自邻近节点的信息，从而更新节点<span class="math inline">\(i\)</span>处的局部表示<span class="math inline">\(z_i\)</span>。 上述表达式中，通过简单的 求和函数 来聚合相邻节点的信息。对于输入节点的排序，显然是不变的。 这种不变性取决于所用节点共享参数<span class="math inline">\(w_{neigh}, w_{self}, b\)</span>。</p>
<h3 id="图卷积网络gcn">图卷积网络(GCN)</h3>
<p>准确得讲，本文主要介绍 <code>spatial-based convolutional graph neural networks</code>(基于空间的卷积图神经网络)，简称 <code>GCN</code>。之所以称为基于空间，是因为使用原始的图结构信息。这与基于频谱(spectral-based)的方法形成对比，后者在傅里叶域应用卷积。 可以将网络的每层处理分为两个阶段：</p>
<ol type="1">
<li><code>aggregation</code>(聚合) 对于每个节点 n，消息从其邻居传递到该节点并以排列不变的方式组合形成新的向量<span class="math inline">\(z_n^{(l)}\)</span>。 <span class="math display">\[z_n^{(l)} = \large\mathcal{Aggregate}(\{h_m^{(l)}:m \in \mathcal{N}(n)\})\]</span></li>
<li><code>update</code>(更新) 将来自相邻节点的聚合信息(<span class="math inline">\(z_n^{(l)}\)</span>)与来自节点本身的本地信息相结合，并用于计算该节点的修改后的嵌入向量。 <span class="math display">\[\large h_n^{(l+1)}=\mathcal{Update}(h_n^{(l)},z_n^{(l)})\]</span></li>
</ol>
<blockquote>
<p>节点嵌入通常使用观察到的节点数据进行初始化，例如<span class="math inline">\(h_n^{0}=\bf{x}_n\)</span>。</p>
</blockquote>
<p>上述框架称为： 消息传递神经网络</p>
<p><img data-src="https://i.imgur.com/X7mJy1b.png" /></p>
<h4 id="聚合算子">聚合算子</h4>
<ul>
<li>求和 <span class="math display">\[\large\mathcal{Aggregate}(\{h_m^{(l)}:m \in \mathcal{N}(n)\}) = \sum_{m\in\mathcal{N}(n)}h_m^{(l)}\]</span> &gt; 邻接节点较多的节点比邻接节点较少的节点相比，影响更大；</li>
<li>平均值 <span class="math display">\[\large\mathcal{Aggregate}(\{h_m^{(l)}:m \in \mathcal{N}(n)\}) = \frac{1}{|\mathcal{N}(n)|}\sum_{m\in\mathcal{N}(n)}h_m^{(l)}\]</span> 其中<span class="math inline">\(|\mathcal{N}(n)|\)</span>表示邻域集合<span class="math inline">\(\mathcal{N}(n)\)</span>中的节点数。 &gt; 这种归一化方式，丢弃了有关网络结构数据的信息，并被证明不如简单求和强大;</li>
<li>Kipf归一化 <span class="math display">\[\large\mathcal{Aggregate}(\{h_m^{(l)}:m \in \mathcal{N}(n)\}) = \sum_{m\in\mathcal{N}(n)}\frac{h_m^{(l)}}{\sqrt{|\mathcal{N}(n)||\mathcal{N}(m)|}}\]</span></li>
<li>Max Pooling <span class="math display">\[\large\mathcal{Aggregate}(\{h_m^{(l)}:m \in \mathcal{N}(n)\}) = \mathcal{Max}_{m\in\mathcal{N}(n)} h_m^{(l)}\]</span></li>
<li>MLP <span class="math display">\[\large\mathcal{Aggregate}(\{h_m^{(l)}:m \in \mathcal{N}(n)\}) = \mathcal{MLP}_{\theta}\bigg(\sum_{m\in\mathcal{N}(n)} \mathcal{MLP}_{\phi}(h_m^{(l)})\bigg)\]</span> 其中，<span class="math inline">\(\mathcal{MLP}_{\theta}和\mathcal{MLP}_{\phi}\)</span>的参数在<span class="math inline">\(l\)</span>层内共享。</li>
</ul>
<h4 id="感受野">感受野</h4>
<figure>
<img data-src="https://i.imgur.com/ERwsL3W.png" alt="随着层数增多，感受野增大" /><figcaption aria-hidden="true">随着层数增多，感受野增大</figcaption>
</figure>
<h4 id="更新算子">更新算子</h4>
<p><span class="math display">\[\large\mathcal{Update}(h_n^{(l)},z_n^{(l)})=f({W}_{self}h_n^{(l)} + {W}_{neigh}z_n^{l} + b)\]</span> 其中， 1. <span class="math inline">\(f(.)\)</span>表示非线性函数，例如 Relu。 2. <span class="math inline">\(W_{self}, W_{neigh}和b\)</span>表示学习的权重和偏置；</p>
<p>为此，神经网络可以表示为连续变换节点嵌入的一组序列： <span class="math display">\[H^{(1)}=F(X,A,W^{(1)})\]</span> <span class="math display">\[H^{(2)}=F(H^{(1)},A,W^{(2)})\]</span> ... <span class="math display">\[H^{(L)}=F(H^{(L-1)},A,W^{(L)})\]</span> <img data-src="https://i.imgur.com/5bWvMlx.png" /></p>
<h2 id="通用图网络">通用图网络</h2>
<p>目前为止，图网络已经有了很多扩展和变体。</p>
<h3 id="边沿嵌入">边沿嵌入</h3>
<figure>
<img data-src="https://i.imgur.com/XdMtOkZ.png" alt="边沿嵌入" /><figcaption aria-hidden="true">边沿嵌入</figcaption>
</figure>
<p><span class="math display">\[e_{nm}^{l+1}=\mathcal{Update}_{edge}\big(e_{nm}^{(l)},h_n^{(l)},h_m^{(l)}\big)\]</span> <span class="math display">\[z_n^{(l+1)}=\mathcal{Aggregate}_{node}(\set{e_{nm}^{(l)}:m \in \mathcal{N}(n)})\]</span> <span class="math display">\[h_n^{l+1}=\mathcal{Update}_{node}(h_n^{(l)},z_n^{(l+1)})\]</span></p>
]]></content>
      <categories>
        <category>Graph Nueral Network</category>
      </categories>
      <tags>
        <tag>Graph Nueral Network</tag>
        <tag>GNN</tag>
      </tags>
  </entry>
  <entry>
    <title>Home Assistant(Supervisor)安装</title>
    <url>/2022/12/26/Home-Assistant-Supervised-install/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>本文讲述 <strong>Home Assistant Supervisor</strong> 的安装步骤，虽然官方有详细的安装指导，但是由于软件源大都在国外，某些步骤可能需要科学上网才能解决。本文实际部署的硬件平台是 <strong>Raspberry Pi 3 Model</strong>，请参考 <a href="https://zgh551.github.io/2022/12/26/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/">树莓派系统安装</a> 做好硬件和软件环境的准备。</p>
<figure>
<img data-src="https://s3.bmp.ovh/imgs/2023/01/01/eca88d886cc33e9a.jpg" alt="上海天文馆" /><figcaption aria-hidden="true">上海天文馆</figcaption>
</figure>
<span id="more"></span>
<h2 id="前期准备">前期准备</h2>
<h3 id="系统确认">系统确认</h3>
<p>参考官方说明文档 <span class="exturl" data-url="aHR0cHM6Ly93d3cuaG9tZS1hc3Npc3RhbnQuaW8vbW9yZS1pbmZvL3Vuc3VwcG9ydGVkL29z">Operating System<i class="fa fa-external-link-alt"></i></span> 获取目前支持的系统信息，可知，目前 Home Assistant Supervisor 支持的操作系统类型是 Debian 11 (Bullseye)，参考 <a href="https://zgh551.github.io/2022/12/26/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/">树莓派系统安装</a> 完成系统的准备工作。</p>
<h3 id="apparmor配置">Apparmor配置</h3>
<p>默认树莓派最新的发布版本是安装了 apparmor 工具的，Supervisor 要求系统开机时激活apparmor 服务，需要在<code>/boot/cmdline.txt</code>文件中，追加 <code>apparmor=1 security=apparmor</code> 内容。详细参考 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0thbmdhLVdoby9ob21lLWFzc2lzdGFudC9pc3N1ZXMvMjU=">how to enable apparmor<i class="fa fa-external-link-alt"></i></span> 内容。</p>
<h3 id="cgroup配置">cgroup配置</h3>
<p>打开 <code>/etc/default/grub</code> 文件，如果不存该文件则创建，并在文件中写入 <code>systemd.unified_cgroup_hierarchy=false</code> 内容。</p>
<p>打开 <code>/boot/cmdline.txt</code> 文件，并追加 <code>systemd.unified_cgroup_hierarchy=false</code> 内容。</p>
<h3 id="networkmanager配置">NetworkManager配置</h3>
<p>由于Home Assistant Supervisor 需要 <code>NetworkManager</code> 的支持，而树莓派官方系统默认采用 <code>dhcpcd</code>网络配置工具。所以需要通过<strong>raspi-config</strong>工具切换网络配置工具。</p>
<p>通过如下命令，打开树莓派配置工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo raspi-config</span><br></pre></td></tr></table></figure>
<p>如下图所示，选择 <mark>Advanced Options</mark> ：</p>
<p><img data-src="https://s3.bmp.ovh/imgs/2023/01/01/ff1e0866079cc9e0.png" title="" alt="" data-align="center"></p>
<p>进入后，选择 <mark>Network Config</mark> ：</p>
<p><img data-src="https://s3.bmp.ovh/imgs/2023/01/01/25b0190151f2570f.png" title="" alt="" data-align="center"></p>
<p>最后将网络配置器切换到 <mark>NetworkManager</mark>，按下回车键 Enter 保存配置，此时需要会提示是否 reboot ,请选择yes，重启树莓派。</p>
<p><img data-src="https://s3.bmp.ovh/imgs/2023/01/01/b9281b0f4fd84e7a.png" title="" alt="" data-align="center"></p>
<h2 id="supervisor-安装步骤">Supervisor 安装步骤</h2>
<h3 id="依赖软件安装">依赖软件安装</h3>
<p>首先更新系统软件源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update --fix-missing</span><br><span class="line">sudo apt-get upgrade -y</span><br></pre></td></tr></table></figure>
<p>然后通过如下命令安装依赖软件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install \</span><br><span class="line">apparmor \</span><br><span class="line">jq \</span><br><span class="line">wget \</span><br><span class="line">curl \</span><br><span class="line">udisks2 \</span><br><span class="line">libglib2.0-bin \</span><br><span class="line">network-manager \</span><br><span class="line">dbus \</span><br><span class="line">lsb-release \</span><br><span class="line">systemd-journal-remote -y</span><br></pre></td></tr></table></figure>
<h3 id="docker-ce-安装">Docker-CE 安装</h3>
<p>下载安装脚本，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL get.docker.com -o get-docker.sh</span><br></pre></td></tr></table></figure>
<p>国内用户建议通过阿里镜像源进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh get-docker.sh --mirror Aliyun</span><br></pre></td></tr></table></figure>
<p>将当前用户添加进dockert组中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure>
<p>需要重启才能生效。</p>
<h3 id="os-agent-安装">OS-Agent 安装</h3>
<p>由于Supervisor依赖 <strong>OS-Agent</strong> 软件包，但该软件不在Debian官方软件源内，需要前往Github仓库 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hvbWUtYXNzaXN0YW50L29zLWFnZW50">os-agent<i class="fa fa-external-link-alt"></i></span> 下载。</p>
<p><img data-src="https://s3.bmp.ovh/imgs/2023/01/01/99f64464d0d1f039.png" /></p>
<p>通过如下指令查看芯片架构类型：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uname -m</span><br></pre></td></tr></table></figure>
<p>如果输出 <code>aarch64</code> ，则下载 <code>os-agent_1.4.1_linux_aarch64.deb</code> 软件包。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -c https://github.com/home-assistant/os-agent/releases/download/1.4.1/os-agent_1.4.1_linux_aarch64.deb</span><br></pre></td></tr></table></figure>
<p>如果网络无法正常下载，可以尝试添加代理，例如如下代理服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -c https://ghproxy.com/https://github.com/home-assistant/os-agent/releases/download/1.4.1/os-agent_1.4.1_linux_aarch64.deb</span><br></pre></td></tr></table></figure>
<p>然后使用 <code>dpkg</code>命令安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i os-agent_1.4.1_linux_aarch64.deb</span><br></pre></td></tr></table></figure>
<p>判断是否安装成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdbus introspect --system --dest io.hass.os --object-path /io/hass/os</span><br></pre></td></tr></table></figure>
<p>上述命令如果不输出错误信息，而是输出包含 <code>interface</code> 字段的信息则说明安装成功，树莓派安装后输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node /io/hass/os &#123;</span><br><span class="line">  interface org.freedesktop.DBus.Introspectable &#123;</span><br><span class="line">    methods:</span><br><span class="line">      Introspect(out s out);</span><br><span class="line">    signals:</span><br><span class="line">    properties:</span><br><span class="line">  &#125;;</span><br><span class="line">  interface org.freedesktop.DBus.Properties &#123;</span><br><span class="line">    methods:</span><br><span class="line">      Get(in  s interface,</span><br><span class="line">          in  s property,</span><br><span class="line">          out v value);</span><br><span class="line">      GetAll(in  s interface,</span><br><span class="line">             out a&#123;sv&#125; props);</span><br><span class="line">      Set(in  s interface,</span><br><span class="line">          in  s property,</span><br><span class="line">          in  v value);</span><br><span class="line">    signals:</span><br><span class="line">      PropertiesChanged(s interface,</span><br><span class="line">                        a&#123;sv&#125; changed_properties,</span><br><span class="line">                        as invalidates_properties);</span><br><span class="line">    properties:</span><br><span class="line">  &#125;;</span><br><span class="line">  interface io.hass.os &#123;</span><br><span class="line">    methods:</span><br><span class="line">    signals:</span><br><span class="line">    properties:</span><br><span class="line">      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;invalidates&quot;)</span><br><span class="line">      readonly s Version = &#x27;1.4.1&#x27;;</span><br><span class="line">      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;true&quot;)</span><br><span class="line">      readwrite b Diagnostics = false;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="supervisor-安装">Supervisor 安装</h3>
<p>前往 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hvbWUtYXNzaXN0YW50L3N1cGVydmlzZWQtaW5zdGFsbGVyL3JlbGVhc2Vz">Releases · home-assistant/supervised-installer · GitHub<i class="fa fa-external-link-alt"></i></span>下载与 OS-Agent版本匹配的Debian包。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -c https://github.com/home-assistant/supervised-installer/releases/download/1.4.1/homeassistant-supervised.deb</span><br></pre></td></tr></table></figure>
<p>如果网络无法下载，可以尝试如下代理：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -c https://ghproxy.com/https://github.com/home-assistant/supervised-installer/releases/download/1.4.1/homeassistant-supervised.deb</span><br></pre></td></tr></table></figure>
<p>执行安装命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i homeassistant-supervised.deb</span><br></pre></td></tr></table></figure>
<p>安装过程中会弹出配置窗口，根据实际硬件和系统位宽选择对应的即可。</p>
<p><img data-src="https://s3.bmp.ovh/imgs/2023/01/01/0b4b4561e1b859dc.png" /></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[info] Install supervisor startup scripts</span><br><span class="line">[info] Install AppArmor scripts</span><br><span class="line">[info] Start Home Assistant Supervised</span><br><span class="line">[info] Installing the &#x27;ha&#x27; cli</span><br><span class="line">[info] Within a few minutes you will be able to reach Home Assistant at:</span><br><span class="line">[info] http://homeassistant.local:8123 or using the IP address of your</span><br><span class="line">[info] machine: http://192.168.2.144:8123</span><br></pre></td></tr></table></figure>
<p>安装成功后，需要等待一段时间，时间长短由实际网络情况决定。如果想确认系统是否在运行相关安装操作，可查看系统进程，如果出现下图中的进程，则说明正在下载相关的docker镜像。</p>
<p><img data-src="https://s3.bmp.ovh/imgs/2023/01/01/27828012ad450222.png" /></p>
<p>通过如下指令可以查看docker镜像的下载情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images | grep ghcr.io/home-assistant</span><br></pre></td></tr></table></figure>
<p>如下镜像列表，说明 <strong>Supervisor</strong> 需求的所有基础镜像都下载完成。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ghcr.io/home-assistant/raspberrypi3-64-homeassistant   2022.12.8   bdb17d6196f1   10 days ago     1.42GB</span><br><span class="line">ghcr.io/home-assistant/aarch64-hassio-supervisor       latest      274d5e89d465   12 days ago     314MB</span><br><span class="line">ghcr.io/home-assistant/aarch64-hassio-cli              2022.11.0   a3ff4e00a9a0   8 weeks ago     116MB</span><br><span class="line">ghcr.io/home-assistant/aarch64-hassio-audio            2022.07.0   c4435f74fa3c   5 months ago    152MB</span><br><span class="line">ghcr.io/home-assistant/aarch64-hassio-dns              2022.04.1   362b749494ab   8 months ago    96.7MB</span><br><span class="line">ghcr.io/home-assistant/aarch64-hassio-multicast        2022.02.0   3ce91958464c   10 months ago   81.5MB</span><br><span class="line">ghcr.io/home-assistant/aarch64-hassio-observer         2021.10.0   9c3593efc7e1   14 months ago   89.2MB</span><br></pre></td></tr></table></figure>
<p>另外可以使用如下命令查看相关容器是否创建成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CONTAINER ID   IMAGE                                                            COMMAND   CREATED        STATUS        PORTS                                   NAMES</span><br><span class="line">8a35d1671da0   ghcr.io/home-assistant/aarch64-hassio-multicast:2022.02.0        <span class="string">&quot;/init&quot;</span>   21 hours ago   Up 21 hours                                           hassio_multicast</span><br><span class="line">fe5d313af4a6   ghcr.io/home-assistant/aarch64-hassio-audio:2022.07.0            <span class="string">&quot;/init&quot;</span>   21 hours ago   Up 21 hours                                           hassio_audio</span><br><span class="line">af22688c8288   ghcr.io/home-assistant/aarch64-hassio-dns:2022.04.1              <span class="string">&quot;/init&quot;</span>   21 hours ago   Up 21 hours                                           hassio_dns</span><br><span class="line">b5255dbcb17d   ghcr.io/home-assistant/aarch64-hassio-cli:2022.11.0              <span class="string">&quot;/init&quot;</span>   21 hours ago   Up 21 hours                                           hassio_cli</span><br><span class="line">7acff09641e5   ghcr.io/home-assistant/aarch64-hassio-observer:2021.10.0         <span class="string">&quot;/init&quot;</span>   6 days ago     Up 21 hours   0.0.0.0:4357-&gt;80/tcp, :::4357-&gt;80/tcp   hassio_observer</span><br><span class="line">cb3b24d10901   ghcr.io/home-assistant/raspberrypi3-64-homeassistant:2022.12.8   <span class="string">&quot;/init&quot;</span>   7 days ago     Up 21 hours                                           homeassistant</span><br><span class="line">7e49186c9adf   ghcr.io/home-assistant/aarch64-hassio-supervisor:latest          <span class="string">&quot;/init&quot;</span>   7 days ago     Up 21 hours                                           hassio_supervisor</span><br></pre></td></tr></table></figure>
<p>进一步访问 <code>IP:4357</code> 端口，确认 Supervisor 工作状态是否正常。 <img data-src="https://s3.bmp.ovh/imgs/2023/01/01/c8b095d572622e38.png" alt="supervisor状态" /></p>
<p>最后通过访问 <code>IP:8123</code> 端口，进行 <strong>Home Assisistant</strong> 的相关配置，如下图所示，需要等待一段时间，等待系统启动完成，然后创建账户配置基本选项。</p>
<p><img data-src="https://s3.bmp.ovh/imgs/2023/01/01/968c870c39329428.png" title="" alt="" data-align="center"></p>
<h2 id="参考">参考</h2>
<ol type="1">
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hvbWUtYXNzaXN0YW50L3N1cGVydmlzZWQtaW5zdGFsbGVy">supervised-installer: Installer for a generic Linux system<i class="fa fa-external-link-alt"></i></span></p></li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hvbWUtYXNzaXN0YW50L29zLWFnZW50L3RyZWUvbWFpbiN1c2luZy1ob21lLWFzc2lzdGFudC1zdXBlcnZpc2VkLW9uLWRlYmlhbg==">os-agent: Daemon allowing to control OS features through D-Bus<i class="fa fa-external-link-alt"></i></span></p></li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubWludGltYXRlLmNuLzIwMjIvMDMvMjkvcmFzcGJlcnJ5SW5zYXRsbEhBUy8jJUU1JTg5JThEJUU4JUE4JTgw">详解树莓派上如何安装Home Assistant Supervised - 雨月空间站<i class="fa fa-external-link-alt"></i></span></p></li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuaG9tZS1hc3Npc3RhbnQuaW8vbW9yZS1pbmZvL3Vuc3VwcG9ydGVkL25ldHdvcmtfbWFuYWdlcg==">Network Manager - Home Assistant<i class="fa fa-external-link-alt"></i></span></p></li>
</ol>
]]></content>
      <categories>
        <category>Home Assistant</category>
        <category>install</category>
      </categories>
      <tags>
        <tag>Home Assistant</tag>
        <tag>Supervised</tag>
        <tag>安装教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Home Assistant入门配置</title>
    <url>/2023/01/02/Home-Assistant-configure/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>本文讲述Home Assistant相关配置，如何使用Home Assistant进行智能家居的搭建。</p>
<figure>
<img data-src="https://s2.loli.net/2024/08/11/NqMX1oPC4wl5Apx.jpg" alt="LUTOS概念" /><figcaption aria-hidden="true">LUTOS概念</figcaption>
</figure>
<span id="more"></span>
<h2 id="插件安装">插件安装</h2>
<h3 id="terminal">Terminal</h3>
<p>点击 <code>配置</code> 菜单栏，在页面中选中 <code>加载项</code> 菜单，然后在新的页面中点击右下角的 <code>加载项商店</code> 按钮，在搜索界面输入 <strong>SSH</strong> 关键字。最终会有两个版本的ssh终端，其中一个官方版本，一个是社区的版本，点击社区版本图标执行安装操作；</p>
<p>然后重启，在配置界面配置本地的ssh key公钥信息，一般会在本地用户的.shh目录下，拷贝密钥粘贴到 <strong>authorized_keys</strong> 字段。</p>
<p>打开侧边栏显示，此时就可以看到快捷按钮；</p>
<h3 id="hacs">HACS</h3>
<h4 id="安装">安装</h4>
<p>请参考 <span class="exturl" data-url="aHR0cHM6Ly9oYWNzLnh5ei9kb2NzL3NldHVwL2Rvd25sb2Fk">HACS官方教程<i class="fa fa-external-link-alt"></i></span>，打开ssh终端，输入如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -c https://get.hacs.xyz | bash -</span><br></pre></td></tr></table></figure>
<p>国内网络由于各种限制，可能需要科学上网才能访问安装脚本网址，当然也可以通过代理的方式下载，具体指令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -c https://ghproxy.com/https://raw.githubusercontent.com/hacs/get/main/get | bash -</span><br></pre></td></tr></table></figure>
<p>等待安装完成，会在 <code>/root/config/custom_components</code>目录下会生成 <code>hacs</code>目录。</p>
<p>安装完成后，需要重启一下。</p>
<h4 id="添加hacs集成组件">添加HACS集成组件</h4>
<p>首先点击左侧的 <code>配置</code> 菜单栏，然后选择 <code>设备与服务</code> 功能进入集成配置界面，在界面的右下角点击 <code>添加集成</code> 按钮，在搜索框内输入 <strong>HACS</strong> ：</p>
<p><img title="HACS" data-src="https://s3.bmp.ovh/imgs/2023/01/02/5123659e1b1d893f.png" alt="" data-align="center" width="388"></p>
<p>然后会弹出如下窗口，4个选项都勾选上：</p>
<p><img title="" data-src="https://s3.bmp.ovh/imgs/2023/01/02/e5534bd22dabea43.png" alt="" data-align="center" width="392"></p>
<p>复制框中的KEY码，然后点击跳转链接：</p>
<p><img title="" data-src="https://s3.bmp.ovh/imgs/2023/01/02/f195a5bbfbbf7784.png" alt="" data-align="center" width="395"></p>
<p>在如下图的网页界面上粘贴Key码，并点击 <code>Continue</code> 按钮。</p>
<figure>
<img data-src="https://s3.bmp.ovh/imgs/2023/01/02/60d90d9d3c2c4b51.png" alt="Continue" /><figcaption aria-hidden="true">Continue</figcaption>
</figure>
<p>然后登陆自己的 Github 账号，绑定 HACS 服务</p>
<figure>
<img data-src="https://s3.bmp.ovh/imgs/2023/01/02/00c7b419c498bd6b.png" alt="login" /><figcaption aria-hidden="true">login</figcaption>
</figure>
<p>出现如下图所示界面，表示绑定成功，回到Home Assistant 界面。</p>
<p><img title="" data-src="https://s3.bmp.ovh/imgs/2023/01/02/188fb48c0f9af031.png" alt="" width="365" data-align="center"></p>
<p><img title="" data-src="https://s3.bmp.ovh/imgs/2023/01/02/f166eae5a8355b60.png" alt="" width="389" data-align="center"></p>
<p>然后左侧侧边栏中将会出现 HACS快捷按钮。</p>
<p>点击 集成 , 右下角 <strong>浏览并下载库</strong></p>
<h2 id="安装米家物联网插件">安装米家物联网插件</h2>
<h3 id="xiaomi-miot插件安装">Xiaomi MIoT插件安装</h3>
<p>首先在Home Assistant Community Store(HACS)中安装Xiaomi MIoT组件。点击左侧侧边栏上的HACS图标， 然后选择进入 <code>集成</code> 配置界面, 单击界面右下角 <code>浏览并下载库</code>，输入 <code>xiaomi</code> 等关键字，然后从下拉列表中选择 <code>Xiaomi MIoT</code> , 最后点击右下角的 <code>下载</code> 按钮, 则相关插件文件会下载到 <code>/config/custom_components/xiaomi_miot_raw</code> 目录下。 下载完成后，需要进行重启操作。</p>
<h3 id="账户配置">账户配置</h3>
<p>首先点击左侧侧边栏的 <code>配置</code> 菜单，进入 <code>设备与服务</code> 配置界面，然后点击界面右下角的 <code>添加集成</code> 按钮，在搜索窗口中输入 <code>xaiomi</code> 等关键字，选择 <code>Xiaomi MIoT</code>图标。</p>
<p>如下图所示，选择采用小米账号登陆，点击 <code>提交</code>：</p>
<figure>
<img data-src="https://s2.loli.net/2023/03/19/oWziSDOaZgvrq6u.png" alt="login" /><figcaption aria-hidden="true">login</figcaption>
</figure>
<p>通过如下窗口填写自己的小米账号和密码，并点击 <code>提交</code>：</p>
<figure>
<img data-src="https://s2.loli.net/2023/03/19/Im981QRu3WkDjUG.png" alt="submit" /><figcaption aria-hidden="true">submit</figcaption>
</figure>
<p>然后勾选需要集成的设备，最后出现如下窗口说明添加成功。</p>
<figure>
<img data-src="https://s2.loli.net/2023/03/19/JNCIm3QloLOfb25.png" alt="success" /><figcaption aria-hidden="true">success</figcaption>
</figure>
]]></content>
      <categories>
        <category>Home Assistant</category>
        <category>configure</category>
      </categories>
      <tags>
        <tag>Home Assistant</tag>
        <tag>HACS</tag>
      </tags>
  </entry>
  <entry>
    <title>PVE-Docker服务部署</title>
    <url>/2023/03/11/PVE-Docker-Install/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>本文主要介绍在Proxmox VE（PVE）虚拟化环境中，如何构建LXC容器以隔离PVE环境。我们将使用PVE中的模版创建LXC容器，并在其中安装Docker服务。通过这种方式，我们可以在PVE虚拟环境中安全地部署和管理Docker应用。</p>
<figure>
<img data-src="https://s2.loli.net/2024/08/11/5Epb3dFI62zAaMQ.jpg" alt="本田概念" /><figcaption aria-hidden="true">本田概念</figcaption>
</figure>
<span id="more"></span>
<h3 id="软件源更新">软件源更新</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -e <span class="string">&#x27;s/www.debian.org/mirrors.tuna.tsinghua.edu.cn/&#x27;</span> tmp/sources.list.backup &gt; /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<h3 id="docker安装">docker安装</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL get.docker.com -o /tmp/get-docker.sh</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh /tmp/get-docker.sh --mirror Aliyun</span><br></pre></td></tr></table></figure>
<h3 id="配置显卡">配置显卡</h3>
<p>通过 <code>ls -l /dev/dri</code> 命令查询设备号</p>
<p>在PVE终端打开 <code>vim /etc/pve/lxc/[CT_ID].conf</code> 文件，写入如下代码，将设备挂载到LXC容器中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lxc.cgroup2.devices.allow: c 226:0 rwm</span><br><span class="line">lxc.cgroup2.devices.allow: c 226:128 rwm</span><br><span class="line">lxc.cgroup2.devices.allow: c 29:0 rwm</span><br><span class="line">lxc.mount.entry: /dev/dri dev/dri none <span class="built_in">bind</span>,optional,create=<span class="built_in">dir</span></span><br><span class="line">lxc.mount.entry: /dev/fb0 dev/fb0 none <span class="built_in">bind</span>,optional,create=file</span><br></pre></td></tr></table></figure>
<p>PVE下默认限制了LXC容器权限，不能直接挂载NFS共享文件。简单粗暴的方法是直接取消限制，修改容器配置文件，追加一行。这种做法取消所有安全规则，不够安全，下面是单独设置nfs的方法，参考 <a href="https://cloud.tencent.com/developer/article/2008005"></a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lxc.apparmor.profile: unconfined</span><br></pre></td></tr></table></figure>
<h2 id="portainer安装">portainer安装</h2>
<p>安装docker管理服务，提供可视化的界面。采用官方镜像进行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker volume create portainer_data</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-p 8000:8000 -p 9000:9000 \</span><br><span class="line">--name=portainer --restart=always \</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">-v portainer_data:/data \</span><br><span class="line">portainer/portainer</span><br></pre></td></tr></table></figure>
<p>-d: 后台运行； --restart: 当容器退出时的重启策略；</p>
<h2 id="挂载samba服务">挂载Samba服务</h2>
<h3 id="软件安装">软件安装</h3>
<p>通过安装如下SMB组件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install cifs-utils -y</span><br></pre></td></tr></table></figure>
<p>采用如下工具查询服务信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">smbclient -L &lt;服务器IP或主机名&gt;  -U  &lt;用户名&gt;</span><br></pre></td></tr></table></figure>
<h3 id="手动挂载">手动挂载</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount -t cifs &lt;共享点路径(//192.168.1.12/share)&gt; &lt;挂载点(/mnt)&gt; -o username=&lt;用户名&gt;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount.cifs &lt;共享点路径(//192.168.1.12/share)&gt; &lt;挂载点(/mnt)&gt; -o username=&lt;用户名&gt;</span><br></pre></td></tr></table></figure>
<p>通过 <code>mount -l | grep &lt;挂载点&gt;</code> 命令查看挂载情况。</p>
<h3 id="开机自动挂载">开机自动挂载</h3>
<p>通过配置 <code>/etc/fstab</code> 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;共享点路径&gt; &lt;挂载点&gt; cifs username=&lt;用户名&gt;,password=&lt;密码&gt; 0 0</span><br></pre></td></tr></table></figure>
<p>该方式存在账号密码泄露风险，故可以使用文件保存账号信息，配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;共享点路径&gt; &lt;挂载点&gt; cifs credentials=&lt;凭证文件路径&gt; 0 0</span><br></pre></td></tr></table></figure>
<p>凭证文件中的内容格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">username=value</span><br><span class="line">password=value</span><br><span class="line">domain=value [option]</span><br></pre></td></tr></table></figure>
<h4 id="其它参数">其它参数</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;共享点路径&gt; &lt;挂载点&gt; cifs credentials=&lt;凭证文件路径&gt;,iocharset-utf8,rw 0 0</span><br></pre></td></tr></table></figure>
<p><code>iocharset</code>:</p>
<h3 id="执行挂载">执行挂载</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount -a</span><br></pre></td></tr></table></figure>
<h2 id="安装jellyfin服务">安装jellyfin服务</h2>
<p>nyanmisaka/jellyfin:latest</p>
<ul>
<li>端口8096映射</li>
<li>设备 <code>/devdri</code> 映射</li>
</ul>
<p>如果出现如下错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">invalid CapDrop: capability not supported by your kernel or not available <span class="keyword">in</span> the current environment: <span class="string">&quot;CAP_MAC_ADMIN&quot;</span></span><br></pre></td></tr></table></figure>
<p>尝试在conf文件中添加：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lxc.cap.drop: </span><br></pre></td></tr></table></figure>
<h2 id="安装-aria2">安装 Aria2</h2>
<ul>
<li>镜像名：p3terx/aria2-pro</li>
</ul>
<h3 id="环境变量">环境变量</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">- PUID=65534</span><br><span class="line">- PGID=65534</span><br><span class="line">- UMASK_SET=022</span><br><span class="line">- RPC_SECRET=&lt;password&gt;</span><br><span class="line">- RPC_PORT=6800</span><br><span class="line">- LISTEN_PORT=6888</span><br><span class="line">- DISK_CACHE=64M</span><br><span class="line">- IPV6_MODE=false</span><br><span class="line">- UPDATE_TRACKERS=true</span><br><span class="line">- CUSTOM_TRACKER_URL=</span><br><span class="line">- TZ=Asia/Shanghai</span><br></pre></td></tr></table></figure>
<h3 id="挂载卷">挂载卷</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">volumes:</span><br><span class="line">  - $&#123;PWD&#125;/aria2-config:/config</span><br><span class="line">  - $&#123;PWD&#125;/aria2-downloads:/downloads</span><br></pre></td></tr></table></figure>
<h3 id="网络端口">网络端口</h3>
<p>如果桥接模式，需要暴露端口号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">- 6800:6800</span><br><span class="line">- 6888:6888</span><br><span class="line">- 6888:6888/udp</span><br></pre></td></tr></table></figure>
<h2 id="安装ariang">安装AriaNg</h2>
<p>镜像： p3terx/ariang</p>
]]></content>
      <categories>
        <category>PVE</category>
      </categories>
      <tags>
        <tag>PVE</tag>
        <tag>LXC</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>感知-3D或4D毫米波</title>
    <url>/2024/08/10/PerceptionMillimeterWaveRadar-3D-4D/</url>
    <content><![CDATA[<h2 id="d毫米波雷达">4D毫米波雷达</h2>
<p>如下图所示，TI给出的4D毫米波方案示例。</p>
<figure>
<img data-src="https://i.imgur.com/Xnc6kF7.png" alt="毫米波指标" /><figcaption aria-hidden="true">毫米波指标</figcaption>
</figure>
<span id="more"></span>
<figure>
<img data-src="https://i.imgur.com/CADixJ2.png" alt="毫米波硬件电路" /><figcaption aria-hidden="true">毫米波硬件电路</figcaption>
</figure>
<figure>
<img data-src="https://i.imgur.com/rhLCILo.png" alt="PCB" /><figcaption aria-hidden="true">PCB</figcaption>
</figure>
<figure>
<img data-src="https://i.imgur.com/TfD7cjH.png" alt="TX和RX通道间距" /><figcaption aria-hidden="true">TX和RX通道间距</figcaption>
</figure>
<p>该双芯片级联方案包含6个TX通道和8个RX通道，在MIMO虚拟阵列中提供48个虚拟通道，其中MIMO阵列在方向角上提供约3度的孔径受限角分辨率。</p>
<figure>
<img data-src="https://i.imgur.com/qCQfDhe.png" alt="MINO虚拟阵列" /><figcaption aria-hidden="true">MINO虚拟阵列</figcaption>
</figure>
<p>如下图所示，两个角反射器放置在距离雷达约9.5m的径向距离处的同一距离单元中。</p>
<p><img data-src="https://i.imgur.com/wYIhmd5.png" alt="角反射器" /> <img data-src="https://i.imgur.com/D35cdhl.png" alt="角度分辨率测量" /></p>
<h2 id="d与4d毫米波对比">3D与4D毫米波对比</h2>
<h3 id="地面井盖">地面井盖</h3>
<figure>
<img data-src="https://i.imgur.com/ZReja0C.png" alt="3D Radar" /><figcaption aria-hidden="true">3D Radar</figcaption>
</figure>
<figure>
<img data-src="https://i.imgur.com/L9jPrtb.png" alt="4D Radar" /><figcaption aria-hidden="true">4D Radar</figcaption>
</figure>
<figure>
<img data-src="https://i.imgur.com/5cqH0Qe.png" alt="4D Radar" /><figcaption aria-hidden="true">4D Radar</figcaption>
</figure>
<h3 id="指示牌和交通杆">指示牌和交通杆</h3>
<figure>
<img data-src="https://i.imgur.com/Ajh8La9.png" alt="4D Radar" /><figcaption aria-hidden="true">4D Radar</figcaption>
</figure>
<h3 id="低速物体">低速物体</h3>
<figure>
<img data-src="https://i.imgur.com/KA0mYhx.png" alt="4D Radar 横向车辆" /><figcaption aria-hidden="true">4D Radar 横向车辆</figcaption>
</figure>
<figure>
<img data-src="https://i.imgur.com/3IeUGpk.png" alt="4D Radar 横向行人" /><figcaption aria-hidden="true">4D Radar 横向行人</figcaption>
</figure>
<h2 id="d与激光雷达对比">4D与激光雷达对比</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">技术参数</th>
<th>激光雷达</th>
<th>4D毫米波</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">最大点云数</td>
<td>70000</td>
<td>3072</td>
</tr>
<tr class="even">
<td style="text-align: center;">最远距离</td>
<td>180m</td>
<td>300m</td>
</tr>
<tr class="odd">
<td style="text-align: center;">工作周期</td>
<td>100ms</td>
<td>60ms</td>
</tr>
<tr class="even">
<td style="text-align: center;">朝向估计误差</td>
<td>1°</td>
<td>2.5°</td>
</tr>
<tr class="odd">
<td style="text-align: center;">尺寸估计误差</td>
<td>0.2m</td>
<td>0.5m</td>
</tr>
<tr class="even">
<td style="text-align: center;">俯仰角分辨率</td>
<td>0.2°</td>
<td>2.3°</td>
</tr>
<tr class="odd">
<td style="text-align: center;">方位角分辨率</td>
<td>0.2°</td>
<td>1.2°</td>
</tr>
<tr class="even">
<td style="text-align: center;">距离分辨率</td>
<td>0.05m</td>
<td>0.4m</td>
</tr>
<tr class="odd">
<td style="text-align: center;">速度分辨率</td>
<td></td>
<td>0.1m/s</td>
</tr>
</tbody>
</table>
<h3 id="距离与朝向">距离与朝向</h3>
<figure>
<img data-src="https://i.imgur.com/u477tic.png" alt="激光雷达" /><figcaption aria-hidden="true">激光雷达</figcaption>
</figure>
<h3 id="近处小目标">近处小目标</h3>
<figure>
<img data-src="https://i.imgur.com/6jQbwF3.png" alt="激光雷达" /><figcaption aria-hidden="true">激光雷达</figcaption>
</figure>
<h3 id="d毫米波的优势">4D毫米波的优势</h3>
<h4 id="可穿透性">可穿透性</h4>
<figure>
<img data-src="https://i.imgur.com/00jyGW5.png" alt="可穿透" /><figcaption aria-hidden="true">可穿透</figcaption>
</figure>
<h4 id="波的衍射折射">波的衍射折射</h4>
<figure>
<img data-src="https://i.imgur.com/sdc0scr.png" alt="衍射折射" /><figcaption aria-hidden="true">衍射折射</figcaption>
</figure>
<h3 id="激光雷达">激光雷达</h3>
<figure>
<img data-src="https://i.imgur.com/Pg9d8QJ.png" alt="激光雷达结构" /><figcaption aria-hidden="true">激光雷达结构</figcaption>
</figure>
]]></content>
      <categories>
        <category>perception</category>
        <category>millimeter-wave radar 3D 4D</category>
      </categories>
      <tags>
        <tag>perception</tag>
        <tag>millimeter-wave radar</tag>
        <tag>3D millimeter-wave radar</tag>
        <tag>4D millimeter-wave radar</tag>
      </tags>
  </entry>
  <entry>
    <title>感知-毫米波介绍</title>
    <url>/2024/08/09/PerceptionMillimeterWaveRadar/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>毫米波(mmWave)是一类使用短波长 电磁波的特殊雷达技术。雷达系统发射的电磁波信号被其发射路径上的物体阻挡继而会发生反射。通过捕捉反射信号，雷达系统可以确定物体的距离、速度和角度。</p>
<p>毫米波雷达可发射波长为毫米量级的信号，在电磁频谱中，这种波长被视为短波长，这也是该技术的优势之一，即处理毫米波所需的系统组件(如 天线)尺寸可以做得很小；短波长的另一个优势是高准确度，工作频率为 76~81 GHz(对应波长约为 4mm)的毫米波系统将能够检测到小至零点几毫米的移动。</p>
<p>其中，TI公司的器件实现了一种称为 调频连续波(FMCW)的特殊毫米波技术。顾名思义，FMCW 雷达连续发射调频信号，以测量距离、速度和角度。这与周期性发射短脉冲的传统脉冲雷达系统不同。</p>
<figure>
<img data-src="https://i.imgur.com/leBJOBt.jpeg" alt="植物" /><figcaption aria-hidden="true">植物</figcaption>
</figure>
<span id="more"></span>
<h2 id="雷达信号">雷达信号</h2>
<p>FMCW雷达系统所用的信号的频率随时间变化呈现线性升高，这种类型的信号也称为 <code>线性调频脉冲</code> 。</p>
<figure>
<img data-src="https://i.imgur.com/NIfN6xU.png" alt="线性调频脉冲信号 - 幅度与时间的关系" /><figcaption aria-hidden="true">线性调频脉冲信号 - 幅度与时间的关系</figcaption>
</figure>
<figure>
<img data-src="https://i.imgur.com/hBpBwNo.png" alt="线性调频脉冲信号 - 频率与时间的关系" /><figcaption aria-hidden="true">线性调频脉冲信号 - 频率与时间的关系</figcaption>
</figure>
<p>该线性调频脉冲具有起始频率 <span class="math inline">\(f_c\)</span>，带宽 <span class="math inline">\(B\)</span>，持续时间 <span class="math inline">\(T_c\)</span>，斜率<span class="math inline">\(S\)</span>捕捉频率的变化率； <span class="math display">\[f_c = 77 GHz; B=4 GHz ; T_c=40 us; S=100 Mhz/us\]</span></p>
<h3 id="雷达射频组件">雷达射频组件</h3>
<figure>
<img data-src="https://i.imgur.com/neqRgKg.png" alt="FMCW雷达框图" /><figcaption aria-hidden="true">FMCW雷达框图</figcaption>
</figure>
<ul>
<li>合成器：生成一个线性调频脉冲；</li>
<li>发射天线：该线性调频脉冲由发射天线（TX天线）发射；</li>
<li>接收天线：接收物体反射的线性调频脉冲信号；</li>
<li>混频器： 将TX和RX信号合并到一起，生成一个中频 （IF）信号；</li>
</ul>
<h3 id="混频器">混频器</h3>
<p>混频器是一个电子组件，将两个信号合并到一起生成一个具有新频率的信号。 对于两个正弦输入 <span class="math display">\[x_{1}\]</span> 和 <span class="math display">\[x_{2}\]</span>： <span class="math display">\[\begin{equation}
x_1= sin(w_1*t+ {\phi}_1)
\end{equation}\]</span> <span class="math display">\[\begin{equation}
x_2= sin(w_2*t+ {\phi}_2)
\end{equation}\]</span> 瞬时输出如下： <span class="math display">\[\begin{equation}
x_{out} = sin[(w_1-w_2)*t + (\phi_{1} - \phi_{2})]
\end{equation}\]</span></p>
<h2 id="测距原理">测距原理</h2>
<h3 id="单目标测距">单目标测距</h3>
<p>如下图所示，雷达通过TX天线发射的线性调节脉冲信号，经过时间 <span class="math inline">\(t\)</span> 之后，接收天线RX收到目标反射回来的信号，两个信号的频率差为 <span class="math inline">\(S_{\tau}\)</span>： <img data-src="https://i.imgur.com/aysTMZR.png" alt="单目标" /> 由公式(6)可知，混频器的输出信号频率是TX和RX信号频率之差，从上图可知，两条线之间的距离是固定的，故中频信号 (IF信号) 包含一个频率恒定的单音信号。图中显示IF信号的频率为<span class="math inline">\(S_{\tau}\)</span> ，且仅在TX和RX线性调频脉冲重叠的时段有效(图中垂直虚线之间的时间段)。故混频器的输出信号(IF信号)作为时间的幅度函数是一个正弦波。 #### 频率 中频信号的频率<span class="math inline">\(f_0\)</span>可表示为： <span class="math display">\[\begin{equation}
f_0 = S_\tau = S * \tau
\end{equation}\]</span> 其中，<span class="math inline">\(S\)</span>为线性调节脉冲信号的斜率，<span class="math inline">\(\tau\)</span>为延时时间。</p>
<p>由于RX线性调节脉冲是TX线性调节脉冲的延时版本，其中延时可以通过电磁波在发射器与物体之间的传输距离表示如下： <span class="math display">\[
\begin{equation}
\tau = \frac{2*d}{c}
\end{equation}
\]</span> 其中，<span class="math inline">\(d\)</span>表示毫米波雷达与被检测物体的距离，<span class="math inline">\(c\)</span>表示光速。 结合公式(4)(5)可得中频信号频率与目标距离的关系如下： <span class="math display">\[
\begin{equation}
f_0 = S*\tau = \frac{2*S*d}{c}
\end{equation}
\]</span> 故得到中频信号的频率即可得到目标与雷达之间的距离： <span class="math display">\[
\begin{equation}
d = \frac{f_0*c}{2*S}
\end{equation}
\]</span> #### 相位 中频信号IF的初始相位<span class="math inline">\(\Phi_{0}\)</span>是IF信号起始点对应时间点的Tx信号与Rx信号的相位差。假设Tx信号的初始相位为0，经过<span class="math inline">\(\tau\)</span>时间后Rx信号的相位也是0，那么IF信号的初始相位为 <span class="math display">\[
\begin{equation}
\phi_0=2{\pi}f_c\tau
\end{equation}
\]</span> 结合公式(8)，以及频率与波长得关系<span class="math inline">\(\frac{c}{f}=\lambda\)</span>得 <span class="math display">\[
\begin{equation}
\phi_0=\frac{4{\pi}d}{\lambda}
\end{equation}
\]</span> 故与雷达相距距离<span class="math inline">\(d\)</span>的物体，IF信号将是一个正弦波，表示如下： <span class="math display">\[
\begin{equation}
A*sin(2{\pi}f_0*t + \phi_0)
\end{equation}
\]</span> 其中<span class="math inline">\(f_0=\frac{2Sd}{c}\)</span>，<span class="math inline">\(\phi_0=\frac{4{\pi}d}{\lambda}\)</span>。 &gt; 等式(9)是一个近似等式，仅在斜率和距离足够小时才有效；但相位和距离的变化率呈线性关系是正确的，即<span class="math inline">\(\Delta{\phi}=\frac{4\pi{\Delta{d}}}{\lambda}\)</span> <img data-src="https://i.imgur.com/g8bqCZ1.png" /> ### 多目标测距 #### FFT 对于单目标的IF信号，可以通过傅里叶变化(FFT)，将时域信号转为频域信号，时域中的正弦波在频域中产生一个峰值，横坐标对应IF信号的频率。 <img data-src="https://i.imgur.com/uLZ5mEJ.png" /> #### Range-FFT 雷达通过接收不同物体的发射信号，并转为IF信号，利用傅里叶变换将产生一个具有不同的分离峰值的频谱，每个峰值表示在特定距离处存在物体。 <img data-src="https://i.imgur.com/MDH6x2l.png" /> ### 多目标的分辨率 距离分辨率是辨别两个或更多物体的能力。当两个物体靠近到某个位置时，雷达系统将不能将二者区分开。 由傅里叶变换理论可知：观测窗口<span class="math inline">\(T\)</span>可以分辨时间间隔超过<span class="math inline">\(\frac{1}{T}\)</span>Hz的频率分量。这意味着IF信号的频率差值满足公式(14)中关系，就可以分辨两个IF单音信号。 <span class="math display">\[
\begin{equation}
\Delta{f} &gt; \frac{1}{T_{c}}
\end{equation}
\]</span> 其中，<span class="math inline">\(T_{c}\)</span>是观测时间长度，<span class="math inline">\(\Delta{f}\)</span>表示两个IF信号之间得频率差值。 由公式(9)得 <span class="math display">\[
\begin{equation}
\Delta{f} = \frac{2*S*\Delta{d}}{c}
\end{equation}
\]</span> 结合公式(14)和(15)得 <span class="math display">\[
\begin{equation}
\Delta{d} &gt; \frac{c}{2*S*T_c} = \frac{c}{2*B}
\end{equation}
\]</span> 故距离分辨率<span class="math inline">\(d_{res}\)</span>取决于线性调节脉冲扫频得带宽 <span class="math display">\[
\begin{equation}
d_{res}  = \frac{c}{2*B}
\end{equation}
\]</span> 根据公式(17)可知，线性调频脉冲带宽为数<code>GHz</code>的<code>FMCW</code>雷达，将有约数厘米的距离分辨率。 &gt; 距离分辨率由线性调频脉冲带宽决定。 例如，带宽为4GHz的线性调频脉冲可转化为 3.75 cm的距离分辨率。 下图所示，当线性调频脉冲的带宽由<span class="math inline">\(B_1\)</span>提升至<span class="math inline">\(B_2\)</span>后，提高了两个目标的分辨率。<br />
<img data-src="https://i.imgur.com/18Ly6Mk.png" /> ### 最远探测距离 一般IF信号经过数字化处理(LPF+ADC)，才在DSP上进行进一步处理，因此，中频信号的完整性，很大程度上取决于ADC的采样频率<span class="math inline">\(F_s\)</span>。 <img data-src="https://i.imgur.com/kKCU5ny.png" /> 根据采样定理知， <span class="math display">\[
\begin{equation}
F_s &gt; 2* f_{IF_{max}} = \frac{2*S*d_{max}}{c}
\end{equation}
\]</span> 故最大距离表示为 <span class="math display">\[
\begin{equation}
d_{max} = \frac{F_{s}*c}{2*S}
\end{equation}
\]</span> ADC的采样频率限制了雷达的最远探测距离。</p>
<h2 id="测速原理">测速原理</h2>
<p>测速的基本原理是基于多普勒效应：</p>
<blockquote>
<p>当移动台以恒定的速率沿某一方向移动时，由于传播路程差的原因，会造成相位和频率的变化，通常将这种变化称为多普勒频移。它揭示了波的属性在运动中发生变化的规律。</p>
</blockquote>
<h3 id="速度估算原理">速度估算原理</h3>
<h4 id="相位变化">相位变化</h4>
<p>当物体静止时，输出IF信号如下： <img data-src="https://i.imgur.com/VZJBBXI.png" alt="静止物体" /> 当物体运动时，接收信号发生了延时，IF信号的相位也发生了改变。 <img data-src="https://i.imgur.com/dabZ5Q8.png" alt="运动物体" /> 则在<span class="math inline">\(\Delta{\tau}\)</span>时间内，相位的变化量为 <span class="math display">\[
\begin{equation}
\Delta{\phi}=2\pi{f_c}{\Delta}\tau=\frac{4\pi{\Delta}d}{\lambda}
\end{equation}
\]</span> #### 相位求解 具有相同频率、不同初始相位的正弦信号经过FFT变换，在相同横坐标位置处（频率相等）产生峰值，但峰值信号的相位不同，峰值的相位等于正弦波的初始相位。 <img data-src="https://i.imgur.com/2OeIDlr.png" /> #### 估算原理 FMCW雷达发送间隔为<span class="math inline">\(T_c\)</span>的两个线性调频脉冲信号，每个反射的调频脉冲信号通过Range-FFT进行处理，对应每个调频脉冲信号的Range-FFT，将在同一位置出现峰值，但相位不同。该相位差与物体移动的位移有关。 <img data-src="https://i.imgur.com/nn6SvoL.png" alt="估算原理" /> 根据物体相对雷达的速度在<span class="math inline">\(T_C\)</span>时间内的位移(<span class="math inline">\(\Delta{d}=v*{T}_c\)</span>)，代入公式(20)得 <span class="math display">\[
\begin{equation}
v=\frac{\lambda{\Delta}\phi}{4\pi{T_c}}
\end{equation}
\]</span> ### 最大速度 由于速度测量基于相位差，因而会存在模糊性。仅当<span class="math inline">\(\Delta{\phi}&lt;\pi\)</span>时，具有非模糊性，故结合公式(20)可得 <span class="math display">\[
\begin{equation}
v_{max}=\frac{\lambda}{4\pi{T_c}}
\end{equation}
\]</span> 因而，想要测量更高的速度需要两个线性调频脉冲之间更短的传输时间。 ### 同一距离处多物体速度估算 如果速度不同的多个移动物体在测量时与雷达的距离相同，则双线性调频脉冲速度测量方法将不起作用，由于物体与雷达的距离相同，因而生成的IF信号频率将相同，经过距离FFT会产生单个峰值，该峰值表示距离相同物体的合并信号。 为测量速度，必须发射<strong>两个以上</strong>的线性调频脉冲信号。对同一距离处多个物体的速度估算，需要发射一组N个等间隔的线性调频脉冲，这组线性调频脉冲称为 <code>线性调频脉冲帧</code>(Frame)。 对于等距不同速的两个物体，在同一帧内，通过Range FFT 后在峰值处提取各相位，并做Doppler FFT，会产生两个具有不同的峰值，其对应的横坐标为各物体的相位差。 <img data-src="https://i.imgur.com/DCkSbzg.png" /> 其中，<span class="math inline">\(\omega_1\)</span>和<span class="math inline">\(\omega_2\)</span>对应各个连续线性调频脉冲之间的相位差。 根据公式(21)得 <span class="math display">\[
\begin{equation}
v_1=\frac{\lambda{\omega}_1}{4\pi{T_c}}
\end{equation}
\]</span> <span class="math display">\[
\begin{equation}
v_2=\frac{\lambda{\omega}_2}{4\pi{T_c}}
\end{equation}
\]</span> #### 速度分辨率 根据离散傅里叶变换理论，两个离散频率<span class="math inline">\(\omega_1\)</span>和<span class="math inline">\(\omega_2\)</span>，仅在<span class="math inline">\(\Delta{\omega}&gt;\frac{2\pi}{N}\)</span>时，可以分辨。 <img data-src="https://i.imgur.com/YQd1qZB.png" /> 由上图可知，帧周期<span class="math inline">\(T_f=NT_c\)</span>。故根据公式(20)得 <span class="math display">\[
\begin{equation}
\Delta{\phi}=\frac{4\pi{\Delta}d}{\lambda}=\frac{4\pi{v}T_c}{\lambda}&gt;\frac{2\pi}{N}
\end{equation}
\]</span> 从而得到速度分辨率为 <span class="math display">\[\begin{equation}
v&gt;v_{res}=\frac{\lambda}{2T_cN}=\frac{\lambda}{2T_f}
\end{equation}
\]</span> 因此，速度分辨率取决于帧的时间(<span class="math inline">\(T_f\)</span>)。</p>
<h2 id="角度检测原理">角度检测原理</h2>
<p>FMCW雷达系统使用水平面估算反射信号的角度，该角度称为到达角（AoA）。 <img data-src="https://i.imgur.com/EBX8dDj.png" alt="到达角" /></p>
<h3 id="角度估算原理">角度估算原理</h3>
<p>当目标距离发生很小的变化时，就会会导致Range-FFT或Doppler-FFT得峰值处相位发生较大的变化，因此可利用物体与两个天线的距离差<span class="math inline">\(\Delta{d}\)</span>引起的相位变化估算到达角（Angle of Arrival ）。</p>
<h4 id="波形往返">波形往返</h4>
<p>如下图所示，根据测速原理知，目标移动<span class="math inline">\(\Delta{d}\)</span>位置，毫米波传播路径往返多走了<span class="math inline">\(2\Delta{d}\)</span>位移，则与相位关系为 <span class="math display">\[
\begin{equation}
\Delta{\phi}=\frac{4\pi{\Delta}d}{\lambda}
\end{equation}
\]</span> <img data-src="https://i.imgur.com/dylOKL8.png" alt="波形往返" /></p>
<h4 id="波形单程">波形单程</h4>
<p>如下图所示，两个接收天线间隔距离为<span class="math inline">\(l\)</span>，毫米波传播路径单程多走了<span class="math inline">\(\Delta{d}\)</span>，故结合公式(27)得 <span class="math display">\[
\begin{equation}
\Delta{\phi}=\frac{2\pi{\Delta}d}{\lambda}
\end{equation}
\]</span> <img data-src="https://i.imgur.com/R3RziuG.png" alt="波形单程" /></p>
<h4 id="到达角估算">到达角估算</h4>
<p>如下图所示，考虑接收天线与目标物体之间得几何关系得 <span class="math display">\[
\begin{equation}
\Delta{d}=l*sin(\theta)
\end{equation}
\]</span> 代入公式(28)得 <span class="math display">\[
\begin{equation}
\theta=sin^{-1}(\frac{\lambda{\Delta}\phi}{2\pi{l}})
\end{equation}
\]</span></p>
<figure>
<img data-src="https://i.imgur.com/KiSSOwS.png" alt="到达角估算" /><figcaption aria-hidden="true">到达角估算</figcaption>
</figure>
<h4 id="估算准确度">估算准确度</h4>
<p>由于<span class="math inline">\(\Delta{\phi}\)</span>取决于<span class="math inline">\(sin(\theta)\)</span>，是一种非线性的依赖关系，只有当<span class="math inline">\(\theta\)</span>很小时，<span class="math inline">\(sin(\theta)\)</span>才是线性函数的近似值。因此当<span class="math inline">\(\theta\)</span>接近0°时，角度的估算精度较高，<span class="math inline">\(\theta\)</span>接近90°时，估算精度降低。 <img data-src="https://i.imgur.com/Qf5dgUC.png" alt="估算精度" /></p>
<h3 id="同距同速角度估算">同距同速角度估算</h3>
<p>假设存在N个接收天线，每个天线计算出的距离和速度信息都相等，可以通过Angle-FFT分离出每组接收天线的相位差。</p>
<p><img data-src="https://i.imgur.com/pkWIbtZ.png" /></p>
<p>结合公式(30)知 <span class="math display">\[
\begin{equation}
\theta_1=sin^{-1}(\frac{\lambda{\omega}_1}{2\pi{l}})
\end{equation}
\]</span> <span class="math display">\[
\begin{equation}
\theta_2=sin^{-1}(\frac{\lambda{\omega}_2}{2\pi{l}})
\end{equation}
\]</span></p>
<h3 id="最大角视场">最大角视场</h3>
<p>雷达的最大角视场由雷达可以估算的最大 AoA 来界定。 当<span class="math inline">\(\Delta{\phi}&gt;\pi\)</span>时，就会产生角度模糊，如下图所示： <img data-src="https://i.imgur.com/JvEornm.png" /> 结合公式(28)(29)得： <span class="math display">\[
\begin{equation}
\Delta{\phi}=\frac{2{\pi}lsin(\theta)}{\lambda}&lt;\pi \Longrightarrow \theta_{max}=sin^{-1}（\frac{\lambda}{2l}）
\end{equation}
\]</span> 故，当接收天线间隔<span class="math inline">\(l=\frac{\lambda}{2}\)</span>时，会导致<span class="math inline">\(\pm{90}^{\circ}\)</span>的最大角视场。</p>
<h3 id="角度分辨率">角度分辨率</h3>
<ul>
<li>随着到达角（AoA）的增加，角度分辨率逐渐降低。</li>
</ul>
<p><img data-src="https://i.imgur.com/T3dWSHV.png" /></p>
<p>结合公式(28)(29)得 <span class="math display">\[
\begin{equation}
\omega=\frac{2{\pi}lsin(\theta)}{\lambda}
\end{equation}
\]</span> 则相位差为 <span class="math display">\[
\begin{aligned}
{\Delta}\omega&amp; =\omega_2-\omega_1\\
&amp; =\frac{2{\pi}lsin(\theta+\Delta{\theta})}{\lambda}-\frac{2{\pi}lsin(\theta)}{\lambda}\\
&amp; =\frac{2{\pi}l}{\lambda} * [sin(\theta+\Delta{\theta})-sin(\theta)] \\
&amp; = \frac{2{\pi}l}{\lambda} * [sin(\theta)cos(\Delta{\theta})+cos(\theta)sin(\Delta{\theta})-sin(\theta)] \\
\end{aligned}
\]</span></p>
<p>其中，将设<span class="math inline">\(\Delta{\theta}\)</span>趋近于0，则<span class="math inline">\(cos(\Delta{\theta}) \to 1\)</span>，<span class="math inline">\(sin(\Delta{\theta}) \to 0\)</span>，故上述公式可近似为 <span class="math display">\[
\begin{equation}
{\Delta}\omega \approx\frac{2{\pi}l}{\lambda}cos(\theta)\Delta{\theta}
\end{equation}
\]</span></p>
<p>根据离散傅里叶变换理论，两个离散频率<span class="math inline">\(\omega_1\)</span>和<span class="math inline">\(\omega_2\)</span>，仅在<span class="math inline">\(\Delta{\omega}&gt;\frac{2\pi}{N}\)</span>时，可以分辨。 <span class="math display">\[
\begin{equation}
{\Delta}\omega &gt; \frac{2\pi}{N} \Rightarrow \frac{2{\pi}l}{\lambda}cos(\theta)\Delta{\theta} &gt; \frac{2\pi}{N} \Rightarrow \Delta{\theta}&gt;\frac{\lambda}{Nlcos(\theta)}
\end{equation}
\]</span></p>
<p>因此，角分辨率为 <span class="math display">\[
\begin{equation}
\theta{res}=\frac{\lambda}{Nlcos(\theta)}
\end{equation}
\]</span> 通常假设<span class="math inline">\(d=\frac{\lambda}{2}\)</span>，<span class="math inline">\(\theta=0\)</span>,得 <span class="math display">\[
\begin{equation}
\theta{res}=\frac{2}{N}
\end{equation}
\]</span></p>
<h2 id="总结">总结</h2>
<ul>
<li>角度 <span class="math display">\[
\begin{equation}
\theta=sin^{-1}(\frac{\lambda{\Delta}\phi}{2\pi{l}})
\end{equation}
\]</span></li>
<li>最大角度 <span class="math display">\[
\begin{equation}
\theta_{max}=sin^{-1}（\frac{\lambda}{2l}）
\end{equation}
\]</span></li>
<li>角度分辨率 <span class="math display">\[
\begin{equation}
\theta{res}=\frac{2}{N}
\end{equation}
\]</span></li>
</ul>
<blockquote>
<p>因此，设计天线的个数以及间距对角度估算起决定性作用。</p>
</blockquote>
<h2 id="参考">参考</h2>
<ol type="1">
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NzY0ODY3L2FydGljbGUvZGV0YWlscy8xMDg5ODc4NTE/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDI=">汽车FMCW毫米波雷达信号处理流程<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>perception</category>
        <category>millimeter-wave radar</category>
      </categories>
      <tags>
        <tag>perception</tag>
        <tag>millimeter-wave radar</tag>
      </tags>
  </entry>
  <entry>
    <title>感知-超声波</title>
    <url>/2024/08/11/PerceptionUltrasonicRadar/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>在自动驾驶使用场景中，一般会使用各类传感器(摄像头、激光雷达、毫米波雷达和超声波雷达等)来感知周围环境信息，传感器收集的大量信息，通过各类算法最终融合到一个真实的语义地图上，下游模块通过该语义地图做相应的规划和决策。</p>
<figure>
<img data-src="https://i.imgur.com/8bSceod.jpeg" alt="花孔雀" /><figcaption aria-hidden="true">花孔雀</figcaption>
</figure>
<span id="more"></span>
<h2 id="超声波">超声波</h2>
<p>超声波雷达是一种利用声波反射原理进行测距的传感器，主要用于短距离测量，一般测量范围在0.1m-5m之间，具有体积小、成本低、安装方便等特点。</p>
<h3 id="测距原理">测距原理</h3>
<figure>
<img data-src="https://s2.loli.net/2024/08/11/Fhpx4VjbDR1MkWd.jpg" alt="测距原理" /><figcaption aria-hidden="true">测距原理</figcaption>
</figure>
<p><span class="math display">\[
D = T_{f} * V_{s} * k
\]</span></p>
<p>其中，<span class="math inline">\(T_f\)</span>表示超声波的飞行时间，及超声波走完距离<span class="math inline">\(D\)</span>所需的时间，<span class="math inline">\(V_s\)</span>表示声音在空气中的速度，<span class="math inline">\(k\)</span>表示一个接近0.5的常数，一般由传感器的结构决定(收发压电换能器的位置)。</p>
<h3 id="声速">声速</h3>
<p>声波在空气的速度与温度的关系近似如下： <span class="math display">\[V_s\approx20.055*\sqrt{T}\]</span> 其中，<span class="math inline">\(T\)</span>表示绝对温度，单位<span class="math inline">\(K\)</span>。 当温度在 <span class="math inline">\(0-40℃\)</span>范围变化是，声速在<span class="math inline">\(330-360 m/s\)</span>范围内变化，因此温度应作为距离的测量的关键因素考虑，故一般要求安装温度传感器获取环境温度。</p>
<h3 id="声波特性">声波特性</h3>
<figure>
<img data-src="https://s2.loli.net/2024/08/11/MRvDS2jpEZy8q1x.png" alt="声波特性" /><figcaption aria-hidden="true">声波特性</figcaption>
</figure>
<ul>
<li><strong>频率</strong>：声波的频率是指每秒钟内声波完成的全振动次数，单位为赫兹（Hz）。人耳能听到的声音频率范围大约在20 Hz到20,000 Hz之间。超声波传感器通常工作在更高的频率，如几十kHz甚至几百kHz。</li>
<li><strong>周期</strong>：声波的周期是指完成一次全振动所需要的时间，单位为秒（s）。频率和周期的关系是互为倒数，即 <span class="math inline">\(f = \frac{1}{T}\)</span>，其中<span class="math inline">\(f\)</span>表示频率，<span class="math inline">\(T\)</span>表示周期。</li>
<li><strong>波长</strong>：声波的波长是指在空气中传播时，两个相邻的同相位点之间的距离，单位为米（m）。波长和频率、声速的关系是 <span class="math inline">\(λ = \frac{v}{f}\)</span>，其中<span class="math inline">\(λ\)</span>表示波长，<span class="math inline">\(v\)</span>表示声速，<span class="math inline">\(f\)</span>表示频率。</li>
<li><strong>声速</strong>：声速是指声波在介质中传播的速度，单位为米每秒（m/s）。不同介质的声速不同，例如在空气中，声速约为340 m/s；在水中，声速约为1,500 m/s；在钢铁中，声速则高达5,000 m/s以上。</li>
<li><strong>振幅</strong>：声波的振幅是指声波的最大位移，单位为帕斯卡（Pa）或牛顿每平方米（N/m²）。振幅越大，声音的响度越高；振幅越小，声音的响度越低。</li>
</ul>
<p>超声波在不同介质下的传播特性如下：</p>
<figure>
<img data-src="https://s2.loli.net/2024/08/11/i9kVoaOK6sARbtl.png" alt="声波的反射与折射" /><figcaption aria-hidden="true">声波的反射与折射</figcaption>
</figure>
<h4 id="反射特性">反射特性</h4>
<p>如下图所示，超声波反射一般会遇到如下场景：</p>
<figure>
<img data-src="https://i.imgur.com/IOkVufX.png" alt="反射场景" /><figcaption aria-hidden="true">反射场景</figcaption>
</figure>
<h5 id="墙面反射">墙面反射</h5>
<figure>
<img data-src="https://s2.loli.net/2024/08/11/QRHbErZ64dnyAha.png" alt="墙面反射" /><figcaption aria-hidden="true">墙面反射</figcaption>
</figure>
<figure>
<img data-src="https://i.imgur.com/Q1TE46y.png" alt="反射原理" /><figcaption aria-hidden="true">反射原理</figcaption>
</figure>
<h5 id="墙角反射">墙角反射</h5>
<figure>
<img data-src="https://i.imgur.com/7Jv1zJY.png" alt="墙角反射原理" /><figcaption aria-hidden="true">墙角反射原理</figcaption>
</figure>
<h5 id="边沿反射">边沿反射</h5>
<figure>
<img data-src="https://i.imgur.com/tqYI1uX.png" alt="边沿反射原理" /><figcaption aria-hidden="true">边沿反射原理</figcaption>
</figure>
<p>不同场景下，不同入射角下，回波强度如下： <img data-src="https://i.imgur.com/u5ZRp4k.png" alt="信号强度与入射角的关系" /> 实际扫描数据如下： <img data-src="https://i.imgur.com/eeJmhsf.png" alt="实际扫描数据" /></p>
<h2 id="内部结构">内部结构</h2>
<figure>
<img data-src="https://i.imgur.com/iONqLvF.png" alt="超声结构示图" /><figcaption aria-hidden="true">超声结构示图</figcaption>
</figure>
<h3 id="接口定义">接口定义</h3>
<figure>
<img data-src="https://i.imgur.com/3SJXyKP.png" alt="接口定义" /><figcaption aria-hidden="true">接口定义</figcaption>
</figure>
<h3 id="总线方式">总线方式</h3>
<figure>
<img data-src="https://i.imgur.com/mc0mGZv.png" alt="Lin总线" /><figcaption aria-hidden="true">Lin总线</figcaption>
</figure>
<h3 id="长距超声">长距超声</h3>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://i.imgur.com/8MfDr4e.png" alt="横向" /></div><div class="group-picture-column"><img data-src="https://i.imgur.com/8MfDr4e.png" alt="竖向" /></div></div></div>
<h4 id="通信协议">通信协议</h4>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://i.imgur.com/qARFFhm.png" alt="数据读取" /></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://i.imgur.com/6eg5g7h.png" alt="距离转换" /></div><div class="group-picture-column"><img data-src="https://i.imgur.com/4c4B4gL.png" alt="信号强度" /></div></div></div>
<h3 id="短距超声">短距超声</h3>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://i.imgur.com/sUP65dB.png" alt="横向" /></div><div class="group-picture-column"><img data-src="https://i.imgur.com/kiMvLSQ.png" alt="竖向" /></div></div></div>
<h4 id="通信协议-1">通信协议</h4>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://i.imgur.com/deGImO6.png" alt="数据读取" /></div><div class="group-picture-column"><img data-src="https://i.imgur.com/OlRqAFZ.png" alt="距离转换" /></div></div></div>
<h3 id="总体布局">总体布局</h3>
<figure>
<img data-src="https://i.imgur.com/zJmzY9O.png" alt="安装布局" /><figcaption aria-hidden="true">安装布局</figcaption>
</figure>
<h3 id="安装要点">安装要点</h3>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://i.imgur.com/hgwfFJv.png" alt="1" /></div><div class="group-picture-column"><img data-src="https://i.imgur.com/XFIa72C.png" alt="2" /></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://i.imgur.com/EWLv0U6.png" alt="3" /></div><div class="group-picture-column"><img data-src="https://i.imgur.com/Wt7K99i.png" alt="4" /></div></div></div>
]]></content>
      <categories>
        <category>perception</category>
        <category>ultrasonic</category>
      </categories>
      <tags>
        <tag>perception</tag>
        <tag>ultrasonic</tag>
      </tags>
  </entry>
  <entry>
    <title>TVM export_lib函数分析</title>
    <url>/2021/10/08/TVM-ExportLibrary/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>本文分析<strong>executor_lib</strong>函数的处理过程，其中包括<strong>DSO</strong>模块的编译和<strong>imported modules</strong>模块的序列化。</p>
<figure>
<img data-src="https://i.loli.net/2021/10/10/3h8wfXOej514JLH.jpg" alt="条子泥" /><figcaption aria-hidden="true">条子泥</figcaption>
</figure>
<span id="more"></span>
<h2 id="分析">分析</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">export_library</span>(<span class="params">self, file_name, fcompile=<span class="literal">None</span>, addons=<span class="literal">None</span>, **kwargs</span>):</span><br><span class="line">    <span class="keyword">return</span> self.module.export_library(file_name, fcompile, addons, **kwargs)</span><br></pre></td></tr></table></figure>
<p>首先调用<strong>relay.build</strong>最终生成<strong>GraphExecutorFactoryModule</strong>对象，位于<code>python/tvm/relay/backend/executor_factory.py</code>文件中。使用<strong>export_library</strong>导出动态库时，实际上调用的是<strong>GraphExecutorFactoryModule</strong>类本身的<strong>module</strong>中的<strong>export_library</strong>函数。该对象指向<strong>tvm.graph_executor_factory.create</strong>函数，是在<strong>C++</strong>端实现的函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fcreate = get_global_func(<span class="string">&quot;tvm.graph_executor_factory.create&quot;</span>)</span><br><span class="line">args = []</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> params.items():</span><br><span class="line">    args.append(k)</span><br><span class="line">    args.append(ndarray.array(v))</span><br><span class="line">self.module = fcreate(graph_json_str, libmod, libmod_name, *args)</span><br></pre></td></tr></table></figure>
<p>接下来进入<code>src/runtime/graph_executor/graph_executor_factory.cc</code>文件，使用<strong>TVM_REGISTER_GLOBAL</strong>宏定义将函数暴露到python端，函数体是lamda表达式。首先进行参数数量检查，然后进行参数重组，将参数按照命名存储进<strong>params</strong>对象中，然后创建<strong>GraphExecutorFactory</strong>对象。其中<strong>module_name</strong>默认值为<strong>default</strong>。然后导入所有<strong>runtime_module</strong>，最后将<strong>GraphExecutorFactory</strong>对象传入<strong>Module</strong>模块并返回。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TVM_REGISTER_GLOBAL</span>(<span class="string">&quot;tvm.graph_executor_factory.create&quot;</span>)</span><br><span class="line">    .<span class="built_in">set_body</span>([](TVMArgs args, TVMRetValue* rv) &#123;</span><br><span class="line">        <span class="built_in">ICHECK_GE</span>(args.num_args, <span class="number">3</span>) &lt;&lt; <span class="string">&quot;The expected number of arguments for &quot;</span></span><br><span class="line">            <span class="string">&quot;graph_executor_factory.create needs at least 3, &quot;</span></span><br><span class="line">            <span class="string">&quot;but it has &quot;</span></span><br><span class="line">            &lt;&lt; args.num_args;</span><br><span class="line">        <span class="comment">// The argument order is graph_json, module, module_name, param0_name, param0_tensor,</span></span><br><span class="line">        <span class="comment">// [param1_name, param1_tensor], ...</span></span><br><span class="line">        <span class="built_in">ICHECK_EQ</span>((args.<span class="built_in">size</span>() - <span class="number">3</span>) % <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        std::unordered_map&lt;std::string, tvm::runtime::NDArray&gt; params;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">3</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(args.<span class="built_in">size</span>()); i += <span class="number">2</span>) &#123;</span><br><span class="line">            std::string name = args[i].<span class="keyword">operator</span> <span class="built_in">String</span>();</span><br><span class="line">            params[name] = args[i + <span class="number">1</span>].<span class="keyword">operator</span> tvm::runtime::<span class="built_in">NDArray</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// graph_json, params, module_name</span></span><br><span class="line">        <span class="keyword">auto</span> exec = <span class="built_in">make_object</span>&lt;GraphExecutorFactory&gt;(args[<span class="number">0</span>], params, args[<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">// module</span></span><br><span class="line">        exec-&gt;<span class="built_in">Import</span>(args[<span class="number">1</span>]);</span><br><span class="line">        *rv = <span class="built_in">Module</span>(exec);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="module">Module</h3>
<h4 id="export_library">export_library</h4>
<p>关于<strong>Module</strong>类位于<code>python/tvm/runtime/module.py</code>文件中，该类中包含<strong>export_library</strong>函数。该函数的主要作用是将模块和所有被导入模块导出为一个简单的动态库。</p>
<h5 id="collect-dso-module">Collect DSO Module</h5>
<p>首先收集所有<strong>DSO</strong>模块(LLVM Module 和 C Module)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">modules = self._collect_dso_modules()</span><br></pre></td></tr></table></figure>
<h5 id="save-file">Save File</h5>
<p>一旦收集到所有的<strong>DSO</strong>模块，就可以调用<strong>runtime</strong>模块的<strong>save</strong>函数将其保存为文件格式。通过遍历所有<strong>DSO</strong>模块，根据其类型键设置相应的文件后缀，并通过<strong>save</strong>函数将模块保存为相应的文件类型，并将该文件添加到<strong>files</strong>数组序列中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> index, module <span class="keyword">in</span> <span class="built_in">enumerate</span>(modules):</span><br><span class="line">    <span class="keyword">if</span> fcompile <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="built_in">hasattr</span>(fcompile, <span class="string">&quot;object_format&quot;</span>):</span><br><span class="line">        <span class="keyword">if</span> module.type_key == <span class="string">&quot;c&quot;</span>:</span><br><span class="line">            object_format = <span class="string">&quot;c&quot;</span></span><br><span class="line">            has_c_module = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            object_format = fcompile.object_format</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> module.type_key == <span class="string">&quot;llvm&quot;</span>:</span><br><span class="line">            object_format = <span class="string">&quot;o&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">assert</span> module.type_key == <span class="string">&quot;c&quot;</span></span><br><span class="line">            object_format = <span class="string">&quot;c&quot;</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;cc&quot;</span> <span class="keyword">in</span> kwargs:</span><br><span class="line">                <span class="keyword">if</span> kwargs[<span class="string">&quot;cc&quot;</span>] == <span class="string">&quot;nvcc&quot;</span>:</span><br><span class="line">                    object_format = <span class="string">&quot;cu&quot;</span></span><br><span class="line">            has_c_module = <span class="literal">True</span></span><br><span class="line">    path_obj = os.path.join(workspace_dir, <span class="string">f&quot;lib<span class="subst">&#123;index&#125;</span>.<span class="subst">&#123;object_format&#125;</span>&quot;</span>)</span><br><span class="line">    module.save(path_obj)</span><br><span class="line">    files.append(path_obj)</span><br><span class="line">    is_system_lib = (</span><br><span class="line">        module.type_key == <span class="string">&quot;llvm&quot;</span> <span class="keyword">and</span> module.get_function(<span class="string">&quot;__tvm_is_system_module&quot;</span>)()</span><br><span class="line">    )</span><br><span class="line">    llvm_target_triple = (</span><br><span class="line">        module.type_key == <span class="string">&quot;llvm&quot;</span> <span class="keyword">and</span> module.get_function(<span class="string">&quot;_get_target_triple&quot;</span>)()</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<h6 id="save函数">save函数</h6>
<p>关于<strong>save</strong>函数，其调用C++端的函数<strong>ModuleSaveToFile</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">save</span>(<span class="params">self, file_name, fmt=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Save the module to file.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This do not save the dependent device modules.</span></span><br><span class="line"><span class="string">    See also export_shared</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    file_name : str</span></span><br><span class="line"><span class="string">    The name of the file.</span></span><br><span class="line"><span class="string">    fmt : str</span></span><br><span class="line"><span class="string">    The format of the file.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    See Also</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    runtime.Module.export_library : export the module to shared library.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    _ffi_api.ModuleSaveToFile(self, file_name, fmt)</span><br></pre></td></tr></table></figure>
<p>该函数使用各个模块的<strong>SaveToFile</strong>函数将模块保存为文件形式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TVM_REGISTER_GLOBAL</span>(<span class="string">&quot;runtime.ModuleSaveToFile&quot;</span>)</span><br><span class="line">    .<span class="built_in">set_body_typed</span>([](Module mod, tvm::String name, tvm::String fmt) &#123;</span><br><span class="line">        mod-&gt;<span class="built_in">SaveToFile</span>(name, fmt);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h5 id="impoerted-modules">Impoerted Modules</h5>
<p>检查是否存在<strong>imported modules</strong>(像<strong>CUDA</strong>、<strong>OpenCL</strong>等)。这里不限制模块类型，一旦存在<strong>imports modules</strong>，将创建命名为<code>devc.o</code>或<code>devc.c</code>的文件。这就可以将<strong>imports modules</strong>的二进制<strong>blob</strong>数据嵌入进动态库中。然后调用<strong>ModulePackImportsToLLVM</strong>或<strong>ModulePackImportsToC</strong>进行模块序列化(<strong>module serialization</strong>)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> self.imported_modules:</span><br><span class="line">    <span class="keyword">if</span> enabled(<span class="string">&quot;llvm&quot;</span>) <span class="keyword">and</span> llvm_target_triple:</span><br><span class="line">        path_obj = os.path.join(workspace_dir, <span class="string">f&quot;devc.<span class="subst">&#123;object_format&#125;</span>&quot;</span>)</span><br><span class="line">        m = _ffi_api.ModulePackImportsToLLVM(self, is_system_lib, llvm_target_triple)</span><br><span class="line">        m.save(path_obj)</span><br><span class="line">        files.append(path_obj)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        path_cc = os.path.join(workspace_dir, <span class="string">&quot;devc.c&quot;</span>)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(path_cc, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(_ffi_api.ModulePackImportsToC(self, is_system_lib))</span><br><span class="line">        files.append(path_cc)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：使用<strong>PackImportsToLLVM</strong>或<strong>PackImportsToC</strong>取决于是否在TVM中使能LLVM，事实上它们的目标相同。</p>
</blockquote>
<h5 id="function-compile">Function Compile</h5>
<p>最后调用<strong>fcompile</strong>去编译生成动态共享库(so)。如果用户没有指定编译器类型，默认采用<strong>cc</strong>编译器，如果文件是<strong>tar</strong>压缩文件，则进行文件解压。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> fcompile:</span><br><span class="line">    <span class="keyword">if</span> file_name.endswith(<span class="string">&quot;.tar&quot;</span>):</span><br><span class="line">        fcompile = _tar.tar</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        fcompile = _cc.create_shared</span><br></pre></td></tr></table></figure>
<p>如果用户指定了编译器，一般在部署到设备端时会指定交叉编译工具，则使用用户指定的编译器进行编译。编译输入参数包括编译生成的文件名，待编译的文件组和编译参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fcompile(file_name, files, **kwargs)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于C 源码模块，将编译他们并一起与DSO模块进行链接。</p>
</blockquote>
<h4 id="module-serialization">Module Serialization</h4>
<p>在文件<code>src/target/codegen.cc</code>中，注册了全局函数<strong>runtime.ModulePackImportsToC</strong>和<strong>runtime.ModulePackImportsToLLVM</strong>，用于将其暴露到<strong>python</strong>端调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Export two auxiliary function to the runtime namespace.</span></span><br><span class="line"><span class="built_in">TVM_REGISTER_GLOBAL</span>(<span class="string">&quot;runtime.ModulePackImportsToC&quot;</span>).<span class="built_in">set_body_typed</span>(PackImportsToC);</span><br><span class="line"><span class="built_in">TVM_REGISTER_GLOBAL</span>(<span class="string">&quot;runtime.ModulePackImportsToLLVM&quot;</span>).<span class="built_in">set_body_typed</span>(PackImportsToLLVM);</span><br></pre></td></tr></table></figure>
<h5 id="serializemodule">SerializeModule</h5>
<p>其中，<strong>PackImportsToC</strong>和<strong>PackImportsToLLVM</strong>函数都调用<strong>SerializeModule</strong>函数序列化<strong>runtime module</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">PackImportsToC</span><span class="params">(<span class="type">const</span> runtime::Module&amp; mod, <span class="type">bool</span> system_lib)</span> </span>&#123;</span><br><span class="line">    std::string bin = <span class="built_in">SerializeModule</span>(mod);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">runtime::Module <span class="title">PackImportsToLLVM</span><span class="params">(<span class="type">const</span> runtime::Module&amp; mod, <span class="type">bool</span> system_lib,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">const</span> std::string&amp; target_triple)</span> </span>&#123;</span><br><span class="line">    std::string bin = <span class="built_in">SerializeModule</span>(mod);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="moduleserializer">ModuleSerializer</h5>
<p>首先在<strong>SerializeModule</strong>函数中创建一个帮手类<strong>ModuleSerializer</strong>，其传入<strong>module</strong>做一些初始化工作，像标注模块的索引号等，然后调用该类的<strong>SerializeModule</strong>函数序列化模块。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">SerializeModule</span><span class="params">(<span class="type">const</span> runtime::Module&amp; mod)</span> </span>&#123;</span><br><span class="line">    std::string bin;</span><br><span class="line">    <span class="function">dmlc::MemoryStringStream <span class="title">ms</span><span class="params">(&amp;bin)</span></span>;</span><br><span class="line">    dmlc::Stream* stream = &amp;ms;</span><br><span class="line"></span><br><span class="line">    <span class="function">ModuleSerializer <span class="title">module_serializer</span><span class="params">(mod)</span></span>;</span><br><span class="line">    module_serializer.<span class="built_in">SerializeModule</span>(stream);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建<strong>module_serializer</strong>对象时，其构造函数调用<strong>Init</strong>函数进行初始化操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">ModuleSerializer</span><span class="params">(runtime::Module mod)</span> : mod_(mod) &#123;</span> <span class="built_in">Init</span>(); &#125;</span><br></pre></td></tr></table></figure>
<h6 id="init">Init</h6>
<p>而在<code>Init</code>函数中，分别调用<strong>CreateModuleIndex</strong>和<strong>CreateImportTree</strong>函数，用于创建<strong>模块索引号</strong>和<strong>导入树</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">CreateModuleIndex</span>();</span><br><span class="line">    <span class="built_in">CreateImportTree</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>CreateModuleIndex</li>
</ul>
<p>在函数<strong>CreateModuleIndex</strong>中将使用<strong>DFS</strong>(深度优先)算法检查模块导入关系并为其创建索引，注意根模块固定为位置0。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">llvm_mod<span class="punctuation">:</span>imported_modules</span><br><span class="line">  - cuda_mod</span><br><span class="line">  - opencl_mod</span><br></pre></td></tr></table></figure>
<p>因此，<strong>LLVM</strong>模块将会拥有索引值0，<strong>CUDA</strong>模块将拥有索引值1，<strong>OpenCL</strong>模块将拥有索引值为2。</p>
<ul>
<li>CreateImportTree</li>
</ul>
<p>在构建模块索引号后，<strong>CreateImportTree</strong>函数将尝试构建导入树，用于将导出的库加载回来时，恢复模块的导入关系。使用<strong>CSR</strong>(Compressed Sparse Row)格式存储导入树。每一行都是父索引，子索引对应其子索引。</p>
<p>使用<code>import_tree_row_ptr_</code>表示行偏移，即某一行的第一个元素在values里面的起始偏移位置。<code>import_tree_child_indices_</code>表示子索引值。</p>
<h6 id="serializemodule-1">SerializeModule</h6>
<p>通过上述两个函数初始化后，可以使用<strong>SerializeModule</strong>函数序列化模块。在其功能逻辑中，假定序列化格式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">binary_blob_size</span><br><span class="line">binary_blob_type_key</span><br><span class="line">binary_blob_logic</span><br><span class="line">binary_blob_type_key</span><br><span class="line">binary_blob_logic</span><br><span class="line">...</span><br><span class="line">_import_tree</span><br><span class="line">_import_tree_logic</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>binary_blob_size</strong></li>
</ul>
<p>表示序列化步骤中将拥有的<strong>blob</strong>数量。如果只有一个<strong>DSO</strong>模块并且是根模块，将不产生<code>import_tree_</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Only have one DSO module and it is in the root, then</span></span><br><span class="line"><span class="comment">// we will not produce import_tree_.</span></span><br><span class="line"><span class="type">bool</span> has_import_tree = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">DSOExportable</span>(mod_.<span class="keyword">operator</span>-&gt;()) &amp;&amp; mod_-&gt;<span class="built_in">imports</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    has_import_tree = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据是否存在<code>import_tree_</code>，如果不存在，<strong>binary_blob_size</strong>字段直接写入模块数量，否则写入所有模块数量并追加1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> sz = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (has_import_tree) &#123;</span><br><span class="line">    <span class="comment">// we will append one key for _import_tree</span></span><br><span class="line">    <span class="comment">// The layout is the same as before: binary_size, key, logic, key, logic...</span></span><br><span class="line">    sz = mod_group_vec_.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Keep the old behaviour</span></span><br><span class="line">    sz = mod_-&gt;<span class="built_in">imports</span>().<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line">stream-&gt;<span class="built_in">Write</span>(sz);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>binary_blob_type_key</strong></li>
</ul>
<p>表示模块的<strong>blob</strong>类型键，对于LLVM或C模块，其<strong>blob</strong>类型键是<code>_lib</code>。而其它模块，像<strong>CUDA</strong>模块，其类型键为<strong>cuda</strong>；<strong>OpenCL</strong>模块，其类型键为<strong>opencl</strong>等。关于类型键的可以通过<strong>module-&gt;type_key()</strong>获取。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; group : mod_group_vec_) &#123;</span><br><span class="line">    <span class="built_in">ICHECK_NE</span>(group.<span class="built_in">size</span>(), <span class="number">0</span>) &lt;&lt; <span class="string">&quot;Every allocated group must have at least one module&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">DSOExportable</span>(group[<span class="number">0</span>])) &#123;</span><br><span class="line">        <span class="built_in">ICHECK_EQ</span>(group.<span class="built_in">size</span>(), <span class="number">1U</span>) &lt;&lt; <span class="string">&quot;Non DSO module is never merged&quot;</span>;</span><br><span class="line">        std::string mod_type_key = group[<span class="number">0</span>]-&gt;<span class="built_in">type_key</span>();</span><br><span class="line">        stream-&gt;<span class="built_in">Write</span>(mod_type_key);</span><br><span class="line">        group[<span class="number">0</span>]-&gt;<span class="built_in">SaveToBinary</span>(stream);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// DSOExportable: do not need binary</span></span><br><span class="line">        <span class="keyword">if</span> (has_import_tree) &#123;</span><br><span class="line">            std::string mod_type_key = <span class="string">&quot;_lib&quot;</span>;</span><br><span class="line">            stream-&gt;<span class="built_in">Write</span>(mod_type_key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>binary_blob_logic</strong></li>
</ul>
<p>表示<strong>blob</strong>的逻辑处理，对于大多数的<strong>blob</strong>(像<strong>CUDA</strong>、<strong>OpenCL</strong>)，将会调用其模块的<strong>SaveToBinary</strong>函数序列化为二进制形式。但是像<strong>LLVM</strong>或<strong>C</strong>模块，只要写入<code>_lib</code>字符，表明该模块是<code>DSO</code>模块。</p>
<ul>
<li><strong>import_tree</strong></li>
</ul>
<p>除非模块只有一个<strong>DSO</strong>模块且为根模块，不需要写入<code>_import_tree</code>字段，其它情况都需要写入。当将导出的库需要加载回来时，可以用其重构模块的导入关系。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Write _import_tree key if we have</span></span><br><span class="line"><span class="keyword">if</span> (has_import_tree) &#123;</span><br><span class="line">    std::string import_key = <span class="string">&quot;_import_tree&quot;</span>;</span><br><span class="line">    stream-&gt;<span class="built_in">Write</span>(import_key);</span><br><span class="line">    stream-&gt;<span class="built_in">Write</span>(import_tree_row_ptr_);</span><br><span class="line">    stream-&gt;<span class="built_in">Write</span>(import_tree_child_indices_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>import_tree_logic</strong></li>
</ul>
<p>将<code>import_tree_row_ptr_</code>和<code>import_tree_child_indices_</code>数组内容写入数据流。</p>
<h5 id="pack">Pack</h5>
<p>经过上述序列化步骤后，将数据流打包成一个符号(<strong>runtime::symbol::tvm_dev_mblob</strong>)，这样就可以在需要时从动态库中恢复模块内容。写入动态库中的符号为<code>__tvm_dev_mblob</code>，根据序列化后的数据流大小创建以<code>__tvm_dev_mblob</code>为符号的数组<code>const unsigned char __tvm_dev_mblob[bin.length() + sizeof(nbytes)]&#123;&#125;</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> nbytes = bin.<span class="built_in">length</span>();</span><br><span class="line">os &lt;&lt; <span class="string">&quot;const unsigned char &quot;</span> &lt;&lt; runtime::symbol::tvm_dev_mblob &lt;&lt; <span class="string">&quot;[&quot;</span></span><br><span class="line">   &lt;&lt; bin.<span class="built_in">length</span>() + <span class="built_in">sizeof</span>(nbytes) &lt;&lt; <span class="string">&quot;] = &#123;\n  &quot;</span>;</span><br></pre></td></tr></table></figure>
<p>前八个字节存储序列化数据流的字节数大小，按照16进制形式保存。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(nbytes); ++i) &#123;</span><br><span class="line">    <span class="comment">// sperators</span></span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;0x&quot;</span> &lt;&lt; ((nbytes &gt;&gt; (i * <span class="number">8</span>)) &amp; <span class="number">0xff</span>UL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>20个字节为一行，保存序列化数据。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; bin.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">    <span class="comment">// sperators</span></span><br><span class="line">    <span class="keyword">if</span> ((i + <span class="built_in">sizeof</span>(nbytes)) % nunit == <span class="number">0</span>) &#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;,\n  &quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> c = bin[i];</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;0x&quot;</span> &lt;&lt; (c &amp; <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<ol type="1">
<li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veGJpbndvcmxkL3AvNDI3MzUwNi5odG1s">稀疏矩阵存储格式总结+存储效率对比:COO,CSR,DIA,ELL,HYB<i class="fa fa-external-link-alt"></i></span></p></li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsYWkwNC9hcnRpY2xlL2RldGFpbHMvNzMzMjMw">用STL实现DFS/BFS算法——检查重复状态<i class="fa fa-external-link-alt"></i></span></p></li>
</ol>
]]></content>
      <categories>
        <category>TVM</category>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>TVM</tag>
        <tag>runtime</tag>
        <tag>Module</tag>
        <tag>export_library</tag>
      </tags>
  </entry>
  <entry>
    <title>TVM LoadFromFile函数分析</title>
    <url>/2021/09/29/TVM-LoadFromFile/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>本文主要分析动态库(.so)文件的加载过程，其中包括模块的<strong>反序列化</strong>和<strong>GraphExecuter</strong> 的创建流程。</p>
<figure>
<img data-src="https://i.loli.net/2021/10/07/pxhqTXVPRGmSMv5.jpg" alt="东台条子泥" /><figcaption aria-hidden="true">东台条子泥</figcaption>
</figure>
<span id="more"></span>
<h2 id="动态库加载">动态库加载</h2>
<p>当使用函数<strong>relay.build</strong>将模型转换为<strong>GraphExecutorFactoryModule</strong>类型的<strong>lib</strong>对象后，就可以在<strong>python</strong>端和<strong>C++</strong>端调用库文件去执行模型推理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lib = relay.build(model, target, params)</span><br></pre></td></tr></table></figure>
<h3 id="直接构建">直接构建</h3>
<p>由于<strong>lib</strong>的类型为<strong>GraphExecutorFactory</strong>，且在编译阶段，如果用户不特别指定模型名，默认模型名为<strong>default</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">ir_mod, target=<span class="literal">None</span>, target_host=<span class="literal">None</span>, params=<span class="literal">None</span>, mod_name=<span class="string">&quot;default&quot;</span></span>):</span><br></pre></td></tr></table></figure>
<p>可以基于<strong>lib</strong>对象直接构建运行模块，其中<code>lib["default"](dev)</code>操作相当于调用<strong>GetFunction</strong>函数传入参数<strong>dev</strong>并返回模块名为<strong>default</strong>的<strong>runtime Module</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">PackedFunc <span class="title">GraphExecutorFactory::GetFunction</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; name, <span class="type">const</span> tvm::runtime::ObjectPtr&lt;tvm::runtime::Object&gt;&amp; sptr_to_self)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == module_name_) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">PackedFunc</span>([sptr_to_self, <span class="keyword">this</span>](TVMArgs args, TVMRetValue* rv) &#123;</span><br><span class="line">            std::vector&lt;Device&gt; devices;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; args.num_args; ++i) &#123;</span><br><span class="line">                devices.<span class="built_in">emplace_back</span>(args[i].<span class="keyword">operator</span> <span class="built_in">Device</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            *rv = <span class="keyword">this</span>-&gt;<span class="built_in">ExecutorCreate</span>(devices);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后使用<code>python/tvm/contrib/graph_executor.py</code>文件中的<strong>GraphModule</strong>类型对返回的<strong>runtime Module</strong>进行封装。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">graph_mod = tvm.contrib.GraphModule(lib[<span class="string">&quot;default&quot;</span>](dev))</span><br></pre></td></tr></table></figure>
<p>上述封装方便使用统一接口进行模型输入设定、运行和获取输出结果等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">graph_mod.set_input(<span class="string">&quot;x&quot;</span>, data)</span><br><span class="line">graph_mod.run()</span><br><span class="line">graph_mod.get_output(<span class="number">0</span>, out_data)</span><br></pre></td></tr></table></figure>
<h3 id="基于动态库文件构建">基于动态库文件构建</h3>
<p>基于动态库文件的构建方式，首先需要调用<strong>GraphExecutorFactoryModule</strong>类中的<strong>export_library</strong>函数，将<strong>lib</strong>对象导出为<code>xxx.so</code>动态库的形式。然后在需要构建时调用<strong>load_module</strong>或<strong>LoadFromFile</strong>函数加载动态库并生成相应的<strong>runtime::Module</strong>对象。</p>
<ul>
<li><strong>python</strong>端</li>
</ul>
<p>在<code>python/tvm/runtime/module.py</code>文件中，使用<strong>tvm.runtime.load_module</strong>函数加载动态库。</p>
<ul>
<li><strong>C++</strong>端</li>
</ul>
<p>在<code>src/runtime/module.cc</code>文件中，使用<strong>tvm::runtime::Module::LoadFromFile</strong>函数加载动态库。</p>
<h4 id="load_module">load_module</h4>
<p>首先判定待加载文件是否存在，然后根据文件后缀类型是否为<code>.o</code>或<code>.tar</code>，自动调用<strong>cc.create_shared</strong>编译器进行文件编译并生成<code>.so</code>库文件并追加到<strong>path</strong>中。支持该操作是为了与<strong>RPC</strong>加载保持一致。最后调用全局函数<strong>ModuleLoadFromFile</strong>，通过<strong>TVM_REGISTER_GLOBAL</strong>宏将<strong>Module::LoadFromFile</strong>函数注册为全局函数<strong>runtime.ModuleLoadFromFile</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_module</span>(<span class="params">path, fmt=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(path):</span><br><span class="line">        path = os.path.realpath(path)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;cannot find file %s&quot;</span> % path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># c++ compiler/linker</span></span><br><span class="line">    cc = os.environ.get(<span class="string">&quot;CXX&quot;</span>, <span class="string">&quot;g++&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># High level handling for .o and .tar file.</span></span><br><span class="line">    <span class="comment"># We support this to be consistent with RPC module load.</span></span><br><span class="line">    <span class="keyword">if</span> path.endswith(<span class="string">&quot;.o&quot;</span>):</span><br><span class="line">        <span class="comment"># Extra dependencies during runtime.</span></span><br><span class="line">        <span class="keyword">from</span> tvm.contrib <span class="keyword">import</span> cc <span class="keyword">as</span> _cc</span><br><span class="line"></span><br><span class="line">        _cc.create_shared(path + <span class="string">&quot;.so&quot;</span>, path, cc=cc)</span><br><span class="line">        path += <span class="string">&quot;.so&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> path.endswith(<span class="string">&quot;.tar&quot;</span>):</span><br><span class="line">        <span class="comment"># Extra dependencies during runtime.</span></span><br><span class="line">        <span class="keyword">from</span> tvm.contrib <span class="keyword">import</span> cc <span class="keyword">as</span> _cc, utils <span class="keyword">as</span> _utils, tar <span class="keyword">as</span> _tar</span><br><span class="line"></span><br><span class="line">        tar_temp = _utils.tempdir(custom_path=path.replace(<span class="string">&quot;.tar&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">        _tar.untar(path, tar_temp.temp_dir)</span><br><span class="line">        files = [tar_temp.relpath(x) <span class="keyword">for</span> x <span class="keyword">in</span> tar_temp.listdir()]</span><br><span class="line">        _cc.create_shared(path + <span class="string">&quot;.so&quot;</span>, files, cc=cc)</span><br><span class="line">        path += <span class="string">&quot;.so&quot;</span></span><br><span class="line">    <span class="comment"># Redirect to the load API</span></span><br><span class="line">    <span class="keyword">return</span> _ffi_api.ModuleLoadFromFile(path, fmt)</span><br></pre></td></tr></table></figure>
<h4 id="loadfromfile">LoadFromFile</h4>
<p>首先进行文件的类型判断，如果类型为<strong>dll</strong>、<strong>dylib</strong>或<strong>dso</strong>，统一调用<strong>runtime.module.loadfile_so</strong>函数进行文件处理。然后根据文件后缀类型，调用不同的加载函数<code>std::string load_f_name = "runtime.module.loadfile_" + fmt</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Module <span class="title">Module::LoadFromFile</span><span class="params">(<span class="type">const</span> std::string&amp; file_name, <span class="type">const</span> std::string&amp; format)</span> </span>&#123;</span><br><span class="line">  std::string fmt = <span class="built_in">GetFileFormat</span>(file_name, format);</span><br><span class="line">  <span class="built_in">ICHECK</span>(fmt.<span class="built_in">length</span>() != <span class="number">0</span>) &lt;&lt; <span class="string">&quot;Cannot deduce format of file &quot;</span> &lt;&lt; file_name;</span><br><span class="line">  <span class="keyword">if</span> (fmt == <span class="string">&quot;dll&quot;</span> || fmt == <span class="string">&quot;dylib&quot;</span> || fmt == <span class="string">&quot;dso&quot;</span>) &#123;</span><br><span class="line">    fmt = <span class="string">&quot;so&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::string load_f_name = <span class="string">&quot;runtime.module.loadfile_&quot;</span> + fmt;</span><br><span class="line">  <span class="type">const</span> PackedFunc* f = Registry::<span class="built_in">Get</span>(load_f_name);</span><br><span class="line">  Module m = (*f)(file_name, format);</span><br><span class="line">  <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="runtime.module.loadfile_so">runtime.module.loadfile_so</h5>
<p>在<code>src/runtime/dso_library.cc</code>文件中注册了<strong>runtime.module.loadfile_so</strong>全局函数。首先创建<strong>DSOLibrary</strong>对象，并将待加载的文件名参数传入到<strong>init</strong>函数中，用于初始化<strong>DSOLibrary</strong>对象<strong>n</strong>。然后调用<strong>CreateModuleFromLibrary</strong>函数，将创建的<strong>DSOLibrary</strong>对象<strong>n</strong>传入该函数中，该函数位于文件<code>src/runtime/library_module.cc</code>中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TVM_REGISTER_GLOBAL</span>(<span class="string">&quot;runtime.module.loadfile_so&quot;</span>).<span class="built_in">set_body</span>([](TVMArgs args, TVMRetValue* rv) &#123;</span><br><span class="line">  <span class="keyword">auto</span> n = <span class="built_in">make_object</span>&lt;DSOLibrary&gt;();</span><br><span class="line">  n-&gt;<span class="built_in">Init</span>(args[<span class="number">0</span>]);</span><br><span class="line">  *rv = <span class="built_in">CreateModuleFromLibrary</span>(n);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h6 id="dsolibrary">DSOLibrary</h6>
<p>根据系统平台不同，<strong>DSOLibrary</strong>对象会调用不同的<strong>Load</strong>函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> </span>&#123; <span class="built_in">Load</span>(name); &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Windows</strong></li>
</ul>
<p>使用<code>#include &lt;windows.h&gt;</code>函数库加载动态库。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Load the library</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Load</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// use wstring version that is needed by LLVM.</span></span><br><span class="line">    <span class="function">std::wstring <span class="title">wname</span><span class="params">(name.begin(), name.end())</span></span>;</span><br><span class="line">    lib_handle_ = <span class="built_in">LoadLibraryW</span>(wname.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">ICHECK</span>(lib_handle_ != <span class="literal">nullptr</span>) &lt;&lt; <span class="string">&quot;Failed to load dynamic shared library &quot;</span> &lt;&lt; name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Linux</strong></li>
</ul>
<p>使用<code>#include &lt;dlfcn.h&gt;</code>函数库来加载动态库。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Library handle</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* lib_handle_&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// load the library</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Load</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">lib_handle_ = <span class="built_in">dlopen</span>(name.<span class="built_in">c_str</span>(), RTLD_LAZY | RTLD_LOCAL);</span><br><span class="line"></span><br><span class="line"><span class="built_in">ICHECK</span>(lib_handle_ != <span class="literal">nullptr</span>) &lt;&lt; <span class="string">&quot;Failed to load dynamic shared library &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">dlerror</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="createmodulefromlibrary">CreateModuleFromLibrary</h6>
<p>该函数主要实现从动态库中恢复<strong>runtime::Module</strong>对象的过程，包括反序列化和重新构建模块间导入的关系。</p>
<ul>
<li><strong>InitContextFunctions</strong></li>
</ul>
<p>调用<strong>InitContextFunctions</strong>函数从动态库中获取上下文相关函数的函数句柄。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">InitContextFunctions</span>([lib](<span class="type">const</span> <span class="type">char</span>* fname) &#123; <span class="keyword">return</span> lib-&gt;<span class="built_in">GetSymbol</span>(fname); &#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Load the imported modules</strong></li>
</ul>
<p>从动态库中获取<code>__tvm_dev_mblob</code>符号，将符号地址返回到<strong>dev_mblob</strong>对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* dev_mblob = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(lib-&gt;<span class="built_in">GetSymbol</span>(runtime::symbol::tvm_dev_mblob));</span><br></pre></td></tr></table></figure>
<p>如果<code>dev_mblob != nullptr</code>，即动态库中存在<code>__tvm_dev_mblob</code>符号，说明动态库中存在序列化的<strong>imported modules</strong>，则调用<strong>ProcessModuleBlob</strong>函数对其进行处理。否则表明动态库中只有一个简单的<strong>DSO Module</strong>，直接将动态库转为<strong>LibraryModuleNode</strong>对象<strong>n</strong>，并基于<strong>n</strong>构造<strong>runtime::Module</strong>对象<strong>root_mod</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (dev_mblob != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">ProcessModuleBlob</span>(dev_mblob, lib, &amp;root_mod, &amp;dso_ctx_addr);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Only have one single DSO Module</span></span><br><span class="line">    root_mod = <span class="built_in">Module</span>(n);</span><br><span class="line">    dso_ctx_addr = root_mod.<span class="keyword">operator</span>-&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="initcontextfunctions">InitContextFunctions</h6>
<p>函数<strong>InitContextFunctions</strong>用于初始化上下文函数，将动态库对应的函数的地址映射到相应函数名，即从动态库中获取相关功能函数的函数句柄。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Initialize the functions</span></span><br><span class="line"><span class="built_in">TVM_INIT_CONTEXT_FUNC</span>(TVMFuncCall);</span><br><span class="line"><span class="built_in">TVM_INIT_CONTEXT_FUNC</span>(TVMAPISetLastError);</span><br><span class="line"><span class="built_in">TVM_INIT_CONTEXT_FUNC</span>(TVMBackendGetFuncFromEnv);</span><br><span class="line"><span class="built_in">TVM_INIT_CONTEXT_FUNC</span>(TVMBackendAllocWorkspace);</span><br><span class="line"><span class="built_in">TVM_INIT_CONTEXT_FUNC</span>(TVMBackendFreeWorkspace);</span><br><span class="line"><span class="built_in">TVM_INIT_CONTEXT_FUNC</span>(TVMBackendParallelLaunch);</span><br><span class="line"><span class="built_in">TVM_INIT_CONTEXT_FUNC</span>(TVMBackendParallelBarrier);</span><br></pre></td></tr></table></figure>
<ul>
<li>ProcessModuleBlob</li>
</ul>
<p>该函数主要实现对序列化的<strong>module</strong>进行反序列化处理，恢复导入模块的关系。</p>
<ol type="1">
<li>获取字段大小</li>
</ol>
<p>首先根据<strong>dev_mblob</strong>字段的前<span style="color:red">8</span>个字节，获取<strong>blob</strong>字段的大小。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> nbytes = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(nbytes); ++i) &#123;</span><br><span class="line">    <span class="type">uint64_t</span> c = mblob[i];</span><br><span class="line">    nbytes |= (c &amp; <span class="number">0xff</span>UL) &lt;&lt; (i * <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>构建数据流</li>
</ol>
<p>根据<strong>blob</strong>字段的大小和地址，创建<strong>dmlc::MemoryFixedSizeStream fs</strong>对象，然后将<strong>fs</strong>对象转化为数据流。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">dmlc::MemoryFixedSizeStream <span class="title">fs</span><span class="params">(<span class="keyword">const_cast</span>&lt;<span class="type">char</span>*&gt;(mblob + <span class="keyword">sizeof</span>(nbytes)),</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">static_cast</span>&lt;<span class="type">size_t</span>&gt;(nbytes))</span></span>;</span><br><span class="line">dmlc::Stream* stream = &amp;fs;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>读取<strong>blob</strong>数量</li>
</ol>
<p>首先读取blob数量，然后根据数量大小，循环处理每个blob的对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> size;</span><br><span class="line"><span class="built_in">ICHECK</span>(stream-&gt;<span class="built_in">Read</span>(&amp;size));</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>处理<strong>blob</strong>对象</li>
</ol>
<p>在处理blob对象时，根据<strong>type_key</strong>类型不同，分别进行不同方式的处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;Module&gt; modules;</span><br><span class="line">std::vector&lt;<span class="type">uint64_t</span>&gt; import_tree_row_ptr;</span><br><span class="line">std::vector&lt;<span class="type">uint64_t</span>&gt; import_tree_child_indices;</span><br><span class="line"><span class="type">int</span> num_dso_module = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">uint64_t</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">    std::string tkey;</span><br><span class="line">    <span class="built_in">ICHECK</span>(stream-&gt;<span class="built_in">Read</span>(&amp;tkey));</span><br><span class="line">    <span class="keyword">if</span> (tkey == <span class="string">&quot;_lib&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// construct dso module using lib</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tkey == <span class="string">&quot;_import_tree&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// READ(_import_tree_row_ptr)</span></span><br><span class="line">        <span class="comment">// READ(_import_tree_child_indices)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// call module.loadbinary_blob_type_key, such as module.loadbinary_cuda to restore.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>type_key == "_lib"</code></li>
</ul>
<p>如果类型键为<code>_lib</code>，直接将动态库转化为<strong>LibraryModuleNode</strong>对象，然后调用<strong>runtime::Module</strong>构造函数，进一步转化为<strong>dso_module</strong>对象，并且<strong>DSO</strong>的上下文地址也指向<strong>dso_module</strong>对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> dso_module = <span class="built_in">Module</span>(<span class="built_in">make_object</span>&lt;LibraryModuleNode&gt;(lib));</span><br><span class="line">*dso_ctx_addr = dso_module.<span class="keyword">operator</span>-&gt;();</span><br><span class="line">++num_dso_module;</span><br><span class="line">modules.<span class="built_in">emplace_back</span>(dso_module);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>type_key == "_import_tree"</code></li>
</ul>
<p>如果类型键为<code>_import_tree</code>，则依次读取<strong>import_tree_row_ptr</strong>和<strong>import_tree_child_indices</strong>数组的内容，用于后续构建导入模块的关系。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ICHECK</span>(stream-&gt;<span class="built_in">Read</span>(&amp;import_tree_row_ptr));</span><br><span class="line"><span class="built_in">ICHECK</span>(stream-&gt;<span class="built_in">Read</span>(&amp;import_tree_child_indices));</span><br></pre></td></tr></table></figure>
<ul>
<li><code>other type_key</code></li>
</ul>
<p>如果类型键非<code>_lib</code>或<code>_import_tree</code>类型，则调用<strong>LoadModuleFromBinary</strong>函数从二进制流中根据<strong>type_key</strong>加载相应的<strong>runtime::Module</strong>，并将模型推送进<strong>modules</strong>对象中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> m = <span class="built_in">LoadModuleFromBinary</span>(tkey, stream);</span><br><span class="line">modules.<span class="built_in">emplace_back</span>(m);</span><br></pre></td></tr></table></figure>
<p>在函数<strong>LoadModuleFromBinary</strong>中，调用注册的全局函数<code>runtime.module.loadbinary_ + type_key</code>，实现二进制数据流到相应<strong>runtime::Module</strong>的转换。目前<strong>TVM</strong>框架中已经存在的<code>type_key</code>包括如下：</p>
<table>
<thead>
<tr class="header">
<th>arm_compute_lib</th>
<th>bnns_json</th>
<th>coreml</th>
<th>dnnl_json</th>
<th>ethos-n</th>
<th>tensorrt</th>
<th>cuda</th>
<th>opencl</th>
<th>vulkan</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Module <span class="title">LoadModuleFromBinary</span><span class="params">(<span class="type">const</span> std::string&amp; type_key, dmlc::Stream* stream)</span> </span>&#123;</span><br><span class="line">    std::string loadkey = <span class="string">&quot;runtime.module.loadbinary_&quot;</span>;</span><br><span class="line">    std::string fkey = loadkey + type_key;</span><br><span class="line">    <span class="type">const</span> PackedFunc* f = Registry::<span class="built_in">Get</span>(fkey);</span><br><span class="line">    <span class="keyword">return</span> (*f)(<span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(stream));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5" type="1">
<li>重新构建模块关系</li>
</ol>
<p>如果读取的<strong>import_tree_row_ptr</strong>为空，说明动态库中无导入树，可能使用的是老版本的动态库格式。直接使用动态库<strong>lib</strong>构建<strong>LibraryModuleNode</strong>类型对象<strong>n</strong>，然后获取实例对象<strong>n</strong>的<code>imports_</code>成员的地址并赋给<strong>module_import_addr</strong>变量。将从二进制数据流中恢复的所有<strong>modules</strong>都追加到<strong>module_import_addr</strong>中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> n = <span class="built_in">make_object</span>&lt;LibraryModuleNode&gt;(lib);</span><br><span class="line"><span class="keyword">auto</span> module_import_addr = ModuleInternal::<span class="built_in">GetImportsAddr</span>(n.<span class="keyword">operator</span>-&gt;());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; m : modules) &#123;</span><br><span class="line">    module_import_addr-&gt;<span class="built_in">emplace_back</span>(m);</span><br><span class="line">&#125;</span><br><span class="line">*dso_ctx_addr = n.<span class="built_in">get</span>();</span><br><span class="line">*root_module = <span class="built_in">Module</span>(n);</span><br></pre></td></tr></table></figure>
<p>如果存在<strong>import_tree_row_ptr</strong>对象，则按照<strong>CSR</strong>格式恢复模块间的关系。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; modules.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> j = import_tree_row_ptr[i]; j &lt; import_tree_row_ptr[i + <span class="number">1</span>]; ++j) &#123;</span><br><span class="line">        <span class="keyword">auto</span> module_import_addr = ModuleInternal::<span class="built_in">GetImportsAddr</span>(modules[i].<span class="keyword">operator</span>-&gt;());</span><br><span class="line">        <span class="keyword">auto</span> child_index = import_tree_child_indices[j];</span><br><span class="line">        <span class="built_in">ICHECK</span>(child_index &lt; modules.<span class="built_in">size</span>());</span><br><span class="line">        module_import_addr-&gt;<span class="built_in">emplace_back</span>(modules[child_index]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ICHECK</span>(!modules.<span class="built_in">empty</span>()) &lt;&lt; <span class="string">&quot;modules cannot be empty when import tree is present&quot;</span>;</span><br><span class="line"><span class="comment">// invariance: root module is always at location 0.</span></span><br><span class="line"><span class="comment">// The module order is collected via DFS</span></span><br><span class="line">*root_module = modules[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<h6 id="lookup-symbol-from-boot">lookup symbol from boot</h6>
<p>如果动态库中存在<code>__tvm_module_ctx</code>符号，则将该根地址指向<strong>DSO</strong>模块地址<strong>dso_ctx_addr</strong>。从而允许从根模块查找符号，实现所有符号都可见。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// allow lookup of symbol from root (so all symbols are visible).</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span>* ctx_addr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>**&gt;(lib-&gt;<span class="built_in">GetSymbol</span>(runtime::symbol::tvm_module_ctx))) &#123;</span><br><span class="line">    *ctx_addr = dso_ctx_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TVM</category>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>TVM</tag>
        <tag>Runtime</tag>
        <tag>LoadFromFile</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>crazyflie-CRTP协议</title>
    <url>/2020/01/29/crazyflie-CRTP/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>本文主要分析CRTP协议的结构，对该协议结构的理解，有助于后续的数据扩展和对软件架构的理解。为了和Crazyflie通信，<strong>Crazyflie</strong> 飞控中提出一种高层次的协议叫做 <strong>CRTP</strong> (<code>Crazy RealTime Protocol</code>)。这种简单的协议使用一些可以收发数据的双向目标端口，但是大都时候通信由主机发起。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/1kaHc4AvGdPVZ3t.jpg" alt="植物" /><figcaption aria-hidden="true">植物</figcaption>
</figure>
<span id="more"></span>
<h2 id="物理载体">物理载体</h2>
<p>当前CRTP同时支持 Crazyradio 和 USB(只针对Crazyflie 2.0)模式。</p>
<table>
<thead>
<tr class="header">
<th>物理载体</th>
<th>支持的飞控</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Crazyradio (PA)</td>
<td>Crazyflie 1.0/2.0</td>
</tr>
<tr class="even">
<td>USB</td>
<td>Crazyflie 2.0</td>
</tr>
</tbody>
</table>
<h2 id="协议头">协议头</h2>
<p>每个数据包拥有1字节的数据头和31字节有效数据载荷，数据头布局如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   7    6    5    4    3    2    1    0</span><br><span class="line">+----+----+----+----+----+----+----+----+</span><br><span class="line">|       Port        |  Link   |  Chan.  |</span><br><span class="line">+----+----+----+----+----+----+----+----+</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><strong>Port</strong>: 用来区别与消息相关的功能和任务</li>
<li><strong>Link</strong>: 为以后使用预留</li>
<li><strong>Channel</strong>: 用来识别子任务和子功能</li>
</ul>
<h2 id="端口分配">端口分配</h2>
<p>当前端口分配如下：</p>
<table>
<thead>
<tr class="header">
<th>端口</th>
<th>目标</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>Console</td>
<td>读取使用consoleprintf打印到Crazyflie控制台上的控制台信息</td>
</tr>
<tr class="even">
<td>2</td>
<td>Parameters</td>
<td>获取或设置Crazyflie参数.Crazyflie源码中宏定义参数</td>
</tr>
<tr class="odd">
<td>3</td>
<td>Commander</td>
<td>发送控制 滚转/俯仰/偏航/油门调节的设置点</td>
</tr>
<tr class="even">
<td>4</td>
<td>Memory access</td>
<td>访问类似于单线或I2C总线的非易失性存储器 (只支持Crazyflie 2.0)</td>
</tr>
<tr class="odd">
<td>5</td>
<td>Data logging</td>
<td>设置包含需要在特殊周期发回Crazyflie的变量的日记块.</td>
</tr>
<tr class="even">
<td>6</td>
<td>Localization</td>
<td>与定位相关的数据包</td>
</tr>
<tr class="odd">
<td>7</td>
<td>Generic Setpoint</td>
<td>允许发送设置点和控制模式</td>
</tr>
<tr class="even">
<td>13</td>
<td>Platform</td>
<td>用于其它平台控制，例如调试和关机</td>
</tr>
<tr class="odd">
<td>14</td>
<td>Client-side debugging</td>
<td>调试界面并只存在于Crazyflie Python API，Crazyflie飞控本身不具备</td>
</tr>
<tr class="even">
<td>15</td>
<td>Link layer</td>
<td>用于控制和询问通信连接</td>
</tr>
</tbody>
</table>
<h3 id="console端口说明">Console端口说明</h3>
<p>该端口作为一种文本控制台方式，可以使用<strong>consoleprintf</strong> 函数从<em>Crazyflie</em>飞控端到主机端打印文本信息。</p>
<h4 id="通信协议">通信协议</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Answer (Crazyflie to host):</span><br><span class="line">        +---------//-----------+</span><br><span class="line">        | PRINTED CONSOLE TEXT |</span><br><span class="line">        +---------//-----------+</span><br><span class="line">Length          0-31</span><br></pre></td></tr></table></figure>
<p>如果任何如下条件满足，飞行器端的缓存区的内容将被发送：</p>
<ul>
<li>输出缓存区满(31字节)</li>
<li>一个"新行"字符已经被发送(或 </li>
<li>已发出刷新命令</li>
</ul>
<h4 id="代码分析">代码分析</h4>
<p>参考源文件 <strong>console.c</strong>，函数调用关系如下：</p>
<p><img data-src="https://i.loli.net/2021/08/30/co8R6P7NvJUEbd2.png" style="zoom:67%;" /></p>
<h5 id="consoleinit函数说明">consoleInit函数说明</h5>
<p>该函数用于初始化相关变量，并创建二值型信号量<strong>synch</strong>用于任务间，任务和中断间同步。</p>
<h6 id="流程图">流程图</h6>
<figure>
<img data-src="https://i.loli.net/2021/08/30/UpS7EqtLHMgZTb4.png" alt="流程图" /><figcaption aria-hidden="true">流程图</figcaption>
</figure>
<h5 id="consoletest函数说明">consoleTest函数说明</h5>
<p>该函数返回初始化结果，初始化成功即测试通过。</p>
<h5 id="consoleputs函数说明">consolePuts函数说明</h5>
<p>该函数用于发送字符串。</p>
<h6 id="流程图-1">流程图</h6>
<p><img data-src="https://i.loli.net/2021/08/30/zfXnJgUK2LDhoqk.png" /></p>
<p>该函数主要通过调用<strong>consolePutchar</strong>函数，实现字符串的发送。</p>
<h5 id="consoleputchar函数说明">consolePutchar函数说明</h5>
<p>该函数用于发送单字节字符。</p>
<p>参考module/interface/console.h文件,通过utils/src/eprintf.c文件中的<strong>eprintf</strong>函数，将<strong>consolePutchar</strong>函数映射到通用打印函数，使用宏定义<strong>consolePrintf</strong>表示。其中<strong>VA_ARGS</strong>是可变参数宏。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> consolePrintf(FMT, ...) eprintf(consolePutchar, FMT, ## __VA_ARGS__)</span></span><br></pre></td></tr></table></figure>
<p>在utils/interface/debug.h文件中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_PRINT(fmt, ...) consolePrintf(DEBUG_FMT(fmt), ##__VA_ARGS__)</span></span><br></pre></td></tr></table></figure>
<p>使用<strong>DEBUG_PRINT</strong>宏定义映射<strong>consolePrintf</strong>函数，通过无线模块或者USB接口发送，并在控制台显示。</p>
<h6 id="流程图-2">流程图</h6>
<p><img data-src="https://i.loli.net/2021/08/30/8NzcIVtgue7W49x.png" style="zoom: 50%;" /></p>
<h5 id="consoleputcharfromisr函数说明">consolePutcharFromISR函数说明</h5>
<p>该函数用于在中断中运行，进行字符的发送工作。</p>
<h6 id="流程图-3">流程图</h6>
<p><img data-src="https://i.loli.net/2021/08/30/7n8b19MoajglFEZ.png" style="zoom:50%;" /></p>
<h5 id="consolesendmessage函数说明">consoleSendMessage函数说明</h5>
<p>该函数用于将消息缓存区的的数据<strong>messageToPrint</strong>，通过<strong>CRTP</strong>函数发送出去。</p>
<h5 id="addbufferfullmarker">addBufferFullMarker</h5>
<p>该函数用于当发送队列快满时，在队列缓存区最后加上缓存区满的标志(<F>)。</p>
<h5 id="findmarkerstart函数说明">findMarkerStart函数说明</h5>
<p>该函数用于查找标志的起始位置。</p>
<h5 id="consoleflush函数说明">consoleFlush函数说明</h5>
<p>该函数用于发送清空缓存区的内容。</p>
<h3 id="parameters端口说明">Parameters端口说明</h3>
<p>参数系统使得飞行器的所有可获得和可设置参数可访问。飞行器拥有一个可修改得参数表，在这个表中，每个参数都和一个ID和一个组名相关联。三个ID用于访问TOC，参数如下：</p>
<table>
<thead>
<tr class="header">
<th>Port</th>
<th>Channel</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td>0</td>
<td><a href="####TOC访问">TOC 访问</a></td>
</tr>
<tr class="even">
<td>2</td>
<td>1</td>
<td><a href="#parameter-read">参数读取</a></td>
</tr>
<tr class="odd">
<td>2</td>
<td>2</td>
<td><a href="#parameter-write">参数写入</a></td>
</tr>
<tr class="even">
<td>2</td>
<td>3</td>
<td><a href="#misc-commands">其它命令</a></td>
</tr>
</tbody>
</table>
<h4 id="toc访问">TOC访问</h4>
<p>这些信息允许访问参数表的内容。信息的第一个字节是信息ID，信息ID定义如下：</p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>数值</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CMD_GET_ITEM</td>
<td>0</td>
<td>原始版本，获取TOC元素</td>
</tr>
<tr class="even">
<td>CMD_GET_INFO</td>
<td>1</td>
<td>原始版本，获取CRC信息</td>
</tr>
<tr class="odd">
<td>CMD_GET_ITEM_V2</td>
<td>2</td>
<td>V2版本，获取TOC元素</td>
</tr>
<tr class="even">
<td>CMD_GET_INFO_V2</td>
<td>3</td>
<td>V2版本，获取CRC信息</td>
</tr>
</tbody>
</table>
<p>上游数据ID和命令单独发送，下游数据包拥有如下形式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Bytes     1       1          1        空终止字符串</span><br><span class="line">        +---+------------+------+----------+--------------+</span><br><span class="line">        | 0 |  Param ID  | Type |  Group   |     Name     |</span><br><span class="line">        +---+------------+------+---+------+--------------+</span><br><span class="line">        | 1 | Num. Param |  CRC32   |</span><br><span class="line">        +---+------------+----------+</span><br><span class="line">Bytes     1       1           4</span><br></pre></td></tr></table></figure>
<p>参数被PC端有序请求直到最后。当达到最后参数时,ID为0'最后的TOC元素'，复位命令允许复位TOC指针，因此下一个发送TOC元素将会是第一个。“获取 TOC CRC”命令也会返回参数数量。</p>
<p>CRC32是飞行器TOC的哈希值。旨在PC应用程序中实现TOC的缓存以避免每次飞行器连接后获取完整的TOC。</p>
<p><strong>参数类型</strong>用一个字节描述如下：</p>
<table>
<thead>
<tr class="header">
<th>类型码</th>
<th>c语言类型</th>
<th>Python解包</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0x08</td>
<td>uint8_t</td>
<td>'&lt;B '</td>
</tr>
<tr class="even">
<td>0x09</td>
<td>uint16_t</td>
<td>'&lt;H'</td>
</tr>
<tr class="odd">
<td>0x0A</td>
<td>uint32_t</td>
<td>'&lt;L'</td>
</tr>
<tr class="even">
<td>0x0B</td>
<td>uint64_t</td>
<td>'&lt;Q'</td>
</tr>
<tr class="odd">
<td>0x00</td>
<td>int8_t</td>
<td>'&lt;b'</td>
</tr>
<tr class="even">
<td>0x01</td>
<td>int16_t</td>
<td>'&lt;h'</td>
</tr>
<tr class="odd">
<td>0x02</td>
<td>int32_t</td>
<td>'&lt;i'</td>
</tr>
<tr class="even">
<td>0x03</td>
<td>int64_t</td>
<td>'&lt;q'</td>
</tr>
<tr class="odd">
<td>0x05</td>
<td>FP16</td>
<td>''</td>
</tr>
<tr class="even">
<td>0x06</td>
<td>float</td>
<td>'&lt;f'</td>
</tr>
<tr class="odd">
<td>0x07</td>
<td>double</td>
<td>'&lt;d'</td>
</tr>
</tbody>
</table>
<h4 id="参数读取">参数读取</h4>
<p>PC客户端请求内容如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">字节</th>
<th style="text-align: center;">请求字段</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">ID</td>
<td>需要读取参数的ID</td>
</tr>
</tbody>
</table>
<p>Crazyflie飞控端应答内容如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">字节</th>
<th style="text-align: center;">应答字段</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">ID</td>
<td>参数ID值</td>
</tr>
<tr class="even">
<td style="text-align: center;">1- ...</td>
<td style="text-align: center;">数值</td>
<td>参数值。TOC中描述了大小和形式</td>
</tr>
</tbody>
</table>
<p>参数读取请求是在通道1上的一个简单包，Crazyflie飞控应答相应的参数值。</p>
<h4 id="参数写入">参数写入</h4>
<p>PC客户端请求写入内容如下：</p>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>请求字段</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>ID</td>
<td>需要写入的参数ID值</td>
</tr>
<tr class="even">
<td>1- ...</td>
<td>value</td>
<td>写入值，大小和形式在TOC中有描述</td>
</tr>
</tbody>
</table>
<p>Crazyflie飞控端应答内容如下：</p>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>应答字段</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>ID</td>
<td>参数ID</td>
</tr>
<tr class="even">
<td>1- ...</td>
<td>数值</td>
<td>参数值，大小和形式在TOC中有描述</td>
</tr>
</tbody>
</table>
<p>写入请求是一个通道2上的简单包。Crazyflie飞控发回参数值作为应答。</p>
<h4 id="其它命令">其它命令</h4>
<p>如下其它命令被使用：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>命令内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0x00</td>
<td>按名称设置</td>
</tr>
</tbody>
</table>
<h5 id="按名称设置">按名称设置</h5>
<p>请求内容</p>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>请求字段</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>按名称设置</td>
<td>0x00</td>
</tr>
<tr class="even">
<td>1~ n</td>
<td>组</td>
<td>组名</td>
</tr>
<tr class="odd">
<td>n ~ (n+1)</td>
<td>NULL</td>
<td>0</td>
</tr>
<tr class="even">
<td>(n+1) ~ (n+m+1)</td>
<td>名称</td>
<td>参数名称</td>
</tr>
<tr class="odd">
<td>(n+m+1)~(n+m+2)</td>
<td>NULL</td>
<td>0</td>
</tr>
<tr class="even">
<td>(n+m+2)~(n+m+3)</td>
<td>类型</td>
<td>参数类型</td>
</tr>
<tr class="odd">
<td>(n+m+3) ~ ...</td>
<td>数值</td>
<td>参数数值，大小和形式由类型描述</td>
</tr>
</tbody>
</table>
<p>应答内容</p>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>应答字段</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>按名称设置</td>
<td>0x00</td>
</tr>
<tr class="even">
<td>1~ n</td>
<td>组</td>
<td>组名</td>
</tr>
<tr class="odd">
<td>n ~ (n+1)</td>
<td>NULL</td>
<td>0</td>
</tr>
<tr class="even">
<td>(n+1) ~ (n+m+1)</td>
<td>名称</td>
<td>参数名称</td>
</tr>
<tr class="odd">
<td>(n+m+2)</td>
<td>NULL</td>
<td>0</td>
</tr>
<tr class="even">
<td>(n+m+3)</td>
<td>错误</td>
<td>如果参数被成功写入返回0.其它编码</td>
</tr>
</tbody>
</table>
<p>组名和参数名称是ASCII字符串的形式，对应的大小分别为n和m。</p>
<h3 id="commander端口说明">Commander端口说明</h3>
<p>命令端口被用来发送从PC客户端到Crazyflie飞控的控制指令，用来调节滚转、俯仰、偏航和油门等控制信号。随着通信链的建立这些数据包能被发送出去，并且直到下一包数据接收到之前该数值都是有效的。</p>
<h4 id="通信协议-1">通信协议</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">        +-------+-------+-------+-------+</span><br><span class="line">        | ROLL  | PITCH |  YAW  |THRUST |</span><br><span class="line">        +-------+-------+-------+-------+</span><br><span class="line">Length      4       4       4       2      bytes</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th>名称</th>
<th>字节</th>
<th>大小</th>
<th>类型</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>滚转角</td>
<td>0-3</td>
<td>4</td>
<td>float</td>
<td>滚转设置点</td>
</tr>
<tr class="even">
<td>俯仰角</td>
<td>4-7</td>
<td>4</td>
<td>float</td>
<td>俯仰设置点</td>
</tr>
<tr class="odd">
<td>偏航角</td>
<td>8-11</td>
<td>4</td>
<td>float</td>
<td>偏航设置点</td>
</tr>
<tr class="even">
<td>油门</td>
<td>12-13</td>
<td>2</td>
<td>uint16_t</td>
<td>油门设置点</td>
</tr>
</tbody>
</table>
<h3 id="memory-access端口说明">Memory access端口说明</h3>
<p>存储器访问对<span class="exturl" data-url="aHR0cHM6Ly93aWtpLmJpdGNyYXplLmlvL3Byb2plY3RzOmNyYXp5ZmxpZTppbmRleA==">Crazyflie Nano Quadcopter<i class="fa fa-external-link-alt"></i></span>无用，当前只在Crazyflie 2.0中应用。使用存储器访问给出如下可能性：</p>
<ul>
<li><p>获得哪些存储单元可用的信息；</p></li>
<li><p>读取/写入/擦除 存储器；</p></li>
</ul>
<p>当前如下存储器被支持：</p>
<ul>
<li><p>Crazyflie 2.0的板载EEPROM；</p></li>
<li><p>Crazyflie 2.0扩展板上的单线存储器；</p>
<p>有更多的信息关于EEPROM如何构建和单总线存储器如何工作和构建可用。</p></li>
</ul>
<h4 id="逻辑流程图">逻辑流程图</h4>
<p>对于客户端获取信息和读写存储器是可选择的，但是Crazyflie Python 客户端总是在连接状态下载关于存储器的信息。</p>
<p><img data-src="https://i.loli.net/2021/08/30/YCcEy3ufIKjP7gW.png" style="zoom:67%;" /></p>
<h4 id="通信协议-2">通信协议</h4>
<p>存储器端口使用3个不同的通道：</p>
<table>
<thead>
<tr class="header">
<th>端口</th>
<th>通道</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4</td>
<td>0</td>
<td>获取关于存储器数量和类型的信息并同时擦除</td>
</tr>
<tr class="even">
<td>4</td>
<td>1</td>
<td>读取存储器</td>
</tr>
<tr class="odd">
<td>4</td>
<td>2</td>
<td>写入存储器</td>
</tr>
</tbody>
</table>
<h5 id="通道0信息设置">通道0：信息/设置</h5>
<p>这个通道被用来获取存在的存储器数量、关于存储器的信息和大规模擦除内存的可能性。每个包的第一个字节是命令类型：</p>
<table>
<thead>
<tr class="header">
<th>命令内容</th>
<th>命令</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>GET_NBR_OF_MEMS</td>
<td>获取存储器的数量</td>
</tr>
<tr class="even">
<td>2</td>
<td>GET_MEM_INFO</td>
<td>获取关于存储器的信息</td>
</tr>
<tr class="odd">
<td>3</td>
<td>SET_MEM_ERASE</td>
<td>块擦除存储器</td>
</tr>
</tbody>
</table>
<h6 id="get_nbr_of_mems">GET_NBR_OF_MEMS</h6>
<p>这个被用来获取存在的存储器数量。</p>
<ul>
<li>请求从PC主机到Crazyflie飞控：</li>
</ul>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>字段</th>
<th>数值</th>
<th>长度</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>获取存储器数量</td>
<td>0x01</td>
<td>1</td>
<td>命令字节</td>
</tr>
</tbody>
</table>
<ul>
<li>响应从Crazyflie飞控到PC主机：</li>
</ul>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>字段</th>
<th>数值</th>
<th>长度</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>获取存储器数量</td>
<td>0x01</td>
<td>1</td>
<td>命令字节</td>
</tr>
<tr class="even">
<td>1</td>
<td>存储器数量</td>
<td></td>
<td>1</td>
<td>(所有类型)存在存储器数量</td>
</tr>
</tbody>
</table>
<p>例如当Crazyflie飞控上存在三个存储器时：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host-to-Crazyflie: &lt;port/chan&gt; 0x01</span><br><span class="line">Crazyflie-to-Host: &lt;port/chan&gt; 0x01 0x03</span><br></pre></td></tr></table></figure>
<h6 id="get_mem_info">GET_MEM_INFO</h6>
<p>该命令被用来获取存储器的ID信息。存储器的ID是顺序的，并且从0到1，其数值小于从GET_NUMBER_OF_MEMS返回的存储器数量。</p>
<ul>
<li>请求从PC主机到Crazyflie飞控：</li>
</ul>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>字段</th>
<th>数值</th>
<th>长度</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>获取存储器信息</td>
<td>0x02</td>
<td>1</td>
<td>命令字节</td>
</tr>
<tr class="even">
<td>1</td>
<td>存储器ID</td>
<td></td>
<td>1</td>
<td>存储器ID(0 &lt;= id &lt; 存储器数量)</td>
</tr>
</tbody>
</table>
<ul>
<li>如果id<strong>有效</strong>，应答从Crazyflie飞控到PC主机如下：</li>
</ul>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>字段</th>
<th>数值</th>
<th>长度</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>GET_MEM_INFO</td>
<td>0x02</td>
<td>1</td>
<td>命令字节</td>
</tr>
<tr class="even">
<td>1</td>
<td>MEM_ID</td>
<td></td>
<td>1</td>
<td>存储器ID</td>
</tr>
<tr class="odd">
<td>2</td>
<td>MEM_TYPE</td>
<td></td>
<td>1</td>
<td>存储器类型(详见如下)</td>
</tr>
<tr class="even">
<td>3</td>
<td>MEM_SIZE</td>
<td></td>
<td>4</td>
<td>存储器的字节数</td>
</tr>
<tr class="odd">
<td>7</td>
<td>MEM_ADDR</td>
<td></td>
<td>8</td>
<td>存储器地址(只对单总线存储器有效)</td>
</tr>
</tbody>
</table>
<p>关于<strong>MEM_ID</strong>字段如下：</p>
<table>
<thead>
<tr class="header">
<th>ID</th>
<th>数值</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>EEPROM_ID</td>
<td>0x00</td>
<td>关于</td>
</tr>
<tr class="even">
<td>LEDMEM_ID</td>
<td>0x01</td>
<td>LED环存储器ID</td>
</tr>
<tr class="odd">
<td>LOCO_ID</td>
<td>0x02</td>
<td>本地位置节点ID</td>
</tr>
<tr class="even">
<td>TRAJ_ID</td>
<td>0x03</td>
<td>轨迹ID</td>
</tr>
<tr class="odd">
<td>LOCO2_ID</td>
<td>0x04</td>
<td>本地位置节点2的ID</td>
</tr>
<tr class="even">
<td>LH_ID</td>
<td>0x05</td>
<td>灯塔基站的ID</td>
</tr>
<tr class="odd">
<td>TESTER_ID</td>
<td>0x06</td>
<td>存储器测试ID</td>
</tr>
<tr class="even">
<td>USD_ID</td>
<td>0x07</td>
<td><em>待确认</em></td>
</tr>
<tr class="odd">
<td>OW_FIRST_ID</td>
<td>0x08</td>
<td>第一个单总线存储器ID</td>
</tr>
</tbody>
</table>
<p>关于<strong>MEM_TYPE</strong>字段如下：</p>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>数值</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MEM_TYPE_EEPROM</td>
<td>0x00</td>
<td>电可擦除存储器</td>
</tr>
<tr class="even">
<td>MEM_TYPE_OW</td>
<td>0x01</td>
<td>单总线存储器</td>
</tr>
<tr class="odd">
<td>MEM_TYPE_LED12</td>
<td>0x10</td>
<td>LED环</td>
</tr>
<tr class="even">
<td>MEM_TYPE_LOCO</td>
<td>0x11</td>
<td>本地位置节点</td>
</tr>
<tr class="odd">
<td>MEM_TYPE_TRAJ</td>
<td>0x12</td>
<td>轨迹</td>
</tr>
<tr class="even">
<td>MEM_TYPE_LOCO2</td>
<td>0x13</td>
<td>本地位置节点2</td>
</tr>
<tr class="odd">
<td>MEM_TYPE_LH</td>
<td>0x14</td>
<td>灯塔基站</td>
</tr>
<tr class="even">
<td>MEM_TYPE_TESTER</td>
<td>0x15</td>
<td>存储器测试</td>
</tr>
<tr class="odd">
<td>MEM_TYPE_USD</td>
<td>0x16</td>
<td><em>待确认</em></td>
</tr>
</tbody>
</table>
<ul>
<li>如果id<strong>无效</strong>，应答从Crazyflie飞控到PC主机如下：</li>
</ul>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>字段</th>
<th>数值</th>
<th>长度</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>GET_MEM_INFO</td>
<td>0x02</td>
<td>1</td>
<td>字节命令</td>
</tr>
<tr class="even">
<td>1</td>
<td>MEM_ID</td>
<td></td>
<td>1</td>
<td>存储器id</td>
</tr>
</tbody>
</table>
<p>例如对于单总线存储器的请求内容如下：</p>
<p>MEM_ID=1, MEM_SIZE=112bytes, MEM_ADDR=0x1234567890ABCDEF</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host-to-Crazyflie: &lt;port/chan&gt; 0x02 0x01</span><br><span class="line">Crazyflie-to-Host: &lt;port/chan&gt; 0x02 0x01 0x01 0x70 0x00 0x00 0x00 0xEF 0xCD 0xAB 0x90 0x78 0x56 0x34 0x12</span><br></pre></td></tr></table></figure>
<p>例如请求的存储器索引信息无效时：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host-to-Crazyflie: &lt;port/chan&gt; 0x01 0x10</span><br><span class="line">Crazyflie-to-Host: &lt;port/chan&gt; 0x01 0x10</span><br></pre></td></tr></table></figure>
<h6 id="set_mem_erase代码中无描述">SET_MEM_ERASE(代码中无描述)</h6>
<p>该命令被用来块擦除给定的id存储器。存储器的id是顺序的，并且从0到1，其数值小于从GET_NUMBER_OF_MEMS返回的存储器数量。</p>
<ul>
<li>请求从PC主机到Crazyflie飞控：</li>
</ul>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>字段</th>
<th>数值</th>
<th>长度</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>SET_MEM_ERASE</td>
<td>0x03</td>
<td>1</td>
<td>命令字节</td>
</tr>
<tr class="even">
<td>1</td>
<td>MEM_ID</td>
<td></td>
<td>1</td>
<td>存储器ID(0 &lt;= id &lt; 存储器数量)</td>
</tr>
</tbody>
</table>
<ul>
<li>应答从Crazyflie飞控到PC主机：</li>
</ul>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>字段</th>
<th>数值</th>
<th>长度</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>SET_MEM_ERASE</td>
<td>0x03</td>
<td>1</td>
<td>命令字节</td>
</tr>
<tr class="even">
<td>1</td>
<td>MEM_ID</td>
<td></td>
<td>1</td>
<td>存储器id</td>
</tr>
<tr class="odd">
<td>2</td>
<td>STATUS</td>
<td></td>
<td>1</td>
<td>命令状态(详见如下)</td>
</tr>
</tbody>
</table>
<p>例如请求块擦除MEM_ID=2的存储器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host-to-Crazyflie: &lt;port/chan&gt; 0x03 0x02</span><br><span class="line">Crazyflie-to-Host: &lt;port/chan&gt; 0x03 0x02 0x00</span><br></pre></td></tr></table></figure>
<h5 id="通道1存储器读取">通道1：存储器读取</h5>
<p>这个通道只被用来读取存储器，因此信息不包含任何命令字节。</p>
<ul>
<li>请求从PC主机到Crazyflie飞控：</li>
</ul>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>字段</th>
<th>数值</th>
<th>长度</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>MEM_ID</td>
<td></td>
<td>1</td>
<td>存储器id(0 &lt;= id &lt; 存储器数量)</td>
</tr>
<tr class="even">
<td>1</td>
<td>MEM_ADDR</td>
<td></td>
<td>4</td>
<td>要读取的首字节地址</td>
</tr>
<tr class="odd">
<td>5</td>
<td>LEN</td>
<td></td>
<td>1</td>
<td>要被读取的字节数量</td>
</tr>
</tbody>
</table>
<ul>
<li>如果存储器的ID有效且地址和长度读取有效，则应答从Crazyflie飞控到PC主机如下：</li>
</ul>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>字段</th>
<th>数值</th>
<th>长度</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>MEM_ID</td>
<td></td>
<td>1</td>
<td>存储器id(0 &lt;= id &lt; 存储器数量)</td>
</tr>
<tr class="even">
<td>1</td>
<td>MEM_ADDR</td>
<td></td>
<td>4</td>
<td>要读取的首字节地址</td>
</tr>
<tr class="odd">
<td>5</td>
<td>STATUS</td>
<td></td>
<td>1</td>
<td>请求状态(详见如下)</td>
</tr>
<tr class="even">
<td>6</td>
<td>DATA</td>
<td></td>
<td>1 .. 24?</td>
<td>要读取的数据(只有MEM_ID/MEM_ADDR/LEN有效时)</td>
</tr>
</tbody>
</table>
<p>例如从MEM_ID=0x01 MEM_ADDR=0x0A读取LEN=0x0F字节数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host-to-Crazyflie: &lt;port/chan&gt; 0x01 0x0A 0x00 0x00 0x00 0x0F</span><br><span class="line">Crazyflie-to-Host: &lt;port/chan&gt; 0x01 0x0A 0x00 0x00 0x00 0x00 0x01 0x09 0x62 0x63 0x4C 0x65 0x64 0x52 0x69 0x6E 0x67 0x02 0x01 0x62 0x55 </span><br></pre></td></tr></table></figure>
<h5 id="通道2存储器写入">通道2：存储器写入</h5>
<p>该通道只被用来写入存储器，因此消息中不好含任何命令字节。</p>
<ul>
<li>请求从PC主机到Crazyflie飞控：</li>
</ul>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>字段</th>
<th>数值</th>
<th>长度</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>MEM_ID</td>
<td></td>
<td>1</td>
<td>存储器id(0 &lt;= id &lt; 存储器数量)</td>
</tr>
<tr class="even">
<td>1</td>
<td>MEM_ADDR</td>
<td></td>
<td>4</td>
<td>要写入的首字节地址</td>
</tr>
<tr class="odd">
<td>5</td>
<td>DATA</td>
<td></td>
<td>1 .. 24?</td>
<td>要写入的数据</td>
</tr>
</tbody>
</table>
<ul>
<li>如果存储器的ID有效并且地址和长度被写入有效，应答从Crazyflie飞控到PC主机：</li>
</ul>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>字段</th>
<th>数值</th>
<th>长度</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>MEM_ID</td>
<td></td>
<td>1</td>
<td>存储器id(0 &lt;= id &lt; 存储器数量)</td>
</tr>
<tr class="even">
<td>1</td>
<td>MEM_ADDR</td>
<td></td>
<td>4</td>
<td>要写入的首字节地址</td>
</tr>
<tr class="odd">
<td>5</td>
<td>STATUS</td>
<td></td>
<td>1</td>
<td>请求状态</td>
</tr>
</tbody>
</table>
<h3 id="datalog端口说明">DataLog端口说明</h3>
<p>log端口分为三个通道：</p>
<table>
<thead>
<tr class="header">
<th>端口</th>
<th>通道</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>5</td>
<td>0</td>
<td>访问内容表：用于读取出TOC</td>
</tr>
<tr class="even">
<td>5</td>
<td>1</td>
<td>日志控制操作：用于添加/删除/开始/暂停log块</td>
</tr>
<tr class="odd">
<td>5</td>
<td>2</td>
<td>日志数据操作：用于从Crazyflie飞控端到PC客户端发送log数据</td>
</tr>
</tbody>
</table>
<h4 id="访问内容表table-of-content-access">访问内容表(Table of content access)</h4>
<p>这个通道用来下载包含所有可记录变量和变量类型的内容表。每组信息的第一个字节对应于命令，所有这个通道的通信都被客户端初始化，并且所有来自飞行器的应答都包含同样的命令字节。</p>
<table>
<thead>
<tr class="header">
<th>TOC命令字</th>
<th>命令</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>CMD_GET_ITEM</td>
<td>原始版本：从TOC中获取元素</td>
</tr>
<tr class="even">
<td>1</td>
<td>CMD_GET_INFO</td>
<td>原始版本：获取TOC和LOG子系统的信息</td>
</tr>
<tr class="odd">
<td>2</td>
<td>CMD_GET_ITEM_V2</td>
<td>V2版本：从TOC中获取元素</td>
</tr>
<tr class="even">
<td>3</td>
<td>CMD_GET_INFO_V2</td>
<td>V2版本：获取TOC和LOG子系统的信息</td>
</tr>
</tbody>
</table>
<h5 id="get-toc-item">Get TOC item</h5>
<p>CMD_GET_ITEM命令允许从飞行器上检索日志变量名、组名和变量类型。该命令旨在从0到LOG_LEN 的所有ID中被请求。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Request (PC to Copter):</span><br><span class="line">        +--------------+----+</span><br><span class="line">        | GET_ITEM (0) | ID |</span><br><span class="line">        +--------------+----+</span><br><span class="line">Length         1         1</span><br><span class="line"></span><br><span class="line">Answer (Copter to PC):</span><br><span class="line">        +--------------+----+</span><br><span class="line">        | GET_ITEM (0) | ID |                                        If index out of range</span><br><span class="line">        +--------------+----+------+------------+--------------+</span><br><span class="line">        | GET_ITEM (0) | ID | Type |   Group    |     Name     |     If returning Item</span><br><span class="line">        +--------------+----+------+------------+--------------+</span><br><span class="line">Length        1          1     1    &lt; Null terminated strings &gt;</span><br></pre></td></tr></table></figure>
<p>下表说明PC端请求内容如下：</p>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>请求字段</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>GET_ITEM</td>
<td>数值0作为GET_ITEM操作</td>
</tr>
<tr class="even">
<td>1</td>
<td>ID</td>
<td>被检索元素的ID，变量数量从0到LOG_LEN</td>
</tr>
</tbody>
</table>
<p>下表说明Crazyflie飞控端的应答响应内容：</p>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>应答字段</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>GET_ITEM</td>
<td>数值0用于GET_ITEM操作</td>
</tr>
<tr class="even">
<td>1</td>
<td>ID</td>
<td>返回元素的ID</td>
</tr>
<tr class="odd">
<td>2</td>
<td>Type</td>
<td>元素的变量类型，详见变量类型列表</td>
</tr>
<tr class="even">
<td>3-...</td>
<td>Group</td>
<td>包含元素组名可变的空终止字符串</td>
</tr>
<tr class="odd">
<td>...</td>
<td>Name</td>
<td>包含元素变量名可变的空终止字符串</td>
</tr>
</tbody>
</table>
<p>如果请求的<strong>ID</strong>高于(TOC_LEN-1)，则元素类型、元素组名和元素变量名不被发送。</p>
<h5 id="get-info">Get Info</h5>
<p>当连接到飞行器时，首先要请求<strong>Get Info</strong>命令。该操作能够知道变量数量、日志实施的限制和日志变量的指纹。</p>
<p>原始版本的请求和应答流程如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Request (PC to Copter):</span><br><span class="line">        +--------------+</span><br><span class="line">        | GET_INFO (1) |</span><br><span class="line">        +--------------+</span><br><span class="line">Length         1</span><br><span class="line"></span><br><span class="line">Answer (Copter to PC):</span><br><span class="line">        +--------------+---------+---------+-----------------+-------------+</span><br><span class="line">        | GET_INFO (1) | LOG_LEN | LOG_CRC |  LOG_MAX_PACKET | LOG_MAX_OPS |</span><br><span class="line">        +--------------+---------+---------+-----------------+-------------+</span><br><span class="line">Length        1             1         4             1               1</span><br></pre></td></tr></table></figure>
<p>下表详述PC端的请求内容：</p>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>请求字段</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>GET_INFO</td>
<td>数值1用于<strong>GET_INFO</strong>操作</td>
</tr>
</tbody>
</table>
<p>下表详述crazyflie飞控应答内容：</p>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>应答字段</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>GET_INFO</td>
<td>数值1用于GET_INFO操作</td>
</tr>
<tr class="even">
<td>1</td>
<td>LOG_LEN</td>
<td>包含在日志表中的元素的数量</td>
</tr>
<tr class="odd">
<td>2</td>
<td>LOG_CRC</td>
<td>在日志TOC存储区内容数值的CRC值，这是飞行器版本的指纹</td>
</tr>
<tr class="even">
<td>6</td>
<td>LOG_MAX_PACKET</td>
<td>飞行器的最大日志包数量，可以在飞行器中编程</td>
</tr>
<tr class="odd">
<td>7</td>
<td>LOG_MAX_OPS</td>
<td>飞行器中的可编程操作的最大数量，该操作是一种日志变量检索程序</td>
</tr>
</tbody>
</table>
<h4 id="log-control">Log control</h4>
<p>日志控制通道允许安装、激活、失效和移除日志包。就像访问TOC通道第一个字节代表的命令，日志控制同样有如下命令：</p>
<table>
<thead>
<tr class="header">
<th>控制命令字节</th>
<th>命令</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>CREATE_BLOCK</td>
<td>创建一个新的日志块</td>
</tr>
<tr class="even">
<td>1</td>
<td>APPEND_BLOCK</td>
<td>在存在的日志块上追加变量</td>
</tr>
<tr class="odd">
<td>2</td>
<td>DELETE_BLOCK</td>
<td>删除一个日志块</td>
</tr>
<tr class="even">
<td>3</td>
<td>START_BLOCK</td>
<td>启用日志块传输</td>
</tr>
<tr class="odd">
<td>4</td>
<td>STOP_BLOCK</td>
<td>停止日志块传输</td>
</tr>
<tr class="even">
<td>5</td>
<td>RESET</td>
<td>删除所有的日志块</td>
</tr>
<tr class="odd">
<td>6</td>
<td>CREATE_BLOCK_V2</td>
<td>V2版本:创建一个新的日志块</td>
</tr>
<tr class="even">
<td>7</td>
<td>APPEND_BLOCK_V2</td>
<td>V2版本:在存在的日志块上追加变量</td>
</tr>
</tbody>
</table>
<h5 id="create-block">Create block</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Request (PC to Copter):</span><br><span class="line">  &lt; 更多设置参数按如下结构扩展      &gt;</span><br><span class="line">        +------------------+--------------+--------------+-------------+</span><br><span class="line">        | CREATE_BLOCK (0) | LOG_BLOCK_ID | SET_LOG_TYPE |  SET_LOG_ID |</span><br><span class="line">        +------------------+--------------+--------------+-------------+</span><br><span class="line">Length         1  1  1  1</span><br><span class="line"></span><br><span class="line">Answer (Copter to PC):</span><br><span class="line">        +------------------+--------------+------------+</span><br><span class="line">        | CREATE_BLOCK (0) | LOG_BLOCK_ID | CREATE_STS |</span><br><span class="line">        +------------------+--------------+------------+</span><br><span class="line">Length            1               1               1</span><br></pre></td></tr></table></figure>
<p>返回状态参考<strong>&lt;errno.h&gt;</strong>文件内容。</p>
<h5 id="append-variable-to-block">Append variable to block</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Request (PC to Copter):</span><br><span class="line">  &lt; 更多设置参数按如下结构扩展      &gt;</span><br><span class="line">        +------------------+--------------+--------------+-------------+</span><br><span class="line">        | APPEND_BLOCK (1) | LOG_BLOCK_ID | SET_LOG_TYPE |  SET_LOG_ID |</span><br><span class="line">        +------------------+--------------+--------------+-------------+</span><br><span class="line">Length         1  1  1  1</span><br><span class="line"></span><br><span class="line">Answer (Copter to PC):</span><br><span class="line">        +------------------+--------------+------------+</span><br><span class="line">        | APPEND_BLOCK (1) | LOG_BLOCK_ID | CREATE_STS |</span><br><span class="line">        +------------------+--------------+------------+</span><br><span class="line">Length            1               1               1</span><br></pre></td></tr></table></figure>
<p>返回状态参考<strong>&lt;errno.h&gt;</strong>文件内容。</p>
<h5 id="delelte-block">Delelte block</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Request (PC to Copter):</span><br><span class="line">        +------------------+--------------+</span><br><span class="line">        | DELETE_BLOCK (2) | LOG_BLOCK_ID |</span><br><span class="line">        +------------------+--------------+</span><br><span class="line">Length         1  1  </span><br><span class="line"></span><br><span class="line">Answer (Copter to PC):</span><br><span class="line">        +------------------+--------------+------------+</span><br><span class="line">        | DELETE_BLOCK (2) | LOG_BLOCK_ID | CREATE_STS |</span><br><span class="line">        +------------------+--------------+------------+</span><br><span class="line">Length            1               1               1</span><br></pre></td></tr></table></figure>
<p>通过请求的LOG_BLOCK_ID，查找相关节点，并删除链表中的该节点。</p>
<h5 id="start-block">Start block</h5>
<p>通过启动相应的定时器实现日志的发送，并设置相应的周期时间。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Request (PC to Copter):</span><br><span class="line">        +-----------------+--------------+------------+</span><br><span class="line">        | START_BLOCK (3) | LOG_BLOCK_ID | LOG_PERIOD |</span><br><span class="line">        +-----------------+--------------+------------+</span><br><span class="line">Length         1  1  1</span><br><span class="line"></span><br><span class="line">Answer (Copter to PC):</span><br><span class="line">        +-----------------+--------------+------------+</span><br><span class="line">        | START_BLOCK (3) | LOG_BLOCK_ID | CREATE_STS |</span><br><span class="line">        +-----------------+--------------+------------+</span><br><span class="line">Length            1               1               1</span><br></pre></td></tr></table></figure>
<h5 id="stop-block">Stop block</h5>
<p>通过停止相应的定时器来停止日志数据的发送。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Request (PC to Copter):</span><br><span class="line">        +----------------+--------------+</span><br><span class="line">        | STOP_BLOCK (4) | LOG_BLOCK_ID |</span><br><span class="line">        +----------------+--------------+</span><br><span class="line">Length         1  1  </span><br><span class="line"></span><br><span class="line">Answer (Copter to PC):</span><br><span class="line">        +----------------+--------------+------------+</span><br><span class="line">        | STOP_BLOCK (4) | LOG_BLOCK_ID | CREATE_STS |</span><br><span class="line">        +----------------+--------------+------------+</span><br><span class="line">Length          1               1               1</span><br></pre></td></tr></table></figure>
<h5 id="reset">Reset</h5>
<p>停止所有日志块的发送、删除所有日志块的内容，释放所有日志块的空间。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Request (PC to Copter):</span><br><span class="line">        +-----------+</span><br><span class="line">        | RESET (5) |</span><br><span class="line">        +-----------+</span><br><span class="line">Length       1</span><br><span class="line"></span><br><span class="line">Answer (Copter to PC):</span><br><span class="line">        +-----------+--------------+------------+</span><br><span class="line">        | RESET (5) | LOG_BLOCK_ID | CREATE_STS |</span><br><span class="line">        +-----------+--------------+------------+</span><br><span class="line">Length        1             1             1</span><br></pre></td></tr></table></figure>
<h5 id="create-block-v2">CREATE BLOCK V2</h5>
<p>V2版本的日志块创建。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Request (PC to Copter):</span><br><span class="line">  &lt; 更多设置参数按如下结构扩展      &gt;</span><br><span class="line">        +---------------------+--------------+--------------+-------------+</span><br><span class="line">        | CREATE_BLOCK_V2 (6) | LOG_BLOCK_ID | SET_LOG_TYPE |  SET_LOG_ID |</span><br><span class="line">        +---------------------+--------------+--------------+-------------+</span><br><span class="line">Length         1  1  1  2</span><br><span class="line"></span><br><span class="line">Answer (Copter to PC):</span><br><span class="line">        +---------------------+--------------+------------+</span><br><span class="line">        | CREATE_BLOCK_V2 (6) | LOG_BLOCK_ID | CREATE_STS |</span><br><span class="line">        +---------------------+--------------+------------+</span><br><span class="line">Length            1               1               1</span><br></pre></td></tr></table></figure>
<h5 id="append-block-v2">APPEND BLOCK V2</h5>
<p>V2版本的追加日志内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Request (PC to Copter):</span><br><span class="line">  &lt; 更多设置参数按如下结构扩展      &gt;</span><br><span class="line">        +---------------------+--------------+--------------+-------------+</span><br><span class="line">        | APPEND_BLOCK_V2 (7) | LOG_BLOCK_ID | SET_LOG_TYPE |  SET_LOG_ID |</span><br><span class="line">        +---------------------+--------------+--------------+-------------+</span><br><span class="line">Length         1  1  1  2</span><br><span class="line"></span><br><span class="line">Answer (Copter to PC):</span><br><span class="line">        +---------------------+--------------+------------+</span><br><span class="line">        | APPEND_BLOCK_V2 (7) | LOG_BLOCK_ID | CREATE_STS |</span><br><span class="line">        +---------------------+--------------+------------+</span><br><span class="line">Length            1               1               1</span><br></pre></td></tr></table></figure>
<h4 id="log-data">Log data</h4>
<p>日志数据通道用于飞行器在可编程速率下发送日志块数据。</p>
<p>详细的请求内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Answer (Copter to PC):</span><br><span class="line">        +----------+------------+---------//----------+</span><br><span class="line">        | BLOCK_ID | TIME_STAMP | LOG VARIABLE VALUES |</span><br><span class="line">        +----------+------------+---------//----------+</span><br><span class="line">Length        1          3           0 to 28</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>应答字段</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>BLOCK_ID</td>
<td>日志块的ID</td>
</tr>
<tr class="even">
<td>1</td>
<td>TIME_STAMP</td>
<td>时标以ms形式，从飞行器启动起算起，并以3字节的小端整形表示</td>
</tr>
<tr class="odd">
<td>4-...</td>
<td>Log variable values</td>
<td>日志包的数据值以小端形式表述</td>
</tr>
</tbody>
</table>
<h3 id="localization端口说明">Localization端口说明</h3>
<p>该端口组有一系列定位相关的数据包，主要如下几个通道：</p>
<table>
<thead>
<tr class="header">
<th>端口</th>
<th>通道</th>
<th>命名</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>6</td>
<td>0</td>
<td>External Position</td>
<td>外部位置</td>
</tr>
<tr class="even">
<td>6</td>
<td>1</td>
<td>Generic localization</td>
<td>通用定位</td>
</tr>
<tr class="odd">
<td>6</td>
<td>2</td>
<td>External Position Packet</td>
<td>外部位置数据包</td>
</tr>
</tbody>
</table>
<h4 id="external-position">External Position</h4>
<p>该数据包被用来发送由外部系统获取的Crazyflie位置信息。主要用该数据包发送由运动捕获系统获取的位置信息，并通过扩展卡尔曼滤波，允许Crazyflie计算位置估计并控制其状态。</p>
<p>数据包形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CrtpExtPosition</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">float</span> x; <span class="comment">// in m</span></span><br><span class="line">  <span class="type">float</span> y; <span class="comment">// in m</span></span><br><span class="line">  <span class="type">float</span> z; <span class="comment">// in m</span></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<h4 id="generic-localization">Generic Localization</h4>
<p>该通道用于定位子系统有用的主机数据包，该数据包被创建用来服务于自身位置系统数据包，但可以被用作对更多通用系统像GPS NMEA编码或二进制数据流。数据包格式如下：</p>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>数值</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>PACKET_TYPE</td>
<td></td>
</tr>
<tr class="even">
<td>1-...</td>
<td>Payload</td>
<td>数据包的有效载荷，数据形式由包类型确定</td>
</tr>
</tbody>
</table>
<p>关于<strong>PACKET_TYPE</strong>定义：</p>
<table>
<thead>
<tr class="header">
<th>包类型</th>
<th>数值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>RANGE_STREAM_FLOAT</td>
<td>0</td>
<td>待确认</td>
</tr>
<tr class="even">
<td>RANGE_STREAM_FP16</td>
<td>1</td>
<td>待确认</td>
</tr>
<tr class="odd">
<td>LPS_SHORT_LPP_PACKET</td>
<td>2</td>
<td>LPS 发送 LPP数据包</td>
</tr>
<tr class="even">
<td>EMERGENCY_STOP</td>
<td>3</td>
<td>紧急停止</td>
</tr>
<tr class="odd">
<td>EMERGENCY_STOP_WATCHDOG</td>
<td>4</td>
<td>接收超时触发紧急停止</td>
</tr>
<tr class="even">
<td>COMM_GNSS_NMEA</td>
<td>6</td>
<td>待确认</td>
</tr>
<tr class="odd">
<td>COMM_GNSS_PROPRIETARY</td>
<td>7</td>
<td>待确认</td>
</tr>
<tr class="even">
<td>EXT_POSE</td>
<td>8</td>
<td>外部位置信息包</td>
</tr>
<tr class="odd">
<td>EXT_POSE_PACKED</td>
<td>9</td>
<td>外部位置信息压缩包</td>
</tr>
</tbody>
</table>
<blockquote>
<p>LPS:Loco Positioning System</p>
<p>LPP:Loco Positioning Protocol</p>
</blockquote>
<h5 id="lpp-short-packet-tunnel">LPP Short packet tunnel</h5>
<p>该数据用于发送LPP短包到本地位置系统，有效数据以<span class="exturl" data-url="aHR0cHM6Ly93d3cuYml0Y3JhemUuaW8vZG9jcy9scHMtbm9kZS1maXJtd2FyZS9tYXN0ZXIvbHBwLw==">LPP Short Packet<i class="fa fa-external-link-alt"></i></span>的形式发送给系统。</p>
<h5 id="emergency-stop">Emergency stop</h5>
<p>当收到时，稳定循环系统被设置到紧急停止模式，该模式下停止所有电机。直到飞控状态复位，否则稳定循环模式一直保持在紧急停止状态。</p>
<h5 id="emergency_stop_watchdog">EMERGENCY_STOP_WATCHDOG</h5>
<p>飞控启动时<strong>超时紧急停止</strong>处于失效状态，当第一个数据包接收开始，超时1s就会使能<strong>超时紧急停止</strong>。该数据包至少每秒被<strong>Crazyflie</strong>发送和接收一次，否则稳定循环系统就会被设置进入紧急停止状态且所有电机停转。</p>
<h5 id="ext_pose">EXT_POSE</h5>
<p>外部系统的位置信息，详细结构如下：</p>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>字段</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>EXT_POSE</td>
<td>byte</td>
<td>外部位置 信息包</td>
</tr>
<tr class="even">
<td>1 - 4</td>
<td>x</td>
<td>float</td>
<td>x轴坐标信息</td>
</tr>
<tr class="odd">
<td>5 - 8</td>
<td>y</td>
<td>float</td>
<td>y轴坐标信息</td>
</tr>
<tr class="even">
<td>9 - 12</td>
<td>z</td>
<td>float</td>
<td>z轴坐标信息</td>
</tr>
<tr class="odd">
<td>13 - 16</td>
<td>qx</td>
<td>float</td>
<td>四元素姿态信息：方位信息的x轴分量</td>
</tr>
<tr class="even">
<td>17 - 20</td>
<td>qy</td>
<td>float</td>
<td>四元素姿态信息：方位信息的y轴分量</td>
</tr>
<tr class="odd">
<td>21 - 24</td>
<td>qz</td>
<td>float</td>
<td>四元素姿态信息：方位信息的z轴分量</td>
</tr>
<tr class="even">
<td>25 - 28</td>
<td>qw</td>
<td>float</td>
<td>四元素姿态信息：矢量大小系数</td>
</tr>
</tbody>
</table>
<h5 id="ext_pose_packed">EXT_POSE_PACKED</h5>
<p>外部位置系统的数据通过该数据包形式进行压缩发送，节省通道带宽，详细包形式如下：</p>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>字段</th>
<th>类型</th>
<th>系数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>EXT_POSE_PACKED</td>
<td>byte</td>
<td></td>
<td>外部位置信息压缩包</td>
</tr>
<tr class="even">
<td>1</td>
<td>id</td>
<td>uint8</td>
<td></td>
<td>Crazyflie飞控地址的最后8bit</td>
</tr>
<tr class="odd">
<td>2 - 3</td>
<td>x</td>
<td>int16</td>
<td>0.001</td>
<td>x轴坐标信息</td>
</tr>
<tr class="even">
<td>4 - 5</td>
<td>y</td>
<td>int16</td>
<td>0.001</td>
<td>y轴坐标信息</td>
</tr>
<tr class="odd">
<td>6 - 7</td>
<td>z</td>
<td>int16</td>
<td>0.001</td>
<td>z轴坐标信息</td>
</tr>
<tr class="even">
<td>8 - 11</td>
<td>quaternion</td>
<td>uint32_t</td>
<td></td>
<td>压缩格式的四元素(压缩算法详见<strong>quatcompress.h</strong>)</td>
</tr>
<tr class="odd">
<td>...</td>
<td></td>
<td></td>
<td></td>
<td>另一同样包形式的元素</td>
</tr>
</tbody>
</table>
<p>每个CRTP数据包可以达到两个外部位置信息元素。</p>
<h3 id="generic-setpoint端口说明">Generic Setpoint端口说明</h3>
<p>该端口允许发送设定点到飞行器平台。其理念在于能够为每个不同的用例定义设定点数据的包格式。因此这是一个拥有一个通道和一个主要包形式的通用端口。</p>
<table>
<thead>
<tr class="header">
<th>端口</th>
<th>通道</th>
<th>命名</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>7</td>
<td>0</td>
<td>通用设定点</td>
</tr>
</tbody>
</table>
<p>通用设定点包的形式如下：</p>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>数值</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>ID</td>
<td>设定点数据包类型的ID值</td>
</tr>
<tr class="even">
<td>1 - ...</td>
<td>Payload</td>
<td>数据形式由数据包类型确定</td>
</tr>
</tbody>
</table>
<p>详细的包类型如下：</p>
<table>
<thead>
<tr class="header">
<th>ID</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td><a href="#stop">stop</a></td>
</tr>
<tr class="even">
<td>1</td>
<td><a href="#velocity-world">Velocity World</a></td>
</tr>
<tr class="odd">
<td>2</td>
<td><a href="#z-distance">Z Distance</a></td>
</tr>
<tr class="even">
<td>3</td>
<td><a href="#cppm-emulation">CPPM Emulation</a></td>
</tr>
<tr class="odd">
<td>4</td>
<td><a href="#altitude-hold">Altitude Hold</a></td>
</tr>
<tr class="even">
<td>5</td>
<td><a href="#hover">Hover</a></td>
</tr>
<tr class="odd">
<td>6</td>
<td><a href="#full-state">Full State</a></td>
</tr>
<tr class="even">
<td>7</td>
<td><a href="#position">Position</a></td>
</tr>
</tbody>
</table>
<h4 id="stop">Stop</h4>
<p>这个设定点无有效负载，用于停止电机和失效控制循环。需要在Crazyflie飞控着陆的情况下发送。</p>
<h4 id="velocity-world">Velocity World</h4>
<p>世界坐标系中的速度设定点伴随着偏航角速度。适用于在本地位置系统的遥控模式。</p>
<p>有效载荷数据的形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">velocityPacket_s</span> &#123;</span></span><br><span class="line">  <span class="type">float</span> vx;        <span class="comment">// m in the world frame of reference</span></span><br><span class="line">  <span class="type">float</span> vy;        <span class="comment">// ...</span></span><br><span class="line">  <span class="type">float</span> vz;        <span class="comment">// ...</span></span><br><span class="line">  <span class="type">float</span> yawrate;  <span class="comment">// deg/s</span></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<h4 id="z-distance">Z Distance</h4>
<p>设置Crazyflie飞控绝对高度和俯仰/滚转角度，数据有效载荷形似如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zDistancePacket_s</span> &#123;</span></span><br><span class="line">  <span class="type">float</span> roll;            <span class="comment">// deg</span></span><br><span class="line">  <span class="type">float</span> pitch;           <span class="comment">// ...</span></span><br><span class="line">  <span class="type">float</span> yawrate;         <span class="comment">// deg/s</span></span><br><span class="line">  <span class="type">float</span> zDistance;        <span class="comment">// m in the world frame of reference</span></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<h4 id="cppm-emulation">CPPM Emulation</h4>
<p>CRTP数据包拥有一个<strong>CPPM</strong>(<code>Crazyflie Pulse Position Modulation</code>)仿真通道，该通道数据范围1000-2000，其中间值为1500，支持原始的<strong>RPYT</strong>(<code>Roll Pitch Yaw Thrust</code>)通道，再加上高达<strong>MAX_AUX_RC_CHANNELS</strong> 数量的辅组通道。辅组通道是可选的，并且除非给定通道被实际使用，发射器没必要传输所有的数据(<strong>numAuxChannels</strong>是设定依据)。</p>
<p>有效数据载荷形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_AUX_RC_CHANNELS 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> s_CppmEmuRollMaxRateDps = <span class="number">720.0f</span>; <span class="comment">// For rate mode</span></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> s_CppmEmuPitchMaxRateDps = <span class="number">720.0f</span>; <span class="comment">// For rate mode</span></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> s_CppmEmuRollMaxAngleDeg = <span class="number">50.0f</span>; <span class="comment">// For level mode</span></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> s_CppmEmuPitchMaxAngleDeg = <span class="number">50.0f</span>; <span class="comment">// For level mode</span></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> s_CppmEmuYawMaxRateDps = <span class="number">400.0f</span>; <span class="comment">// Used regardless of flight mode</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cppmEmuPacket_s</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="type">uint8_t</span> numAuxChannels : <span class="number">4</span>;   <span class="comment">// Set to 0 through MAX_AUX_RC_CHANNELS</span></span><br><span class="line">      <span class="type">uint8_t</span> reserved : <span class="number">4</span>;</span><br><span class="line">  &#125; hdr;</span><br><span class="line">  <span class="type">uint16_t</span> channelRoll;</span><br><span class="line">  <span class="type">uint16_t</span> channelPitch;</span><br><span class="line">  <span class="type">uint16_t</span> channelYaw;</span><br><span class="line">  <span class="type">uint16_t</span> channelThrust;</span><br><span class="line">  <span class="type">uint16_t</span> channelAux[MAX_AUX_RC_CHANNELS];</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<h4 id="altitude-hold">Altitude Hold</h4>
<p>设置Crazyflie飞控的垂直速度和滚转/俯仰角度。</p>
<p>数据有效载荷形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">altHoldPacket_s</span> &#123;</span></span><br><span class="line">  <span class="type">float</span> roll;            <span class="comment">// rad</span></span><br><span class="line">  <span class="type">float</span> pitch;           <span class="comment">// ...</span></span><br><span class="line">  <span class="type">float</span> yawrate;         <span class="comment">// deg/s</span></span><br><span class="line">  <span class="type">float</span> zVelocity;       <span class="comment">// m/s in the world frame of reference</span></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<h4 id="hover">Hover</h4>
<p>设置Crazyflie飞控绝对高度和在刚体坐标系下的速度。</p>
<p>数据有效载荷形似如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hoverPacket_s</span> &#123;</span></span><br><span class="line">  <span class="type">float</span> vx;           <span class="comment">// m/s in the body frame of reference</span></span><br><span class="line">  <span class="type">float</span> vy;           <span class="comment">// ...</span></span><br><span class="line">  <span class="type">float</span> yawrate;      <span class="comment">// deg/s</span></span><br><span class="line">  <span class="type">float</span> zDistance;    <span class="comment">// m in the world frame of reference</span></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<h4 id="full-state">Full State</h4>
<p>设置所有的控制状态。其数据有效载荷形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fullStatePacket_s</span> &#123;</span></span><br><span class="line">  <span class="type">int16_t</span> x;         <span class="comment">// position - mm</span></span><br><span class="line">  <span class="type">int16_t</span> y;</span><br><span class="line">  <span class="type">int16_t</span> z;</span><br><span class="line">  <span class="type">int16_t</span> vx;        <span class="comment">// velocity - mm / sec</span></span><br><span class="line">  <span class="type">int16_t</span> vy;</span><br><span class="line">  <span class="type">int16_t</span> vz;</span><br><span class="line">  <span class="type">int16_t</span> ax;        <span class="comment">// acceleration - mm / sec^2</span></span><br><span class="line">  <span class="type">int16_t</span> ay;</span><br><span class="line">  <span class="type">int16_t</span> az;</span><br><span class="line">  <span class="type">int32_t</span> quat;      <span class="comment">// compressed quaternion, see quatcompress.h</span></span><br><span class="line">  <span class="type">int16_t</span> rateRoll;  <span class="comment">// angular velocity - milliradians / sec</span></span><br><span class="line">  <span class="type">int16_t</span> ratePitch; <span class="comment">//  (<span class="doctag">NOTE:</span> limits to about 5 full circles per sec.</span></span><br><span class="line">  <span class="type">int16_t</span> rateYaw;   <span class="comment">//   may not be enough for extremely aggressive flight.)</span></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<h4 id="position">Position</h4>
<p>设置绝对位置和方向，其数据有效载荷形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">positionPacket_s</span> &#123;</span></span><br><span class="line">  <span class="type">float</span> x;     <span class="comment">// Position in m</span></span><br><span class="line">  <span class="type">float</span> y;</span><br><span class="line">  <span class="type">float</span> z;</span><br><span class="line">  <span class="type">float</span> yaw;   <span class="comment">// Orientation in degree</span></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<h2 id="连接步骤">连接步骤</h2>
<p><strong>CRTP</strong>被设计为无状态模式，所以不需要握手过程。任何命令可以在任何时候被发送，但是对于一些日记/参数/存储 命令，为了主机客户端能够发送正确的信息，内容表(<strong>TOC</strong>)需要被下载。为了能够使用所有的功能，在连接的情况下，执行Python API 将会下载 参数/日记/存储 TOC 。</p>
]]></content>
      <categories>
        <category>crazyflie</category>
        <category>CRTP协议</category>
      </categories>
      <tags>
        <tag>CRTP</tag>
        <tag>Crazy RealTime Protocol</tag>
      </tags>
  </entry>
  <entry>
    <title>crazyflie-开发说明</title>
    <url>/2020/01/22/crazyflie-develop/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>嵌入式软件开发主要包括编译(build)、调试(debug)和烧录(flash)三个步骤。本文结合crazefie项目，说明开发流程。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/hpJQSXx9corO15W.jpg" alt="上海科技馆-静物" /><figcaption aria-hidden="true">上海科技馆-静物</figcaption>
</figure>
<span id="more"></span>
<h2 id="准备源码">准备源码</h2>
<p>由于官方仓库中使用了<code>git submodule</code>，所以在克隆源码时需使用<code>--recursive</code>标志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recursive https://github.com/bitcraze/crazyflie-firmware.git</span><br></pre></td></tr></table></figure>
<p>如果已经克隆了仓库，但是没有添加<code>--recursive</code>选项，需要手动添加子模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> crazyflie-firmware</span><br><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br></pre></td></tr></table></figure>
<p>具体更新哪些子项目模块可以查看<code>.gitmodules</code>文件。</p>
<blockquote>
<p>注意： - 问题：如果编译时出现如下错误：<code>make[1]: *** No rule to make target 'libdw1000.o', needed by 'cf2.elf'.  Stop. Makefile:350: recipe for target 'build' failed</code> - 解决办法：上述错误原因是因为缺少<code>libdw1000</code>文件，输入<code>git submodule deinit</code>，并删除<code>libdw1000</code>目录里面的<code>.git</code>文件，重新拉取该项目源码。</p>
</blockquote>
<h2 id="环境搭建">环境搭建</h2>
<p>官方提供三种环境搭建方式，分别使用虚拟机镜像<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JpdGNyYXplL2JpdGNyYXplLXZt">Crazyflie VM<i class="fa fa-external-link-alt"></i></span>、Docker镜像<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JpdGNyYXplL3Rvb2xiZWx0">toolbelt<i class="fa fa-external-link-alt"></i></span>和本机安装相应的ARM工具链来搭建开发环境。</p>
<h3 id="虚拟机镜像">虚拟机镜像</h3>
<p>本文采用 VirtualBox 虚拟机软件，该软件属于自由软件，方便安装。</p>
<h4 id="virtualbox">VirtualBox</h4>
<ul>
<li>下载<span class="exturl" data-url="aHR0cHM6Ly93d3cudmlydHVhbGJveC5vcmcvd2lraS9Eb3dubG9hZHM=">VirtualBox<i class="fa fa-external-link-alt"></i></span></li>
<li>安装软件</li>
</ul>
<h4 id="下载bitcraze镜像">下载bitcraze镜像</h4>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmJpdGNyYXplLmlvL3Byb2plY3RzOnZpcnR1YWxtYWNoaW5lOmluZGV4">Bitcraze Virtual Machine Image<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h4 id="导入镜像">导入镜像</h4>
<figure>
<img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3pnaDU1MS9GaWd1cmVCZWQvbWFzdGVyL2ltZy8yMDIwMDExNzE1NTQyNC5wbmc?x-oss-process=image/format,png" alt="镜像导入过程" /><figcaption aria-hidden="true">镜像导入过程</figcaption>
</figure>
<h4 id="启动镜像">启动镜像</h4>
<figure>
<img data-src="https://i.loli.net/2021/08/30/BxSWetJvMy7R1uG.png" alt="启动镜像" /><figcaption aria-hidden="true">启动镜像</figcaption>
</figure>
<blockquote>
<p>注意：运行镜像时可能会出现如下问题 错误1：<code>Implementation of the USB 2.0 controller not found!</code> 安装<span class="exturl" data-url="aHR0cHM6Ly93d3cudmlydHVhbGJveC5vcmcvd2lraS9Eb3dubG9hZHM=">VirtualBox Extension Pack<i class="fa fa-external-link-alt"></i></span>即可解决 错误2：<code>VT-x is not available</code> 对于Win10电脑如果已经开启了Hyper-V，需将其服务关闭； 1、控制面板 --&gt; 程序和功能 --&gt; 启用或关闭windows功能 2、失效 <strong>H-yper-v</strong>、<strong>Windows 沙盒(Sandbox)</strong> 选项，使能 <strong>虚拟机平台</strong>、<strong>Windows虚拟机监控程序平台</strong>选项。 3、管理员打开 PowerShell客户端 4、输入<code>bcdedit /set hypervisorlaunchtype off</code> 5、重启电脑</p>
</blockquote>
<h3 id="docker镜像方式">Docker镜像方式</h3>
<h4 id="安装docker">安装Docker</h4>
<ol type="1">
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZG9ja2VyLWZvci13aW5kb3dzL2luc3RhbGwv">Docker Hub下载<i class="fa fa-external-link-alt"></i></span></li>
<li>双击安装文件，一直Next。</li>
<li>注册Docker账号</li>
</ol>
<h4 id="下载docker镜像">下载Docker镜像</h4>
<ul>
<li>关于<span class="exturl" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9yL2JpdGNyYXplL2J1aWxkZXI=">bitcraze/builder镜像<i class="fa fa-external-link-alt"></i></span></li>
<li>打开PowerShell客户端</li>
<li>拉取远程镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull bitcraze/builder</span><br></pre></td></tr></table></figure>
<p>下载过程如下所示，由于文件较大可能需要一段时间。</p>
<figure>
<img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3pnaDU1MS9GaWd1cmVCZWQvbWFzdGVyL2ltZy8yMDIwMDExNzE2NTYzMC5naWY" alt="镜像拉取" /><figcaption aria-hidden="true">镜像拉取</figcaption>
</figure>
<h4 id="进入交互模式">进入交互模式</h4>
<ul>
<li>查看镜像是否下载成功</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<ul>
<li>进入项目目录</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ./crazyflie-firmware</span><br></pre></td></tr></table></figure>
<ul>
<li>进入交互式环境</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> -it -v <span class="variable">$&#123;PWD&#125;</span>:/module bitcraze/builder bash</span><br></pre></td></tr></table></figure>
<p>该命令用法参考<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnaGZvcmV2ZXIvYXJ0aWNsZS9kZXRhaWxzLzEwMDA4NzQzNw==">Docker 常用命令<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="本地工具链配置">本地工具链配置</h3>
<p>待补充</p>
<h2 id="编译">编译</h2>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">命令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>all</strong></td>
<td>快捷编译方式，所有文件都编译</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>compile</strong></td>
<td>编译生成 cflie.hex文件，但不更新version.c文件</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>build</strong></td>
<td>更新 version.c 文件并编译生成 cflie.elf/hex文件</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>clean_o</strong></td>
<td>只清除目标文件，保留执行文件(.elf,.hex)</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>clean</strong></td>
<td>清除所有的编译文件</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>mrproper</strong></td>
<td>清除每一个编译文件和典型的编辑器备份文件</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>cload</strong></td>
<td>如果crazyflie-clients-python与项目文件在同级目录并且Crazyradio/Crazyradio PA被插入电脑，该命令将会尝试通过无线bootloader烧写固件</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>flash</strong></td>
<td>使用 OpenOCD烧录.elf 文件</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>halt</strong></td>
<td>使用 OpenOCD 暂停目标芯片</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>reset</strong></td>
<td>使用 OpenOCD 复位目标芯片</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>openocd</strong></td>
<td>启动 OpenOCD</td>
</tr>
</tbody>
</table>
<h2 id="调试">调试</h2>
<p>关于芯片功能的调试，使用开源工具OpenOCD。</p>
<h3 id="ubuntu">Ubuntu</h3>
<blockquote>
<p><strong><em>Versions:</em></strong></p>
<ul>
<li>Ubuntu 18.04.2 LTS (64 bit)</li>
<li>Eclipse 2019-03 (Eclipse IDE for C/C++ Developers)</li>
</ul>
</blockquote>
<h4 id="安装依赖">安装依赖</h4>
<ul>
<li>安装<strong>GDB</strong>和<strong>openocd</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install gdb</span><br><span class="line">sudo apt-get install openocd</span><br></pre></td></tr></table></figure>
<ul>
<li>安装java运行环境</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install default-jre</span><br></pre></td></tr></table></figure>
<ul>
<li>安装eclipse</li>
</ul>
<p>进入<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWNsaXBzZS5vcmcvZG93bmxvYWRzL2Rvd25sb2FkLnBocD9maWxlPS9vb21waC9lcHAvMjAxOS0xMi9SL2VjbGlwc2UtaW5zdC13aW42NC5leGU=">eclipse 下载页<i class="fa fa-external-link-alt"></i></span>下载文件目录，并解压文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf <span class="string">&quot;your-downloaded-file&quot;</span>.tar.gz</span><br></pre></td></tr></table></figure>
<ul>
<li>开始eclipse安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;your-unzip-folder&quot;</span>/.eclipse_inst</span><br></pre></td></tr></table></figure>
<h2 id="下载">下载</h2>
]]></content>
      <categories>
        <category>crazyflie</category>
        <category>开发说明</category>
      </categories>
      <tags>
        <tag>crazyflie</tag>
        <tag>开发说明</tag>
      </tags>
  </entry>
  <entry>
    <title>crazyflie-目录分析</title>
    <url>/2020/01/22/crazyflie-directory/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>本文主要分析<strong>crazyflie</strong>项目的目录结构，并对主要目录作了简要说明。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/5WUADE8QVGmFRcT.jpg" alt="重庆" /><figcaption aria-hidden="true">重庆</figcaption>
</figure>
<span id="more"></span>
<h2 id="目录结构">目录结构</h2>
<p>下图所示是飞控项目的目录结构，项目中的包含文档说明、代码测试、项目所需的开源项目、飞控源码、编译工具和输出文件等。</p>
<p><img data-src="https://i.loli.net/2021/08/30/Ndk897wgDTzBcJR.png" /></p>
<h3 id="doc">[doc]</h3>
<p>该目录包含项目相关的说明文档，主要说明项目编译方式、CRTP包说明、扩展板开发说明等。</p>
<h3 id="blobs">[blobs]</h3>
<p>该目录包含灯塔固件。</p>
<h3 id="generated-test">[generated-test]</h3>
<p>该目录包含产生测试文件的脚本，但是从仓库拉取下来是空的。</p>
<h3 id="test">[test]</h3>
<p>该目录包含各个模块的测试用例文件。</p>
<h3 id="vender">[vender]</h3>
<p>该目录包含项目所依赖的其它项目文件，包括测试工具、实时操作系统和开源定位库等；</p>
<ul>
<li><strong>cmock</strong>：用于项目的mock测试；</li>
<li><strong>unity</strong>：用于项目的单元测试；</li>
<li><strong>CMSIS</strong>：用于实现Cortex-M 系列处理器与供应商无关的硬件抽象层；</li>
<li><strong>FreeRTOS</strong>：用于实现系统的任务调度和消息管理；</li>
<li><strong>libdw1000</strong>：用于驱动dw1000芯片，实现室内定位功能。</li>
</ul>
<h3 id="src">[src]</h3>
<p>该目录包含飞控相关的源文件，具体说明如下：</p>
<ul>
<li><strong>drivers</strong>：目录包含实现硬件底层驱动的文件，实现主控芯片外设驱动和外部芯片驱动的开发；</li>
<li><strong>hal</strong>：目录包含对硬件抽象的功能文件，将系统的某些硬件抽象成功能模块；</li>
<li><strong>modules</strong>：目录包含所有的功能模块，包括CRTP通信模块、姿态估计模块、位置控制模块、姿态稳定控制模块和传感器融合模块等；</li>
<li><strong>lib</strong>：目录包含供应商相关标准开发库、文件系统库等；</li>
<li><strong>utils</strong>：目录包含可以公用的实用程序，如CRC校验、滤波等；</li>
<li><strong>platform</strong>：目录包含平台配置的相关文件；</li>
<li><strong>deck</strong>：目录包含扩展板接口文件；</li>
<li><strong>config</strong>：目录包含系统配置相关文件；</li>
<li><strong>init</strong>：目录包含主函数文件；</li>
</ul>
<h3 id="tool">[tool]</h3>
<p>该目录包含编译源文件相关的脚本；</p>
<h3 id="bin">[bin]</h3>
<p>该目录包含编译生成的输出文件；</p>
]]></content>
      <categories>
        <category>crazyflie</category>
        <category>目录分析</category>
      </categories>
      <tags>
        <tag>crazyflie</tag>
        <tag>目录分析</tag>
      </tags>
  </entry>
  <entry>
    <title>crazyflie-硬件分析</title>
    <url>/2020/02/29/crazyflie-hardware/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>本文主要对crazyflie飞控硬件原理图设计进行简单的分析，包括电路原理、参数选型和PCB设计等。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/7zyoK5FNvTxCY8I.jpg" alt="青岛啤酒" /><figcaption aria-hidden="true">青岛啤酒</figcaption>
</figure>
<span id="more"></span>
<h2 id="原理图分析">原理图分析</h2>
<h3 id="微处理器单元">微处理器单元</h3>
<h4 id="选型">选型</h4>
<p>关于主控芯片的选型采用<a href="https://www.st.com/content/st_com/en/products/microcontrollers-microprocessors/stm32-32-bit-arm-cortex-mcus/stm32-high-performance-mcus/stm32f4-series.html"><strong>ST</strong></a>公司F4系列处理器,该系列处理器主要有三个产线，分别为进阶产线、基础产线和入门产线。基于性能和成本考虑，飞控设计选用基础产线系类，该系类主控拥有210 <strong>DMIPS</strong>，与进阶产线的225 <strong>DMIPS</strong>差距不大。由于摄像头接口外设并不需要，所以选择最基本的<strong>STM32F405</strong>系列主控就可以满足性能要求。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/mco3YEdsp4qAfJ5.jpg" alt="产品对比图" /><figcaption aria-hidden="true">产品对比图</figcaption>
</figure>
<p>由于迷你四轴对引脚需求较少，可以选择下图64引脚的RG系列封装。</p>
<p><img data-src="https://i.loli.net/2021/08/30/7ztr64V1gkHPG9B.jpg" /></p>
<p>芯片外设如下：</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/N6ZWCRBPi7JhQ92.jpg" alt="外设" /><figcaption aria-hidden="true">外设</figcaption>
</figure>
<p>飞控中主要用到的通信外设包括IIC、SPI、USART和USB，控制相关外设包括PWM。</p>
<h4 id="芯片供电分析">芯片供电分析</h4>
<h4 id="复位电路">复位电路</h4>
<h4 id="晶振">晶振</h4>
<h4 id="boot模式">Boot模式</h4>
<h3 id="传感器单元">传感器单元</h3>
<h4 id="惯性测量单元imu">惯性测量单元(IMU)</h4>
<ul>
<li><strong>Gyroscope</strong>(陀螺仪)</li>
</ul>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>BMI088</th>
<th>ICM20602</th>
<th>单位</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>TCO</strong>(零速率偏移随温度的变化)</td>
<td>15</td>
<td>10</td>
<td>mdps/K</td>
</tr>
<tr class="even">
<td><strong>TCS</strong>(零敏度随温度的变化)</td>
<td>0.03</td>
<td>2</td>
<td>%/K</td>
</tr>
<tr class="odd">
<td>零速率偏置</td>
<td>1</td>
<td>1</td>
<td>dps</td>
</tr>
<tr class="even">
<td>输出噪声</td>
<td>0.1</td>
<td>0.04</td>
<td>dps</td>
</tr>
<tr class="odd">
<td>偏差稳定性</td>
<td>&lt; 2</td>
<td></td>
<td>°/h</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>Accelerometer</strong>(加速度计)</li>
</ul>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>BMI088</th>
<th>ICM20602</th>
<th>单位</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>TCO</strong>(零速率偏移随温度的变化)</td>
<td>0.2</td>
<td>xy:0.5 z:1</td>
<td>mg/k</td>
</tr>
<tr class="even">
<td><strong>TCS</strong>(零敏度随温度的变化)</td>
<td>0.002</td>
<td>1.5</td>
<td>%/K</td>
</tr>
<tr class="odd">
<td>零重力偏置</td>
<td>20</td>
<td>25-40</td>
<td>mg</td>
</tr>
<tr class="even">
<td>噪声频谱密度</td>
<td>z:190;x,y:160</td>
<td>100</td>
<td>ug/Hz</td>
</tr>
<tr class="odd">
<td>输出噪声</td>
<td>2.4</td>
<td>1.0</td>
<td>mg</td>
</tr>
<tr class="even">
<td>非线性度</td>
<td>0.5</td>
<td>0.3</td>
<td>%FS</td>
</tr>
<tr class="odd">
<td>跨轴灵敏度(<strong>Cross-Axis Sensitivity</strong>)</td>
<td>0.5</td>
<td>1</td>
<td>%</td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li>非线性度：理想情况下，电压与加速度之间是线性关系，用器件的灵敏度来描述。 非线性度衡量实际灵敏度与理想的恒定灵敏度之间的偏差，用相对于满量程范围(%FSR)或正负满量程(%FS)的百分比来表示。 通常，FSR = FS+FS。 ADI加速度计的非线性度非常低，绝大多数情况下可忽略不计。</li>
<li>跨轴灵敏度:衡量对某一轴施加一个加速度时，在另一轴上产生多大的输出，通常表示为百分比。 两个轴之间的耦合是由对齐误差、蚀刻不精确性和电路串扰共同造成。</li>
</ul>
</blockquote>
<h4 id="高度测量单元">高度测量单元</h4>
<ul>
<li>气压计</li>
</ul>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>BMP388</th>
<th>ICP101</th>
<th>单位</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Relative Accuracy</strong>(相对精度)</td>
<td>8</td>
<td>3</td>
<td>Pa</td>
</tr>
<tr class="even">
<td><strong>Absolute Accuracy</strong>(绝对精度)</td>
<td>50</td>
<td>100</td>
<td>Pa</td>
</tr>
<tr class="odd">
<td><strong>TCO</strong>(温度偏移系数)</td>
<td>0.75</td>
<td>0.5</td>
<td>Pa/k</td>
</tr>
<tr class="even">
<td><strong>Resolution</strong>(解析度)</td>
<td>0.016</td>
<td>0.01</td>
<td>Pa</td>
</tr>
</tbody>
</table>
<h3 id="电机驱动单元">电机驱动单元</h3>
<p>由于mini四轴一般采用空心杯电机，驱动电路相对简单。方案设计中选用简单的<strong>MOS</strong>电路驱动，具体形式如下：</p>
<p><img data-src="https://i.loli.net/2021/08/30/njYsXcdS4FPWaGN.png" /></p>
<p>由上图可知，选用<strong>NMOS</strong>搭建驱动电路，参考<code>CJ2302</code>数据手册知，<span class="math inline">\(V_{gs}\)</span>阀值为<span class="math inline">\(0.95V\)</span>，<span class="math inline">\(GS\)</span>驱动电流<span class="math inline">\(I_{gss}=\pm100nA\)</span>。所以选取电阻<span class="math inline">\(R1\)</span>和<span class="math inline">\(R2\)</span>参数时，为了减小<span class="math inline">\(DS\)</span>端的导通电阻，需要保证<span class="math inline">\(V_{gs}\)</span>尽可能大。</p>
<p>为了满足驱动电流<span class="math inline">\(I_{gss}\)</span>的需求，电阻<span class="math inline">\(R1\)</span>需要足够小，几欧姆的数量级即可。电阻<span class="math inline">\(R1\)</span> 如果选取太小数值，又会增大导通过程产生的振铃，太大可能会不满足瞬间驱动电流，无法导通。</p>
<p>图中二极管<span class="math inline">\(D1\)</span>用于续流二极管，当<strong>NMOS</strong>管关闭时，电机内部可以等效为一个电感，与二极管<span class="math inline">\(D1\)</span>组成一个放电回路，释放电机停止过程中的电流，避免对MOS管的损坏。</p>
<h3 id="无线通信单元">无线通信单元</h3>
<p><img data-src="https://i.loli.net/2021/08/30/TPBn7pdRXvlcO5f.png" /></p>
<p>如上图所示，51与52系列的主要功能对比，对于mini飞控来说，51系列芯片性能已经足够使用。目前由于对车规级认证无要求，且无需ANT协议，所以选取<strong>nRF51</strong>系列无线芯片中的<strong>nRF51822</strong> SoC。</p>
<p>设计中采用<strong>RFX2411N</strong>收发一体的驱动器。</p>
<h3 id="电源管理单元">电源管理单元</h3>
<h4 id="电池管理芯片">电池管理芯片</h4>
<p>设计中选用电池管理芯片<strong>BQ24075</strong>，充电电流1.5A，支持一个电池。</p>
<h4 id="线性电源">线性电源</h4>
<p>无线通信模块采用<strong>NCP702SN30</strong>线性电源芯片单独供电，传感器模块采用<strong>LP2985</strong>线性电源芯片单独供电。</p>
]]></content>
      <categories>
        <category>crazyflie</category>
        <category>硬件设计</category>
      </categories>
      <tags>
        <tag>crazyflie</tag>
        <tag>硬件设计</tag>
        <tag>Hardware</tag>
      </tags>
  </entry>
  <entry>
    <title>传感器融合-路面坡度计算</title>
    <url>/2020/09/17/%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88-%E8%B7%AF%E9%9D%A2%E5%9D%A1%E5%BA%A6%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>本文主要介绍一种计算车辆坡度角的方法，利用有限的两轴加速度传感器并结合车辆动力学特性，实时估算车辆的坡度角。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/wI6rcvWo2CzU9Fe.jpg" alt="青岛" /><figcaption aria-hidden="true">青岛</figcaption>
</figure>
<span id="more"></span>
<h2 id="融合框架">融合框架</h2>
<p><img data-src="https://i.loli.net/2021/08/30/Y6Z5RjPhEUwvuDQ.png" style="zoom: 80%;" /></p>
<h2 id="基于加速度偏差坡度估计">基于加速度偏差坡度估计</h2>
<h3 id="车辆坐标系定义">车辆坐标系定义</h3>
<p>车辆坐标下定义如下：</p>
<p><img data-src="https://i.loli.net/2021/08/30/otAnhJlSK4IDqbG.png" alt="车辆坐标系" style="zoom:80%;" /></p>
<p>沿车辆中轴线确定<span class="math inline">\(x\)</span>轴，车头方向为正方向; <span class="math inline">\(x\)</span>轴与后轴的交点为原点<span class="math inline">\(o\)</span>，过点<span class="math inline">\(o\)</span>作一条直线与<span class="math inline">\(x\)</span>轴垂直，将该直线定义为<span class="math inline">\(y\)</span>轴，沿<span class="math inline">\(x\)</span>轴逆时针方向为正。</p>
<h3 id="加速度计定义">加速度计定义</h3>
<p><img data-src="https://i.loli.net/2021/08/30/4mD37ckXrAefagQ.png" alt="加速度计" style="zoom:80%;" /></p>
<p>一般车辆加速度计的安装与车辆坐标系一致，车辆前进时，加速前进，传感测量值为<strong>正</strong>；减速前进，传感器测量值为<strong>负</strong>。车辆后退时，加速后退，传感器输出值为<strong>负</strong>；减速后退，传感器输出值为<strong>正</strong>。</p>
<p>同理，如果车辆前进上坡，静止在坡道上，传感器输出信号为<strong>正</strong>值；车辆前进下坡，静止在坡道上，传感器输出信号为<strong>负</strong>值。</p>
<h3 id="计算坡度值">计算坡度值</h3>
<h4 id="上坡静止状态">上坡静止状态</h4>
<p><img data-src="https://i.loli.net/2021/08/30/WVomupz7c63rIOh.png" style="zoom: 80%;" /></p>
<p>如上图所示，车辆上坡阶段，静止于坡道上时，加速度传感器在<span class="math inline">\(x\)</span>轴上存在重力分量，可以表示为 <span class="math display">\[
a_x = g\sin(\theta) \tag{1}
\]</span></p>
<h4 id="下坡静止状态">下坡静止状态</h4>
<p><img data-src="https://i.loli.net/2021/08/30/hSejlLFqodQRECI.png" style="zoom: 80%;" /></p>
<p>如上图所示，车辆下坡阶段，静止于坡道上时，加速度传感器在<span class="math inline">\(x\)</span>轴上存在重力分量，可以表示为 <span class="math display">\[
a_x=g\sin(\pi -\theta)=g\sin(-\theta) \tag{2}
\]</span></p>
<h4 id="车辆加速度">车辆加速度</h4>
<p><img data-src="https://i.loli.net/2021/08/30/afgl2rYhUwP5964.png" style="zoom: 80%;" /></p>
<p>如上图所示，通过采集相邻时刻<span class="math inline">\(k-1\)</span>和<span class="math inline">\(k\)</span>的纵向速度，计算车辆<span class="math inline">\(k-1\)</span>时刻的加速度为 <span class="math display">\[
\dot{v}_x(k-1) = \frac{v(k) - v(k-1)}{\Delta T} \tag{3}
\]</span> 其中，<span class="math inline">\(\Delta T\)</span>为采样步长，<span class="math inline">\(v(k)\)</span>定义前进为正，后退为负。</p>
<h4 id="坡度角计算">坡度角计算</h4>
<p>基于车辆在坡道上的受力分析，可以推算出当车辆运动时，加速度传感器输出信号<span class="math inline">\(a_x\)</span>与坡度角<span class="math inline">\(\theta\)</span>的关系如下： <span class="math display">\[
a_x = \dot{v}_x + g\sin(\theta) \tag{4}
\]</span> 所以坡度角可以表示如下： <span class="math display">\[
\theta = \arcsin(\frac{a_x - \dot{v}_x}{g}) \tag{5}
\]</span></p>
<h2 id="基于纵向动力学坡度计算">基于纵向动力学坡度计算</h2>
<h3 id="车辆纵向动力学模型">车辆纵向动力学模型</h3>
<p><img data-src="https://i.loli.net/2021/08/30/U8Ae7RSxg6OhcYv.png" style="zoom:80%;" /></p>
<p>如上图所示，车辆纵向方向主要受到发动机产生的牵引力<span class="math inline">\(F_x\)</span>的影响，同时也受到重力分量、迎风阻力和地面摩擦力的影响。通过对车辆对上述力的分析，车辆的动力学模型可以表示如下：</p>
<p><span class="math display">\[
F_x - mg\sin(\theta) - fmg\cos(\theta) - \frac{1}{2}\rho C_dAv_x^2 = m\dot{v}_x\tag{6}
\]</span></p>
<p>其中，<span class="math inline">\(m\)</span>为车辆质量，<span class="math inline">\(\rho\)</span>为空气密度，<span class="math inline">\(C_d\)</span>为风阻系数，<span class="math inline">\(A\)</span>为迎风面积，<span class="math inline">\(g\)</span>为重力加速度，<span class="math inline">\(\theta\)</span>为路面坡度，<span class="math inline">\(f\)</span>为路面滚阻系数。上述等式(6)中，路面坡度<span class="math inline">\(\theta\)</span>为待求参数，其它参数对于某一车辆来说均可以认为是已知的或者通过测量能够得到。</p>
<p>令 <span class="math inline">\(y = F_x\)</span>，<span class="math inline">\(u = m\dot{v}_x + \frac{1}{2}\rho C_dAv_x^2\)</span>，<span class="math inline">\(b = mg(\sin(\theta) + f\cos(\theta))\)</span>，将公式(6)简化为：</p>
<p><span class="math display">\[
y = u + b \tag{7}
\]</span></p>
<p>上式中，<span class="math inline">\(y\)</span>、<span class="math inline">\(u\)</span>为已知量，<span class="math inline">\(b\)</span>为未知量，由于<span class="math inline">\(b\)</span>是参数<span class="math inline">\(\theta\)</span>的函数，因此对路面坡度的估计可以通过估算<span class="math inline">\(\hat{b}\)</span>的值求得。</p>
<h3 id="参数估计">参数估计</h3>
<p>采用带有遗忘因子的最小二乘法估计<span class="math inline">\(b\)</span>的值，假设代价函数为<span class="math inline">\(V(\hat{b},k)\)</span>，那么采用最小二乘法估计<span class="math inline">\(b\)</span>的值，相当于求解参数<span class="math inline">\(\hat{b}\)</span>，使得函数<span class="math inline">\(V(\hat{b},k)\)</span>在某一时刻<span class="math inline">\(k\)</span>取得最小值。</p>
<p><span class="math display">\[
V(\hat{b},k) = \frac{1}{2}\sum_{i=1}^{k} \lambda^{k-i}(y_i - u_i - \hat{b}_k)^2 \tag{8}
\]</span></p>
<p>其中，<span class="math inline">\(\lambda\)</span>为遗忘因子，<span class="math inline">\(k\)</span>为采样时刻。</p>
<p>函数极小值的计算可以通过求解函数导数为0的参数，及</p>
<p><span class="math display">\[
\frac{\partial V}{\partial \hat{b}_k} = 0 \tag{9}
\]</span></p>
<p>结合等式(8)、(9)得</p>
<p><span class="math display">\[
\sum_{i=1}^{k}\lambda^{k-i}(y_i - u_i - \hat{b}_k)=0\tag{10}
\]</span></p>
<p>对等式(10)化简得</p>
<p><span class="math display">\[
\sum_{i=1}^{k}\lambda^{k-i}(y_i-u_i) - \sum_{i=1}^{k}\lambda^{k-i}\hat{b}_k=0 \tag{11}
\]</span></p>
<p>移项得</p>
<p><span class="math display">\[
\hat{b}_k \sum_{i=1}^{k}\lambda^{k-i} =\sum_{i=1}^{k}\lambda^{k-i}(y_i-u_i) \tag{12}
\]</span></p>
<p>基于等式(12)，提取<span class="math inline">\(\hat{b}_k\)</span>得</p>
<p><span class="math display">\[
\hat{b}_k = (\sum_{i=1}^{k}\lambda^{k-i})^{-1}\bigl(\sum_{i=1}^{k}\lambda^{k-i}(y_i-u_i)\bigr) \tag{13}
\]</span></p>
<p>从等式(13)可以看出，随着采样时刻<span class="math inline">\(k\)</span>不断增加，估计值<span class="math inline">\(\hat{b}\)</span>的计算量也不断增加。由于车辆行驶过程中的路面坡度估计需要实时计算，因此在实际应用中一般采用递推最小二乘估计来实时估计每一采样时刻<span class="math inline">\(b\)</span>的估计值<span class="math inline">\(\hat{b}\)</span>。</p>
<p><span class="math display">\[
\hat{b}_k = \hat{b}_{k-1} + L_k(y_k -u_k)\tag{14}
\]</span></p>
<p>增益系数<span class="math inline">\(L_k\)</span>为</p>
<p><span class="math display">\[
L_k = \frac{P_{k-1}}{\lambda + P_{k-1}} \tag{15}
\]</span></p>
<p>误差协方差<span class="math inline">\(P_k\)</span>为</p>
<p><span class="math display">\[
P_k = \frac{1}{\lambda}(1 - L_k)P_{k-1} \tag{16}
\]</span></p>
<p>根据公式(14)、(15)、(16)的更新过程</p>
<p><span class="math display">\[
D = \frac{\hat{b}}{mg} \tag{17}
\]</span></p>
<p>坡度角为</p>
<p><span class="math display">\[
\theta = \arcsin(\frac{D-f\sqrt{1-D^2 + f^2}}{1 + f^2}) \tag{18}
\]</span></p>
<h2 id="坡度角融合">坡度角融合</h2>
<p>车辆行驶过程中路面坡度<span class="math inline">\(\theta\)</span>可以认为是高频信号和低频信号两部分组成，在对路面坡度进行估计时，基于纵向动力学估计方法依赖于车辆的多个参数，车辆的各个参数受高频噪声影响大；基于加速度偏差坡度估计的缺点是受惯性传感器的静态偏差影响较大，惯性传感器的静态偏差属于低频噪声，为了保证路面坡度估算结果的准确性，对<span class="math inline">\(\theta_1\)</span>采用低通滤波器除去其高频部分，对<span class="math inline">\(\theta_2\)</span>采用高通滤波器滤除其低频部分，最终得到更加准确的实时估计值<span class="math inline">\(\hat{\theta}\)</span>为：</p>
<p><span class="math display">\[
\hat{\theta} = \frac{1}{\tau s + 1}\theta_1 + \frac{\tau s}{\tau s + 1}\theta_2 \tag{19}
\]</span></p>
<p>其中，<span class="math inline">\(\tau\)</span>为时间常数，<span class="math inline">\(s\)</span>为拉普拉斯算子，<span class="math inline">\(\frac{1}{\tau s + 1}\)</span>为低通滤波器，<span class="math inline">\(\frac{\tau s}{\tau s + 1}\)</span>为高通滤波器。</p>
]]></content>
      <categories>
        <category>传感器融合算法</category>
      </categories>
      <tags>
        <tag>sensor fusion</tag>
        <tag>传感器融合</tag>
        <tag>车辆坡度计算</tag>
        <tag>加速度计</tag>
      </tags>
  </entry>
  <entry>
    <title>路径规划-AStar</title>
    <url>/2020/04/15/%E5%9F%BA%E4%BA%8E%E5%9B%BE%E6%90%9C%E7%B4%A2-AStar/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>A*算法是一种基于图搜索的路径搜索算法,通过结合移动代价和启发代价,优化路径的搜索性能. <img data-src="https://i.loli.net/2021/08/30/kMIZKgcV7PnNQEC.jpg" alt="青岛" /> <span id="more"></span></p>
<h2 id="算法描述">算法描述</h2>
<h3 id="确定规划的起点和终点">确定规划的起点和终点</h3>
<p>下图所示,红色方块代表规划<strong>起始点</strong>,绿色方块代表<strong>终点</strong>,深灰色方块代表<strong>障碍物</strong>区域,其余白色方块代表可行驶区域(free space).首先将起始点节点推送到open集合中.</p>
<p><img data-src="https://i.loli.net/2021/08/30/3agpvPEB89XTLK4.png" alt="原始地图给定起始点和终点" style="zoom:50%;" /></p>
<h3 id="产生临近节点">产生临近节点</h3>
<p>每次从open集合中取出<strong>总代价值</strong>最小的节点,由于当前open集合中只有起始节点,所以此时从open集合中取出的就是起始节点,并将该节点推入close集合.</p>
<p>如下图所示,基于起始节点生成相邻节点,并计算每个节点的代价值.其中<strong>A</strong>*节点的代价值由<strong>移动代价</strong>和<strong>启发代价</strong>组成,即<span class="math inline">\(F = G + H\)</span>.</p>
<p>本例中,采用如下距离计算代价值:</p>
<ul>
<li><strong>移动代价</strong> 采用欧拉距离计算移动代价值</li>
<li><strong>启动代价</strong> 采用曼哈顿距离计算启发代价值</li>
</ul>
<p><img data-src="https://i.loli.net/2021/08/30/6sE9MRizIfejx4H.png" alt="临近节点产生" style="zoom:50%;" /></p>
<h4 id="图例说明">图例说明</h4>
<p>下图是对上图中每个节点中小方格的说明:</p>
<ul>
<li><strong>左下角</strong>的方格代表移动代价</li>
<li><strong>右下角</strong>的方格代表启发代价</li>
<li><strong>最上方</strong>的矩形方格代表总的代价值</li>
<li><strong>中间</strong>的紫色方格代表父节点的方向</li>
</ul>
<p><img data-src="https://i.loli.net/2021/08/30/dk7cMlj1O5ACWNZ.png" style="zoom: 80%;" /></p>
<h3 id="节点选择">节点选择</h3>
<p>A*算法下一节点的选择,是从open集合中选取总代价值最小的节点.如下图所示,位于起始点右侧的节点代价值最小,图中使用浅绿色蒙板覆盖该节点表示选中.</p>
<p><img data-src="https://i.loli.net/2021/08/30/yaH7igL1RWFxMEI.png" alt="选择价值最低节点" style="zoom:80%;" /></p>
<h3 id="节点扩展">节点扩展</h3>
<p>基于选中的节点,根据扩展规则,生成新的临近节点,计算临近节点时只需要计算<strong>移动代价</strong>.</p>
<p>如下图中的右侧所示,对于新生成的8个节点需要做如下条件判断:</p>
<ul>
<li><p>是否在<strong>close</strong>集合中:</p>
<p>如果该节点在close集合中,直接跳过该节点,进行下一节点的判断</p></li>
<li><p>是否<strong>碰撞</strong>:</p>
<p>若该节点与障碍物存在碰撞可能,则跳过该节点,进行下一节点的判断;</p></li>
<li><p>是否在<strong>open</strong>集合中:</p>
<ol type="1">
<li><p>如果该节点==在==open集合中,需要判断该节点的移动代价是否小于原先位置节点的移动代价:</p>
<p>如果小于,则替换原先节点,并将节点的父节点方向指向当前节点,否则跳过该节点,进行下一节点的判断.</p></li>
<li><p>如果该节点==不在==open集合,则直接将其加入open集合.</p></li>
</ol></li>
</ul>
<p>如下图所示,当前节点的左侧的节点已经在close集合中,直接跳过该节点;当前节点左上角,左下角,上方和下方的节点已经在open集合中,所以需要比较新节点与open集合中节点的移动代价.通过比较,这四个新节点的移动代价大于相应open集合中节点的移动代价,所以跳过这些节点;当前节点右侧三个新节点都不在open集合中,所以直接将它们推入open集合.</p>
<p><img data-src="https://i.loli.net/2021/08/30/zdJIXQBpYuF7OAZ.png" style="zoom: 67%;" /></p>
<p>基于扩展规则,不断推出总代价值最小的节点,并扩展这些节点.下图中,当前节点右侧三个新节点与障碍存在碰撞,所以直接跳过.</p>
<p><img data-src="https://i.loli.net/2021/08/30/pqgZ2vl5XixR4mU.png" style="zoom: 67%;" /></p>
<p>如下图所示,如果存在总代价相等的情况,则先推出最新推入的节点.下图中,假设右下方总代价值为64的节点是新推进open集合的节点.</p>
<p><img data-src="https://i.loli.net/2021/08/30/JENcBzb1UmMZYLX.png" style="zoom:67%;" /></p>
<p>如下图所示,继续推出新的节点,并迭代更新.</p>
<p><img data-src="https://i.loli.net/2021/08/30/v4cL526HZYWtbXh.png" style="zoom:67%;" /></p>
<p>如下图所示,新的节点有的与障碍物存在碰撞,有的已经在close集合中,有的移动代价大于原先的节点;但当前节点下方的节点,其移动代价小于open集中对应节点的代价,所以需替换open集合中该节点的移动代价,并将其父节点指向当前节点.</p>
<p><img data-src="https://i.loli.net/2021/08/30/pBPmRbjvfouhLzq.png" style="zoom:67%;" /></p>
<h3 id="迭代">迭代</h3>
<p>如下图所示,直到从open集合中推出的节点是终点,表明搜索结束.浅绿色蒙板包含的区域属于close集合,其它搜索过的节点属于open集合.如果遍历所有open集合的节点都无法到达终点,则搜索失败.</p>
<p><img data-src="https://i.loli.net/2020/10/31/w3grmTFfHltY24U.png" alt="搜索完成" style="zoom: 67%;" /></p>
<h3 id="获取路径">获取路径</h3>
<p>如下图所示,搜索结束后,以终点为起始节点,根据节点所指向的父节点,反向更新搜索路径,直到节点的父节点指向为空,即到达起始点.</p>
<p><img data-src="https://i.loli.net/2020/10/31/Eqa4sbG6jgUnXVI.png" alt="搜索结果" style="zoom: 67%;" /></p>
<h2 id="参考">参考</h2>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cucmVkYmxvYmdhbWVzLmNvbS9wYXRoZmluZGluZy9hLXN0YXIvaW50cm9kdWN0aW9uLmh0bWw=">Introduction to the A* Algorithm<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cucmVkYmxvYmdhbWVzLmNvbS9wYXRoZmluZGluZy9hLXN0YXIvaW1wbGVtZW50YXRpb24uaHRtbCNhbGdvcml0aG0=">Implementation of A*<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xNjE2NjA5MzI=">路径规划中的Hybrid A*算法<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>规划算法</category>
        <category>图搜索算法</category>
      </categories>
      <tags>
        <tag>路径规划</tag>
        <tag>A Star</tag>
        <tag>A*</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法-LQR-离散时间有限边界</title>
    <url>/2020/02/20/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-LQR-%E7%A6%BB%E6%95%A3%E6%97%B6%E9%97%B4%E6%9C%89%E9%99%90%E8%BE%B9%E7%95%8C/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>本文介绍离散时间有限范围内的<strong>LQR(Linear Quadratic Regulator)</strong>算法求解过程. <img data-src="https://i.loli.net/2021/08/30/erFAJgdV85LWOvI.jpg" alt="蝴蝶花" /></p>
<span id="more"></span>
<h2 id="lqr问题背景">LQR问题背景</h2>
<p>对于一个离散时间系统：</p>
<p><span class="math display">\[
x_{t+1}=Ax_t + Bu_t,x_0=x_{init}\tag{1}
\]</span></p>
<p>其中，<span class="math inline">\(A\in R^{n\times n}\)</span>，<span class="math inline">\(B\in R^{n\times m}\)</span></p>
<p>关于最优问题，就在于如何选择合适的<span class="math inline">\(u_0,u_1,...\)</span>，使得状态量<span class="math inline">\(x_0,x_1,...\)</span>足够小，因此得到好的调节和控制；或者使得<span class="math inline">\(u_0,u_1,...\)</span>足够小，以使用更少的能量。这两个量通常相互制约，如果采用更大的输入<span class="math inline">\(u\)</span>，就会驱使状态量<span class="math inline">\(x\)</span>更快达到0。采用线性二次调节原理可以解决这个问题。</p>
<h2 id="lqr代价函数">LQR代价函数</h2>
<p>为了表示控制系统达到稳定控制所付出的代价，定义如下二次型代价函数：</p>
<p><span class="math display">\[
J(U)=\sum^{N-1}_{\tau=0}(x^{T}_{\tau}Qx_{\tau} + u^{T}_{\tau}Ru_{\tau})+ x^{T}_{N}Q_{f}x_{N}\tag{2}
\]</span></p>
<p>其中函数参数<span class="math inline">\(U = (u_0,u_1,..,u_N)\)</span>，并且矩阵<span class="math inline">\(Q,Q_f,R\)</span>为正定矩阵，及</p>
<p><span class="math display">\[
\begin{array}{cl}
Q=Q^{T}\geq0,&amp;Q_f=Q_{f}^{T}\geq0,&amp;R=R^{T}&gt;0
\end{array}
\]</span></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(Q\)</span></th>
<th style="text-align: center;"><span class="math inline">\(Q_f\)</span></th>
<th style="text-align: center;"><span class="math inline">\(R\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">给定状态代价矩阵</td>
<td style="text-align: center;">最终状态代价矩阵</td>
<td style="text-align: center;">输入代价矩阵</td>
</tr>
</tbody>
</table>
<ul>
<li><span class="math inline">\(N\)</span>：时间范围(考虑<span class="math inline">\(N = \infty\)</span>)</li>
<li><span class="math inline">\(Q\)</span>，<span class="math inline">\(R\)</span>：分别设定状态偏差和输入的相对权重</li>
<li><span class="math inline">\(R&gt;0\)</span>：意味着任何非零输入都增加<span class="math inline">\(J\)</span>的代价</li>
<li><span class="math inline">\(x_{\tau}^{T} {Q} x_{\tau}\)</span>：衡量状态偏差</li>
<li><span class="math inline">\(u^{T}_{\tau} R u_{\tau}\)</span>：衡量输入大小</li>
<li><span class="math inline">\(x^{T}_{N} Q_{f} x_{N}\)</span>：衡量最终状态偏差</li>
</ul>
<p>因此，关于<strong>LQR</strong>问题就是找出使得代价函数<span class="math inline">\(J(U)\)</span>最小的一组控制输入<span class="math inline">\((u_0,u_1,...,u_{N-1})_{lqr}\)</span>。</p>
<h2 id="求解lqr方法">求解LQR方法</h2>
<p>本文主要介绍两种求解LQR的方法，分别为最小二乘法和动态规划算法。</p>
<h3 id="最小二乘法">最小二乘法</h3>
<p>根据公式(1)可知，<span class="math inline">\(x_0\)</span>是<span class="math inline">\(X = (x_0,...,x_N)\)</span>的线性函数，并且<span class="math inline">\(U = (u_0,...,u_{N-1})\)</span>，可以得出如下关系：</p>
<p><span class="math display">\[
\begin{array}{cl}
x_1 &amp;= Ax_0 + Bu_0\\
x_2 &amp;= Ax_1 + Bu_1\\
\vdots\\
x_n &amp;= Ax_{N-1} + Bu_{N-1}
\end{array}\tag{3}
\]</span></p>
<p>将上述公式(3)逐个带入得</p>
<p><span class="math display">\[
\begin{array}{cl}
x_1 &amp;= Ax_0 + Bu_0\\
x_2 &amp;= A^{2}x_0 + ABu_0 + Bu_1\\
\vdots\\
x_n &amp;= A^{N}x_0 + A^{N-1}Bu_0 + A^{N-2}Bu_1 + \dots+ Bu_{N-1}
\end{array} \tag{4}
\]</span></p>
<p>整理得</p>
<p><span class="math display">\[
\left[\begin{array}{cl}
x_0\\
x_1\\
\vdots\\
x_N
\end{array}\right]=
\left[ \begin{array}{cl}
0 &amp; \dots \\
B &amp; 0 &amp; \dots \\
AB &amp; B &amp; 0 &amp; \dots \\
\vdots &amp; \vdots \\
A^{N-1}B &amp; A^{N-2}B &amp; \dots &amp; B
\end{array}\right]
\left[
\begin{array}{cl}
u_0\\
u_1\\
\vdots\\
u_{N-1}
\end{array}
\right]+
\left[
\begin{array}{cl}
I\\
A\\
\vdots\\
A^{N}
\end{array}
\right]x_0 \tag{5}
\]</span></p>
<p>其中</p>
<p><span class="math display">\[
G=\left[ \begin{array}{cl}
0 &amp; \dots \\
B &amp; 0 &amp; \dots \\
AB &amp; B &amp; 0 &amp; \dots \\
\vdots &amp; \vdots \\
A^{N-1}B &amp; A^{N-2}B &amp; \dots &amp; B
\end{array}\right]，H=\left[
\begin{array}{cl}
I\\
A\\
\vdots\\
A^{N}
\end{array}
\right]
\]</span></p>
<p>等式(5)可以进一步表示为</p>
<p><span class="math display">\[
X= GU + Hx_0 \tag{6}
\]</span></p>
<p>其中，<span class="math inline">\(G\in R^{Nn\times Nm}\)</span>，<span class="math inline">\(H\in R^{Nn\times n}\)</span>。</p>
<p>从而等式(2)所表示得代价函数可以表示为</p>
<p><span class="math display">\[
J(U)=\parallel diag(Q^{1/2},\dots,Q^{1/2},Q^{1/2}_{f})(GU+Hx_0)\parallel^2+
\parallel diag(R^{1/2},\dots,R^{1/2})U\parallel^2 \tag{7}
\]</span></p>
<p>这就转化成一个求解最小二乘法的问题，其问题大小为<span class="math inline">\(N(n + m)\times Nm\)</span>。</p>
<h3 id="动态规划法dynamic-programming">动态规划法(Dynamic Programming)</h3>
<p>动态规划算法是解决多阶段决策过程最优化的一种有效的数学方法。</p>
<h4 id="值函数">值函数</h4>
<p>首先定义一个值函数<span class="math inline">\(V_t:R^n \to R\)</span>,其中<span class="math inline">\(t=(0,\dots,N)\)</span>：</p>
<p><span class="math display">\[
V_t(z)=\min_{u_t,\dots,u_{N-1}}\Bigl(\sum_{\tau=t}^{N-1}(x^T_\tau Qx_\tau + u^t_\tau Ru_\tau) + x_N^TQ_fx_N\Bigr) \tag{8}
\]</span></p>
<p>如果设置<span class="math inline">\(x_t = z\)</span>，根据公式(1)的关系，<span class="math inline">\(x_{\tau+1} = Ax_{\tau} + Bu_{\tau}\)</span>,并且<span class="math inline">\(\tau=t,\dots,N\)</span>。</p>
<ul>
<li><span class="math inline">\(V_t(z)\)</span>可以表示在<span class="math inline">\(t\)</span>时刻，从状态<span class="math inline">\(z\)</span>开始的LQR最小代价值</li>
<li><span class="math inline">\(V_0(x_0)\)</span>表示在0时刻，从状态<span class="math inline">\(x_0\)</span>开始的LQR最小代价值</li>
</ul>
<p><span class="math inline">\(V_t\)</span>可以表示为二次型的形式，即<span class="math inline">\(V_T(z)=z^TP_tz\)</span>, 其中<span class="math inline">\(P_t=P_t^T \geq 0\)</span>。当<span class="math inline">\(t=N\)</span>时，代价值函数为：</p>
<p><span class="math display">\[
V_N(z) = z^TQ_f z \tag{9}
\]</span></p>
<p>因此<span class="math inline">\(P_N = Q_f\)</span>。</p>
<p>根据动态规划原理，等式(8)可以写成如下递归关系式：</p>
<p><span class="math display">\[
V_t(z)=\min_w\bigl(z^TQz + w^TRw + V_{t+1}(Az+Bw)\bigr)\tag{10}
\]</span></p>
<p>其中，</p>
<ul>
<li><span class="math inline">\(z^TQz + w^TRw\)</span>：如果<span class="math inline">\(u_t = w\)</span>,则代表<span class="math inline">\(t\)</span>时刻产生的代价值；</li>
<li><span class="math inline">\(V_{t+1}(Az+Bw)\)</span>：代表从<span class="math inline">\(t+1\)</span>时刻开始，引起的最小代价值；</li>
</ul>
<p>提取等式(10)中与<span class="math inline">\(w\)</span>无关的选项得</p>
<p><span class="math display">\[
V_t(z)=z^TQz + \min_w\bigl(w^TRw + V_{t+1}(Az+Bw)\bigr)\tag{11}
\]</span></p>
<p>等式(11)描述了<span class="math inline">\(V_t(z)\)</span>与<span class="math inline">\(V_{t+1}(z)\)</span>之间的递归关系。</p>
<p>最优控制率<span class="math inline">\(u_t\)</span>可以表示为</p>
<p><span class="math display">\[
u_t^{lqr}=arg\min_w\bigl(w^TRw + V_{t+1}(Az+Bw)\bigr)
\]</span></p>
<h4 id="求极值">求极值</h4>
<p>假设<span class="math inline">\(V_{t+1}= z^TP_{t+1}z\)</span>,并且<span class="math inline">\(P_{t+1}=P^{T}_{t+1} \geq0\)</span>,等式(13)可以进一步转化为<span class="math inline">\(P_{t+1}\)</span>的形式：</p>
<p><span class="math display">\[
V_t(z)=z^TQz + \min_w\bigl(w^TRw + (Az+Bw)^TP_{t+1}(Az+Bw)\bigr)\tag{12}
\]</span></p>
<p>为了求最小值，对<span class="math inline">\(w\)</span>求导，导数为零的点即为最值点。</p>
<p><span class="math display">\[
2w^TR + 2(Az+Bw)^TP_{t+1}B = 0 \tag{13}
\]</span></p>
<p>推导等式(13)，求取<span class="math inline">\(w\)</span>:</p>
<p><span class="math display">\[
\begin{array}{cl}
w^TR + z^{T}A^{T}P_{t+1}B+w^{T}B^{T}P_{t+1}B &amp;= 0\\
w^T(R + B^TP_{t+1}B) &amp;= - z^{T}A^{T}P_{t+1}B &amp;\text{(合并同类项并移项)}\\
(R + B^TP_{t+1}B)^Tw &amp;= -B^TP_{t+1}^{T}Az &amp; \text{(转置)}\\
(R + B^TP_{t+1}B)w &amp;= -B^TP_{t+1}Az &amp;(P_{t+1}=P^{T}_{t+1},R=R^T)\\
w &amp;=-(R + B^TP_{t+1}B)^{-1}B^TP_{t+1}Az &amp;\text{(矩阵求逆)}
\end{array}\tag{14}
\]</span></p>
<p>由等式(14)可知，最优输入为</p>
<p><span class="math display">\[
w^* =-(R + B^TP_{t+1}B)^{-1}B^TP_{t+1}Az \tag{15}
\]</span></p>
<p>将等式(15)带入等式(12)得</p>
<p><span class="math display">\[
V_t(z)=z^TQz + w^{*T}Rw^* + (Az+Bw^*)^TP_{t+1}(Az+Bw^*)\tag{16}
\]</span></p>
<p>对等式(16)化简得</p>
<p><span class="math display">\[
\begin{array}{cl}
V_t(z) 
&amp;= &amp; z^TQz + w^{*T}Rw^* + (Az+Bw^*)^TP_{t+1}(Az+Bw^*)\\
&amp;= &amp; z^TQz + w^{*T}Rw^* + z^TA^TP_{t+1}Az + 2z^TA^TP_{t+1}Bw^* + w^{*T}B^TP_{t+1}Bw^*\\
&amp;= &amp;z^TQz + z^TA^TP_{t+1}Az + w^{*T}(R+B^TP_{t+1}B)w^*  + 2z^TA^TP_{t+1}Bw^*\\
&amp;= &amp;z^TQz + z^TA^TP_{t+1}Az\\
&amp;  &amp;+z^TA^TP_{t+1}B(R + B^TP_{t+1}B)^{-1}(R+B^TP_{t+1}B)(R + B^TP_{t+1}B)^{-1}B^TP_{t+1}Az\\
&amp;  &amp;-2z^TA^TP_{t+1}B(R + B^TP_{t+1}B)^{-1}B^TP_{t+1}Az\\
&amp;= &amp;z^TQz + z^TA^TP_{t+1}Az\\
&amp;  &amp;+z^TA^TP_{t+1}B(R + B^TP_{t+1}B)^{-1}B^TP_{t+1}Az\\
&amp;  &amp;-2z^TA^TP_{t+1}B(R + B^TP_{t+1}B)^{-1}B^TP_{t+1}Az\\
&amp;= &amp;z^TQz + z^TA^TP_{t+1}Az - z^TA^TP_{t+1}B(R + B^TP_{t+1}B)^{-1}B^TP_{t+1}Az\\
&amp;= &amp;z^T(Q + A^TP_{t+1}A - A^TP_{t+1}B(R + B^TP_{t+1}B)^{-1}B^TP_{t+1}A)z\\
&amp;= &amp;z^TP_tz
\end{array}\tag{17}
\]</span></p>
<p>上述公式化简过程中，由于<span class="math inline">\(P_{t+1}=P^{T}_{t+1},R=R^T\)</span>，所以<span class="math inline">\(\bigl((R+B^TP_{t+1}B)^{-1}\bigr)^T = (R + B^TP_{t+1}B)^{-1}\)</span>。</p>
<p>由等式(17)可知</p>
<p><span class="math display">\[
P_t = Q + A^TP_{t+1}A - A^TP_{t+1}B(R + B^TP_{t+1}B)^{-1}B^TP_{t+1}A \tag{18}
\]</span></p>
<h4 id="求解过程">求解过程</h4>
<p>关于LQR的求解过程，可以采用动态规划算法，依据上述公式(18)的递归关系，反向递推，求出满足一定条件的最小代价值。</p>
<ol type="1">
<li>确定迭代范围<span class="math inline">\(N\)</span></li>
<li>设置迭代初始值<span class="math inline">\(P_N=Q_f\)</span></li>
<li>循环迭代，<span class="math inline">\(t = N,\dots,1\)</span></li>
</ol>
<p><span class="math display">\[
P_{t-1} = Q + A^TP_{t+1}A - A^TP_{t+1}B(R + B^TP_{t+1}B)^{-1}B^TP_{t+1}A
\]</span></p>
<ol start="4" type="1">
<li>则反馈系数<span class="math inline">\(K_t = -(R + B^TP_{t+1}B)^{-1}B^TP_{t+1}A\)</span>，对于时间<span class="math inline">\(t=0,\dots,N-1\)</span></li>
<li>优化的控制量<span class="math inline">\(u_t^{lqr}=K_tx_t\)</span></li>
</ol>
]]></content>
      <categories>
        <category>基础算法</category>
        <category>最优算法</category>
      </categories>
      <tags>
        <tag>LQR</tag>
        <tag>Linear quadratic regulator</tag>
        <tag>最优</tag>
      </tags>
  </entry>
  <entry>
    <title>双线性插值</title>
    <url>/2019/10/19/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%8F%8C%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>线性差值在实际应用非常广泛，比如航空航天行业中广泛用到气动数据的插值，经常会用到三线性到四线性的插值，在汽车行业很多标定数据而需要使用双线性插值，本篇文章主要讲述双线性插值的实现方式。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/yLw1Imexs68bTHc.jpg" alt="重庆博物馆" /><figcaption aria-hidden="true">重庆博物馆</figcaption>
</figure>
<span id="more"></span>
<h2 id="应用场景">应用场景</h2>
<p>本文基于车辆扭矩标定的应用场景来说明2维线性插值的具体应用，根据车辆的控制原理可知，车辆的目标加速度与当前车速和发动机输出扭矩有关，因此对车辆扭矩进行标定后，我们就可以得到一个根据当前目标加速度和车速，获得车辆输出扭矩的关系表。 如下表所示，只选取了目标加速度为正的部分标定数据，其中横向表示速度(m/s)，纵向表示加速度(m/s2)，表中的数据代表汽车扭矩输出(Nm)。由于速度只采样了[0.1,0.2,0.3,0.4,0.5,0.6,0.7]这几个数值点的数据，加速度也只采样了[0.06,0.09,0.1,0.12,0.13,0.15,0.2,0.21,0.24,0.26]这几组数据点的数据，如果想得到中间任意数值的数值，就需要使用双线性插值算法来获得。</p>
<figure>
<img data-src="https://img-blog.csdnimg.cn/20190727155601290.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnaGZvcmV2ZXI=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>如下表所示，如果当前需求的目标加速度为0.094m/s2，当前车速为0.36m/s，想得到当前输出扭矩值，按照表格所圈出的扭矩值，进行多次线性插值，求得理想的输出扭矩。</p>
<figure>
<img data-src="https://img-blog.csdnimg.cn/20190727155822629.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnaGZvcmV2ZXI=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<h3 id="双线性插值原理">双线性插值原理</h3>
<p>双线性插值算法，是在线性插值的基础上进行多次插值的结果。 如下图所示，假设插值点<span class="math inline">\({(x_i,y_i)}\)</span>的坐标点<span class="math inline">\(x_i\)</span>和<span class="math inline">\(y_i\)</span>范围满足，<span class="math inline">\(x_1\le x_i \le x_2\)</span>，<span class="math inline">\(y_1\le y_i \le y_2\)</span>，其中<span class="math inline">\((x_1,y_1)\)</span>对应数值为<span class="math inline">\(z_1\)</span>，<span class="math inline">\((x_2,y_1)\)</span>对应数值为<span class="math inline">\(z_2\)</span>，<span class="math inline">\((x_2,y_2)\)</span>对应数值为<span class="math inline">\(z_3\)</span>，<span class="math inline">\((x_1,y_2)\)</span>对应数值为<span class="math inline">\(z_4\)</span>。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190729105119489.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnaGZvcmV2ZXI=,size_16,color_FFFFFF,t_70" /></p>
<p>第一步，进行x轴方向的线性插值。当y取值<span class="math inline">\(y_1\)</span>时，进行点<span class="math inline">\((x_1,z_1)\)</span>和点<span class="math inline">\((x_2,z_2)\)</span>之间的插值，得到插值点<span class="math inline">\((x_i,z5)\)</span>；同理y取值<span class="math inline">\(y_2\)</span>时，进行点<span class="math inline">\((x_1,z_4)\)</span>和点<span class="math inline">\((x_2,z_3)\)</span>之间的插值，可得第二个插值点<span class="math inline">\((x_i,z_6)\)</span>。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190727171729916.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnaGZvcmV2ZXI=,size_16,color_FFFFFF,t_70" /></p>
<p>第二步，进行y轴方向的插值。依据新的插值点<span class="math inline">\((y_1,z5)\)</span>和<span class="math inline">\((y_2,z_6)\)</span>，进行线性插值，得到插值点<span class="math inline">\((x_i,y_i,z_7)\)</span>。此时的点<span class="math inline">\((x_i,y_i,z_7)\)</span>就是双线性插值的最终结果。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190727171818236.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnaGZvcmV2ZXI=,size_16,color_FFFFFF,t_70" /></p>
<h2 id="软件实现">软件实现</h2>
<p>本文基于c语言去实现插值算法，数据结构采用简单的数组结构，不使用C++的关联容器属性去实现数据表的存储。</p>
<h3 id="数据表的存储结构">数据表的存储结构</h3>
<p>数据结构使用三个数组进行数组的存储，其中两个数组分别存储横向的速度值和纵向的加速度值，另一个数组存储对应的扭矩值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ACC_ARRAY_NUM       ( 10 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VELOCITY_ARRAY_NUM  (  7 )</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> acc_table[ACC_ARRAY_NUM]           = &#123;<span class="number">0.06f</span>,<span class="number">0.09f</span>,<span class="number">0.1f</span>,<span class="number">0.12f</span>,<span class="number">0.13f</span>,<span class="number">0.15f</span>,<span class="number">0.2f</span>,<span class="number">0.21f</span>,<span class="number">0.24f</span>,<span class="number">0.26f</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> velocity_table[VELOCITY_ARRAY_NUM] = &#123;<span class="number">0.1f</span>,<span class="number">0.2f</span>,<span class="number">0.3f</span>,<span class="number">0.4f</span>,<span class="number">0.5f</span>,<span class="number">0.6f</span>,<span class="number">0.7f</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> torque_table[ACC_ARRAY_NUM][VELOCITY_ARRAY_NUM]=</span><br><span class="line">&#123;</span><br><span class="line">        &#123;<span class="number">60</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">50</span>,<span class="number">50</span>,<span class="number">50</span>,<span class="number">50</span>&#125;,</span><br><span class="line">        &#123;<span class="number">140</span>,<span class="number">140</span>,<span class="number">100</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">50</span>,<span class="number">50</span>&#125;,</span><br><span class="line">        &#123;<span class="number">140</span>,<span class="number">140</span>,<span class="number">120</span>,<span class="number">80</span>,<span class="number">60</span>,<span class="number">60</span>,<span class="number">60</span>&#125;,</span><br><span class="line">        &#123;<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">100</span>,<span class="number">60</span>,<span class="number">60</span>,<span class="number">60</span>&#125;,</span><br><span class="line">        &#123;<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">120</span>,<span class="number">80</span>,<span class="number">60</span>,<span class="number">60</span>&#125;,</span><br><span class="line">        &#123;<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">100</span>,<span class="number">60</span>,<span class="number">60</span>&#125;,</span><br><span class="line">        &#123;<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">120</span>,<span class="number">100</span>,<span class="number">80</span>&#125;,</span><br><span class="line">        &#123;<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">120</span>,<span class="number">100</span>&#125;,</span><br><span class="line">        &#123;<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">120</span>&#125;,</span><br><span class="line">        &#123;<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="索引id查找函数">索引ID查找函数</h3>
<p>输入参数 <strong><em>array</em></strong> ：需进行数值匹配查找的数组 输入参数 <strong><em>num</em></strong> ：数组的长度 输入参数 <strong><em>input</em></strong> ：需要匹配的值 输出参数 <strong><em>before</em></strong> ：匹配值的前数组边界ID 输出参数 <strong><em>before</em></strong> ：匹配值的后数组边界ID</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ArrayIndexFind</span><span class="params">(<span class="type">float</span> *<span class="built_in">array</span>,<span class="type">uint16_t</span> num,<span class="type">float</span> input,<span class="type">uint16_t</span> *before,<span class="type">uint16_t</span> *after)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> min_index,max_index;</span><br><span class="line">    <span class="type">uint16_t</span> middle_index;</span><br><span class="line">    min_index = <span class="number">0</span>;</span><br><span class="line">    max_index = num - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( (max_index - min_index) &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        middle_index = (min_index + max_index) / <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">if</span>(input &lt; <span class="built_in">array</span>[middle_index])</span><br><span class="line">        &#123;</span><br><span class="line">            max_index = middle_index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            min_index = middle_index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *before = min_index;</span><br><span class="line">    *after  = max_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据插值函数">数据插值函数</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">InterpolateValue</span><span class="params">(<span class="type">float</span> x,<span class="type">float</span> x0,<span class="type">float</span> y0,<span class="type">float</span> x1,<span class="type">float</span> y1)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x - x0) &lt; kDoubleEpsilon)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> y0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">fabs</span>(x - x1) &lt; kDoubleEpsilon)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> y1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> y0 + (y1 - y0)*(x - x0)/ (x1 - x0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线性差值函数">线性差值函数</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">Interpolation::InterpolationYZ</span><span class="params">(<span class="type">float</span> y,<span class="type">float</span> *y_tb,<span class="type">uint16_t</span> y_num,<span class="type">float</span> *z_tb)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> max_y = y_tb[y_num - <span class="number">1</span>];</span><br><span class="line">    <span class="type">float</span> min_y = y_tb[<span class="number">0</span>];</span><br><span class="line">    <span class="type">uint16_t</span> y_before,y_after;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(y &gt;= (max_y - kDoubleEpsilon))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> z_tb[y_num - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(y &lt;= (min_y + kDoubleEpsilon))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> z_tb[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayIndexFind(y_tb,y_num,y,&amp;y_before,&amp;y_after);</span><br><span class="line">    <span class="keyword">return</span> InterpolateValue(y,y_tb[y_before],z_tb[y_before],y_tb[y_after],z_tb[y_after]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双线性插值函数">双线性插值函数</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">Interpolation2D</span><span class="params">(<span class="type">float</span> x,<span class="type">float</span> y,<span class="type">float</span> *x_tb,<span class="type">uint16_t</span> x_num,<span class="type">float</span> *y_tb,<span class="type">uint16_t</span> y_num,<span class="type">float</span> *z_tb)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> max_x = x_tb[x_num - <span class="number">1</span>];</span><br><span class="line">    <span class="type">float</span> min_x = x_tb[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> x_before,x_after;</span><br><span class="line">    <span class="type">uint16_t</span> z_before_value,z_after_value;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; (max_x - kDoubleEpsilon))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> InterpolationYZ(y,y_tb,y_num, (z_tb + (x_num - <span class="number">1</span>)*y_num));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; (min_x + kDoubleEpsilon))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> InterpolationYZ(y,y_tb,y_num, z_tb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayIndexFind(x_tb,x_num,x,&amp;x_before,&amp;x_after);</span><br><span class="line"></span><br><span class="line">    z_before_value = InterpolationYZ(y,y_tb,y_num, (z_tb + x_before * y_num));</span><br><span class="line">    z_after_value  = InterpolationYZ(y,y_tb,y_num, (z_tb + x_after  * y_num));</span><br><span class="line">    <span class="keyword">return</span> InterpolateValue(x,x_tb[x_before],z_before_value,x_tb[x_after],z_after_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>线性插值</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最小二乘法线性拟合</title>
    <url>/2019/10/17/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95%E7%9A%84%E7%BA%BF%E6%80%A7%E6%8B%9F%E5%90%88/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>最小二乘法是曲线拟合的常用方法，使用该方法对匹配函数的选取非常重要。 <img data-src="https://i.loli.net/2021/08/30/67NEhYDHezj1PX2.jpg" alt="青岛" /></p>
<span id="more"></span>
<h2 id="理论">理论</h2>
<ol type="1">
<li>假设拟合的多项式为:</li>
</ol>
<p><span class="math display">\[
y = a_0 + a_1*x +a_2*x^2 + ...+a_m*x^m
\]</span></p>
<p>其中，<strong>m</strong>代表多项式的阶数。</p>
<ol start="2" type="1">
<li>离散点与该多项式的平方和<span class="math inline">\(F(a_0,a_1,,a_m)\)</span>为，其中<strong>n</strong>代表采样点数：</li>
</ol>
<p><span class="math display">\[
F(a_0,a_1,,a_m) = \sum_{i=0}^n[y_i - (a_0 + a_1*x_i +a_2*x_i^2 + ...+a_m*x_i^m)]^2
\]</span></p>
<ol start="3" type="1">
<li><p>最小二乘法的思想是求平方和函数<span class="math inline">\(F(a_0,a_1,,a_m)\)</span>的最小值，而对于二次方程求最小值的问题，常见的思路就是对方程求导，倒数为零的点，及为方程的极值点。</p></li>
<li><p>下面对<span class="math inline">\(F(a_0,a_1,,a_m)\)</span>分别求<span class="math inline">\(a_i\)</span>偏导数，得：</p></li>
</ol>
<p><span class="math display">\[
-2 \sum_{i=0}^n[y_i - (a_0 + a_1*x_i +a_2*x_i^2 + ...+a_m*x_i^m)] = 0 \\
-2 \sum_{i=0}^n[y_i - (a_0 + a_1*x_i +a_2*x_i^2 + ...+a_m*x_i^m)] x_i= 0\\
-2 \sum_{i=0}^n[y_i - (a_0 + a_1*x_i +a_2*x_i^2 + ...+a_m*x_i^m)] x_i^2= 0\\
\ldots\\
-2 \sum_{i=0}^n[y_i - (a_0 + a_1*x_i +a_2*x_i^2 + ...+a_m*x_i^m)] x_i^m= 0
\]</span></p>
<ol start="5" type="1">
<li>整理得</li>
</ol>
<p><span class="math display">\[
a_0\sum_{i=0}^{n}+a_1\sum_{i=0}^{n} x_i+ a_2\sum_{i=0}^{n} x_i^2+...+a_m\sum_{i=0}^{n}x_i^m = \sum_{i=0}^{n}y_i\\
a_0\sum_{i=0}^{n} x_i+a_1\sum_{i=0}^{n} x_i^2+ a_2\sum_{i=0}^{n} x_i^3+...+a_m\sum_{i=0}^{n}x_i^{m+1}  = \sum_{i=0}^{n}y_ix_i\\
\ldots\\
a_0\sum_{i=0}^{n} x_i^m+a_1\sum_{i=0}^{n} x_i^{m+1}+ a_2\sum_{i=0}^{n} x_i^{m+2}+...+a_m\sum_{i=0}^{n}x_i^{2m}  = \sum_{i=0}^{n}y_ix_i^m
\]</span></p>
<ol start="6" type="1">
<li>使用矩阵形式表示为：</li>
</ol>
<p><span class="math display">\[
\left[
\begin{matrix}
\sum_{i=0}^{n} &amp; \sum_{i=0}^{n}x_i&amp;\sum_{i=0}^{n}x_i^2&amp;\ldots&amp;\sum_{i=0}^{n}x_i^m\\
\sum_{i=0}^{n}x_i&amp;\sum_{i=0}^{n}x_i^2&amp;\sum_{i=0}^{n}x_i^3&amp;\ldots&amp;\sum_{i=0}^{n}x_i^{m+1}\\
\sum_{i=0}^{n}x_i^2&amp;\sum_{i=0}^{n}x_i^3&amp;\sum_{i=0}^{n}x_i^4&amp;\ldots&amp;\sum_{i=0}^{n}x_i^{m+2}\\
\ldots&amp;\ldots&amp;\ldots&amp;\ldots&amp;\ldots\\
\sum_{i=0}^{n}x_i^{m}&amp;\sum_{i=0}^{n}x_i^{m+1}&amp;\sum_{i=0}^{n}x_i^{m+2}&amp;\ldots&amp;\sum_{i=0}^{n}x_i^{2m}
\end{matrix}
\right] 
\left[
\begin{matrix}
a_0\\
a_1\\
a_2\\
\ldots\\
a_m
\end{matrix}
\right]=\\
\left[
\begin{matrix}
\sum_{i=0}^{n}y_i\\
\sum_{i=0}^{n}y_ix_i\\
\sum_{i=0}^{n}y_ix_i^2\\
\ldots\\
\sum_{i=0}^{n}y_ix_i^m\\
\end{matrix}
\right]
\]</span></p>
<ol start="7" type="1">
<li>下面就是求解一次线性方程，常用的方法是使用高斯消元法，也可以使用求矩阵的秩或者求解逆矩阵等方式求解。</li>
</ol>
<h2 id="高斯消元法求解线性方程">高斯消元法求解线性方程</h2>
<h3 id="原则">原则</h3>
<ul>
<li>两个方程互换解不变</li>
<li>一个方程乘以非零K,解不变</li>
<li>一个方程乘以非零K,加上另一个方程解不变</li>
</ul>
<h3 id="一阶线性函数">一阶线性函数</h3>
<p>假设多项式得阶数<strong>m</strong>为2，则上述矩阵方程为：</p>
<p><span class="math display">\[
\left[
\begin{matrix}
\sum_{i=0}^{n} &amp; \sum_{i=0}^{n}x_i\\
\sum_{i=0}^{n}x_i&amp;\sum_{i=0}^{n}x_i^2&amp;
\end{matrix}
\right] 
\left[
\begin{matrix}
a_0\\
a_1
\end{matrix}
\right]=\\
\left[
\begin{matrix}
\sum_{i=0}^{n}y_i\\
\sum_{i=0}^{n}y_ix_i
\end{matrix}
\right]
\]</span></p>
<p>写成行列式的形式为：</p>
<p><span class="math display">\[
\begin{vmatrix}
\sum_{i=0}^{n} &amp; \sum_{i=0}^{n}x_i&amp;\sum_{i=0}^{n}y_i\\
\sum_{i=0}^{n}x_i &amp; \sum_{i=0}^{n}x_i^2&amp;\sum_{i=0}^{n}y_ix_i\\
\end{vmatrix}
\]</span></p>
<p>第一行乘以系数<span class="math inline">\(\sum_{i=0}^{n}\)</span>，第二行乘以系数<span class="math inline">\(\sum_{i=0}^{n}x_i\)</span></p>
<p><span class="math display">\[
\begin{vmatrix}
1 &amp; \frac{\sum_{i=0}^{n}x_i}{\sum_{i=0}^{n}} &amp; \frac{\sum_{i=0}^{n}y_i}{\sum_{i=0}^{n}}\\
1 &amp; \frac{\sum_{i=0}^{n}x_i^2}{\sum_{i=0}^{n}x_i} &amp; \frac{\sum_{i=0}^{n}y_ix_i}{\sum_{i=0}^{n}x_i}
\end{vmatrix}
\]</span></p>
<p>第二行减去第一行得</p>
<p><span class="math display">\[
\begin{vmatrix}
1 &amp; \frac{\sum_{i=0}^{n}x_i}{\sum_{i=0}^{n}} &amp; \frac{\sum_{i=0}^{n}y_i}{\sum_{i=0}^{n}}\\
0 &amp; \frac{\sum_{i=0}^{n}x_i^2}{\sum_{i=0}^{n}x_i} -\frac{\sum_{i=0}^{n}x_i}{\sum_{i=0}^{n}} &amp; \frac{\sum_{i=0}^{n}y_ix_i}{\sum_{i=0}^{n}x_i} - \frac{\sum_{i=0}^{n}y_i}{\sum_{i=0}^{n}}
\end{vmatrix}
\]</span></p>
<p>通过上式可得<span class="math inline">\(a_1\)</span>为</p>
<p><span class="math display">\[
a_1 
= \frac{\frac{\sum_{i=0}^{n}y_ix_i}{\sum_{i=0}^{n}x_i} - \frac{\sum_{i=0}^{n}y_i}{\sum_{i=0}^{n}}}{\frac{\sum_{i=0}^{n}x_i^2}{\sum_{i=0}^{n}x_i} -\frac{\sum_{i=0}^{n}x_i}{\sum_{i=0}^{n}}}
=\frac{\sum_{i=0}^{n}y_ix_i*\sum_{i=0}^{n}-\sum_{i=0}^{n}y_i*\sum_{i=0}^{n}x_i}{\sum_{i=0}^{n}x_i^2*\sum_{i=0}^{n} - \sum_{i=0}^{n}x_i*\sum_{i=0}^{n}x_i}
\]</span></p>
<p>同理将<span class="math inline">\(a_1\)</span>回代入得：</p>
<p><span class="math display">\[
a_0 
= \frac{\sum_{i=0}^{n}y_i}{\sum_{i=0}^{n}} - \frac{(\sum_{i=0}^{n}y_ix_i*\sum_{i=0}^{n}-\sum_{i=0}^{n}y_i*\sum_{i=0}^{n}x_i)*\sum_{i=0}^{n}x_i}{(\sum_{i=0}^{n}x_i^2*\sum_{i=0}^{n} - \sum_{i=0}^{n}x_i*\sum_{i=0}^{n}x_i)*\sum_{i=0}^{n}}\\
=\frac{(\sum_{i=0}^{n}x_i^2*\sum_{i=0}^{n} - \sum_{i=0}^{n}x_i*\sum_{i=0}^{n}x_i)*\sum_{i=0}^{n}y_i -(\sum_{i=0}^{n}y_ix_i*\sum_{i=0}^{n}-\sum_{i=0}^{n}y_i*\sum_{i=0}^{n}x_i)*\sum_{i=0}^{n}x_i}{(\sum_{i=0}^{n}x_i^2*\sum_{i=0}^{n} - \sum_{i=0}^{n}x_i*\sum_{i=0}^{n}x_i)*\sum_{i=0}^{n}}\\
=\frac{\sum_{i=0}^{n}x_i^2*\sum_{i=0}^{n}\sum_{i=0}^{n}y_i -\sum_{i=0}^{n}y_ix_i*\sum_{i=0}^{n}\sum_{i=0}^{n}x_i}{(\sum_{i=0}^{n}x_i^2*\sum_{i=0}^{n} - \sum_{i=0}^{n}x_i*\sum_{i=0}^{n}x_i)*\sum_{i=0}^{n}}\\
=\frac{\sum_{i=0}^{n}x_i^2\sum_{i=0}^{n}y_i -\sum_{i=0}^{n}y_ix_i\sum_{i=0}^{n}x_i}{\sum_{i=0}^{n}x_i^2*\sum_{i=0}^{n} - \sum_{i=0}^{n}x_i*\sum_{i=0}^{n}x_i}
\]</span></p>
<p>故最终可得</p>
<p><span class="math display">\[
a_0
=\frac{\sum_{i=0}^{n}x_i^2\sum_{i=0}^{n}y_i -\sum_{i=0}^{n}y_ix_i\sum_{i=0}^{n}x_i}{\sum_{i=0}^{n}x_i^2*\sum_{i=0}^{n} - \sum_{i=0}^{n}x_i*\sum_{i=0}^{n}x_i}
\]</span></p>
<p><span class="math display">\[
a_1 
=\frac{\sum_{i=0}^{n}y_ix_i*\sum_{i=0}^{n}-\sum_{i=0}^{n}y_i*\sum_{i=0}^{n}x_i}{\sum_{i=0}^{n}x_i^2*\sum_{i=0}^{n} - \sum_{i=0}^{n}x_i*\sum_{i=0}^{n}x_i}
\]</span></p>
]]></content>
      <categories>
        <category>基础算法</category>
        <category>最优算法</category>
      </categories>
      <tags>
        <tag>最小二乘法</tag>
        <tag>C++/C</tag>
      </tags>
  </entry>
  <entry>
    <title>超声波障碍物定位_库位中心</title>
    <url>/2019/11/12/%E6%84%9F%E7%9F%A5%E7%AE%97%E6%B3%95-%E8%B6%85%E5%A3%B0%E6%B3%A2%E9%9A%9C%E7%A2%8D%E7%89%A9%E5%AE%9A%E4%BD%8D-%E5%BA%93%E4%BD%8D%E4%B8%AD%E5%BF%83/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>垂直车位的检测存在许多技术上的瓶颈，通过超声波一次性检测很难达到较高的精度，而通过车辆泊车过程中的多次的库位定位，可以有效提高车位的定位精度。本文主要介绍垂直车位情形下，车辆已经进库的情形，如何通过辆边的障碍物，重新定位库位的中心。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/sYMfyTvGl5WFk6V.jpg" alt="菊花展" /><figcaption aria-hidden="true">菊花展</figcaption>
</figure>
<span id="more"></span>
<h2 id="数据处理">数据处理</h2>
<p>超声波的数据处理，主要将冗余的数据剔除和一些无效数据滤除。下面介绍了一些实际采用的超声波数据的滤波算法。</p>
<h3 id="原始数据">原始数据</h3>
<p>如下图所示，是车辆垂直进库过程中实际采集的数据，蓝色代表车辆左侧采集到的数据，橘黄色代表车辆右侧采集的数据。从图中可以看出，原始超声数据比较杂乱，很多无效数据都记录了下来。比如未检测到超声回波的数据，首先应该把这些无效数据滤除。 <img data-src="https://img-blog.csdnimg.cn/20190522172808439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnaGZvcmV2ZXI=,size_16,color_FFFFFF,t_70" alt="原始数据" /></p>
<h3 id="第一级滤波">第一级滤波</h3>
<p>如下图所示，是超声波数据第一级滤波后的结果，第一级滤波主要滤波无效的超声波数据，包括超声无回波的数据、超声回波幅值小于阀值的数据和车辆停止采集的冗余数据。将这些无效数据滤除后，得到如下比较整洁的数据图。图中绿色数据代表车辆后轴中心的轨迹坐标。虽然经过一级滤波后数据趋势有所改善，但仍然不便于直接进行线性拟合。因为图中存在车头的弧线段和一些突变边沿数据，所以数据还需进一步的滤波。 <img data-src="https://img-blog.csdnimg.cn/20190522173940224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnaGZvcmV2ZXI=,size_16,color_FFFFFF,t_70" alt="第一级滤波" /></p>
<h3 id="第二级滤波">第二级滤波</h3>
<p>如下图所示，是超声数据进行二级滤波后的效果。从图中可以看出二级滤波后，数据更加平滑，可以进行线性拟合。二级滤波的算法，主要采用数据的分布特性，提取数据中分布集中的数据点，将分散的数据剔除，这样就可以得到平滑的车辆边沿曲线，最后采用最小二乘法拟合直线。 <img data-src="https://img-blog.csdnimg.cn/2019052217495454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnaGZvcmV2ZXI=,size_16,color_FFFFFF,t_70" alt="第二级滤波" /> 根据库位边沿拟合的两个直线，求得新的中心线所在的直线，然后根据求得的中心线与车辆轨迹的偏差去调整车辆的入库轨迹。</p>
<h2 id="软件实现">软件实现</h2>
<p>软件实现部分使用<strong>Python</strong>进行前期的算法验证，利用python具有的强大的数学运算库，可以方便地进行前期的算法验证。</p>
<h3 id="代码实现">代码实现</h3>
<h4 id="第一级滤波-1">第一级滤波</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一级滤波</span></span><br><span class="line"><span class="comment"># 滤除无效的数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ValidDataProcess</span>(<span class="params">datx,daty,level,level_threshold</span>):   </span><br><span class="line">    valid_process_x = []</span><br><span class="line">    valid_process_y = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(level)):</span><br><span class="line">        <span class="keyword">if</span> level[i] &gt; level_threshold:</span><br><span class="line">            valid_process_x.append(datx[i])</span><br><span class="line">            valid_process_y.append(daty[i])</span><br><span class="line">    <span class="keyword">return</span> valid_process_x,valid_process_y</span><br></pre></td></tr></table></figure>
<h4 id="第二级滤波-1">第二级滤波</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第二级滤波</span></span><br><span class="line"><span class="comment"># 根据数据的分布特性滤除分布比较零散的数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">FitDataProcess</span>(<span class="params">datx,daty,threshold,step</span>):</span><br><span class="line">    valid_fit_x =[]</span><br><span class="line">    valid_fit_y =[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(daty)):</span><br><span class="line">        <span class="keyword">if</span> (daty[i] &gt;= threshold) <span class="keyword">and</span> (daty[i] &lt; (threshold + step)):</span><br><span class="line">            valid_fit_x.append(datx[i])</span><br><span class="line">            valid_fit_y.append(daty[i])</span><br><span class="line">    <span class="keyword">return</span> valid_fit_x,valid_fit_y</span><br></pre></td></tr></table></figure>
<h4 id="数据分布">数据分布</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#数值分布求取函数 该进版本v2</span></span><br><span class="line"><span class="keyword">def</span>  <span class="title function_">ValueDistributed_v2</span>(<span class="params">step,dat</span>):</span><br><span class="line">    <span class="comment">#获取数值范围</span></span><br><span class="line">    value_max = <span class="built_in">max</span>(dat)</span><br><span class="line">    value_min = <span class="built_in">min</span>(dat)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;最大值:&quot;</span>,value_max)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;最小值:&quot;</span>,value_min)</span><br><span class="line">    array_cnt = <span class="built_in">int</span>((value_max - value_min)/step) + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;分组数:&quot;</span>,array_cnt)</span><br><span class="line">    </span><br><span class="line">    DistributedCnt = np.zeros(array_cnt)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dat)):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,array_cnt):</span><br><span class="line">            <span class="keyword">if</span> (dat[v] &gt;= (value_min + step * i)) <span class="keyword">and</span> (dat[v] &lt; (value_min + step * (i+<span class="number">1</span>))):</span><br><span class="line">                DistributedCnt[i] = DistributedCnt[i] + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,array_cnt):           </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;分布:&quot;</span>,i,<span class="string">&quot;，值：&quot;</span>,DistributedCnt[i])</span><br><span class="line">    list_distribute_max_cnt = DistributedCnt.tolist()</span><br><span class="line">    distribute_max_cnt = list_distribute_max_cnt.index(<span class="built_in">max</span>(list_distribute_max_cnt))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;最高分布索引:&quot;</span>,distribute_max_cnt)</span><br><span class="line">    <span class="keyword">return</span> value_min + step * distribute_max_cnt</span><br></pre></td></tr></table></figure>
<h4 id="直线拟合函数的实现">直线拟合函数的实现</h4>
<p>使用Python的Scipy库中的optimize模块，可以实现一阶线性函数的拟合，具体使用如下：</p>
<ul>
<li>定义函数形式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#直线方程函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f_1</span>(<span class="params">x, A, B</span>):</span><br><span class="line">    <span class="keyword">return</span> A*x + B</span><br></pre></td></tr></table></figure>
<ul>
<li>使用curve_fit方法实现 其中A1和B1就是所要求的系数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A1, B1 = optimize.curve_fit(f_1, valid_fit_11x, valid_fit_11y)[<span class="number">0</span>]</span><br><span class="line">x1 = np.arange(-<span class="number">7</span>,<span class="number">5</span>,<span class="number">0.1</span>)</span><br><span class="line">y1 = A1 * x1 + B1</span><br></pre></td></tr></table></figure>
<p>为了后期便于移植到C++/C平台，基于Python语言，实现了简单的直线最小二乘法拟合算法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一阶线性函数的拟合，采用最小二乘法</span></span><br><span class="line"><span class="comment"># 拟合函数形式:y = a*x +b</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">LineFit</span>(<span class="params">x,y</span>):</span><br><span class="line">    sum_x = <span class="built_in">sum</span>(x)</span><br><span class="line">    sum_y = <span class="built_in">sum</span>(y)</span><br><span class="line">    sum_xy = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)):</span><br><span class="line">        sum_xy = sum_xy + x[i]*y[i]</span><br><span class="line">    sum_x2 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)):</span><br><span class="line">        sum_x2 = sum_x2 + x[i]*x[i]</span><br><span class="line">    sum_n = <span class="built_in">len</span>(x)</span><br><span class="line">    <span class="comment"># 分母</span></span><br><span class="line">    Denominator = sum_n*sum_x2 - sum_x*sum_x</span><br><span class="line">    <span class="comment"># 分子</span></span><br><span class="line">    molecule_a = sum_n*sum_xy - sum_x*sum_y</span><br><span class="line">    molecule_b = sum_x2*sum_y - sum_x*sum_xy</span><br><span class="line">    <span class="keyword">return</span> molecule_a/Denominator,molecule_b/Denominator</span><br></pre></td></tr></table></figure>
<p>关于曲线拟合的具体内容可以参照<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnaGZvcmV2ZXIvYXJ0aWNsZS9kZXRhaWxzLzkwMjk1MDUx">最小二乘法的线性拟合<i class="fa fa-external-link-alt"></i></span>。</p>
<h4 id="最后的实现">最后的实现</h4>
<ul>
<li>使用<strong>ValidDataProcess</strong>进行一级滤波</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">valid_process_11x,valid_process_11y = ValidDataProcess(GroundLocation_x11,GroundLocation_y11,LRU11_UltrasonicLevel,level_threadhold)</span><br><span class="line">valid_process_12x,valid_process_12y = ValidDataProcess(GroundLocation_x12,GroundLocation_y12,LRU12_UltrasonicLevel,level_threadhold)  </span><br></pre></td></tr></table></figure>
<ul>
<li>使用<strong>ValueDistributed_v2</strong>函数，求取数据分布</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DistributeValue_11y = ValueDistributed_v2(<span class="number">0.05</span>,valid_process_11y)</span><br><span class="line">DistributeValue_12y = ValueDistributed_v2(<span class="number">0.05</span>,valid_process_12y)</span><br></pre></td></tr></table></figure>
<ul>
<li>根据分布特性，使用<strong>FitDataProcess</strong>进行二级滤波</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">valid_fit_11x,valid_fit_11y = FitDataProcess(valid_process_11x,valid_process_11y,DistributeValue_11y,<span class="number">0.05</span>)</span><br><span class="line">valid_fit_12x,valid_fit_12y = FitDataProcess(valid_process_12x,valid_process_12y,DistributeValue_12y,<span class="number">0.05</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>使用二级滤波的数据，进行线性拟合，求得直线方程</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A1, B1 = LineFit(valid_fit_11x, valid_fit_11y)</span><br><span class="line">A2, B2 = LineFit(valid_fit_12x, valid_fit_12y)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>超声波</tag>
        <tag>感知算法</tag>
        <tag>障碍物定位</tag>
        <tag>库位中心</tag>
      </tags>
  </entry>
  <entry>
    <title>超声波障碍物定位-库位角点</title>
    <url>/2019/11/11/%E6%84%9F%E7%9F%A5%E7%AE%97%E6%B3%95-%E8%B6%85%E5%A3%B0%E6%B3%A2%E9%9A%9C%E7%A2%8D%E7%89%A9%E5%AE%9A%E4%BD%8D-%E5%BA%93%E4%BD%8D%E8%A7%92%E7%82%B9/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>基于纯超声的垂直车位检测存在一些技术瓶颈，比如超声波的更新频率较低、探测开角较大等，都是影响检测精度的关键因素。另外对于垂直车位，车辆头部情况复杂、存在各种结构的进气栅格、引擎盖的高度不一等，增大了超声检测的难度。基于上述传感器本身性能限制和探测环境的复杂性，一次性精确检测很难实现，目前常规算法检测精度大概在30cm左右。为了进一步提升超声波检测的精度，利用车辆泊车过程中的检测的超声数据，重新进行库位的定位。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/eSXfcn2BYoTNR4K.jpg" alt="世纪公园" /><figcaption aria-hidden="true">世纪公园</figcaption>
</figure>
<span id="more"></span>
<h2 id="超声重定位">超声重定位</h2>
<p>首先车辆先通过超声波传感器确定车位的大概位置，然后规划车辆进行倒车入库，在入库的过程中，进行前车车头边沿的重新检测，并通过尾部超声波进行后车的检测，当车辆离后车距离达到30~40cm时，车辆停止。通过后置的短距超声波，使用三角定位算法实现，进行后车边沿数据的采集。等待数据量足够时，一般可以设定50个数据点左右。停止超声数据的推送，开始进行边沿算法的计算，从而实现垂直车位的二次定位。</p>
<p><img data-src="https://i.loli.net/2021/08/30/mC9TIKJhZdqGfMB.png" /></p>
<h3 id="数据滤波">数据滤波</h3>
<h4 id="状态滤波">状态滤波</h4>
<p>传感器本身会输出一些状态信号，如噪声干扰、硬件故障、盲区、振玲故障、通信故障和正常等状态。可以通过传感器输出的这些状态信号进行数据的一级滤波，只保留状态输出为正常的信号。</p>
<h4 id="幅值滤波">幅值滤波</h4>
<p>超声波的<strong>Level</strong>值反应了声波的回波强度，因此可以使用回波强度的大小，去滤除一部分无效信号，比如回波为0值数据。这些数据反应了未探测到障碍物，或者是障碍物的特殊结构反射了声波，特殊的材料吸收了声波。 比如某些车型的车头设计有很大的进气栅格，这种结构就会减少反射声波的强度，从而导致强度降低。</p>
<p><img data-src="https://i.loli.net/2021/08/30/OVlckaCFD34UqPY.png" alt="幅值滤波" style="zoom: 80%;" /></p>
<p>当超声波探测到车辆边沿时，此时由于很多回波反射方向变化，所以传感器接收到的强度变低。</p>
<p><img data-src="https://i.loli.net/2021/08/30/M9wzFi37mrlEYku.png" style="zoom:80%;" /></p>
<p>通过一系列的滤波操作，可以得出以下图形。其中蓝色是滤波前的原始数据，黄色是滤波后的数据。可以从下图看出，通过滤波操作可以滤除一些无效信号点。 <img data-src="https://img-blog.csdnimg.cn/20190513171545723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnaGZvcmV2ZXI=,size_16,color_FFFFFF,t_70" alt=""  /></p>
<hr />
<h3 id="边沿检测">边沿检测</h3>
<p>对原始数据进行处理后，可以得到一组有效的超声信号，基于这组数据，可以进行车辆边沿的检测。</p>
<h4 id="距离疏密程度">距离疏密程度</h4>
<p>由于所有的坐标点都已经转化到了地面坐标系下，所以只需要进行x方向的疏密度分析。从下图可知，在车辆边沿处，点比较稀疏，有的地方存在很长一段距离无数据点。这种情况一般是车头处存在镂空的结构，或者声波发生了散射，导致声波强度减小。所以在确定车辆边沿点时，需设置一个疏密距离阀值，当距离值大于阀值时，才认为该点是边界的跳变点。 <img data-src="https://img-blog.csdnimg.cn/20190513192450664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnaGZvcmV2ZXI=,size_16,color_FFFFFF,t_70" /></p>
<h3 id="数据分布">数据分布</h3>
<p>对于后车的边沿定位，使用的是车辆后方的短距传感器，该传感器使用三角定位原理，确定后车边沿的坐标值。可以从图中看出，图片左侧数据点描绘的是后车的边沿，可以通过数据的分布情况，及集中程度，确定最有可能车辆边沿的值。 <img data-src="https://img-blog.csdnimg.cn/20190513194816201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnaGZvcmV2ZXI=,size_16,color_FFFFFF,t_70" /> 如下图所示，是对上图x轴做了数值分布分析，可以看出，大部分点的x轴坐标都分布于区域5中，所以最后取区域5中的点作为可信的坐标点。 <img data-src="https://img-blog.csdnimg.cn/20190513201643149.PNG#pic_center" /></p>
<h2 id="结论">结论</h2>
<p>库位角点定位算法适合泊车过程中的库位坐标重定位，方便在泊车过程中更新库位坐标。</p>
]]></content>
      <categories>
        <category>感知算法</category>
        <category>超声波</category>
      </categories>
      <tags>
        <tag>超声波</tag>
        <tag>感知算法</tag>
        <tag>障碍物定位</tag>
        <tag>库位角点</tag>
      </tags>
  </entry>
  <entry>
    <title>霍夫变换-OpenCV源码分析</title>
    <url>/2019/10/20/%E6%84%9F%E7%9F%A5%E7%AE%97%E6%B3%95-%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2(Hough)-OpenCV%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>霍夫变换算法主要用于图像中的特征匹配，常见的应用场景是进行图像中的直线或者圆形的识别。该算法的原理就是实现笛卡尔空间到霍夫空间的转换，将在笛卡尔空间下难以判定的特性，转到霍夫空间，从而将问题简化。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/hyaDQrwBu37YFfJ.jpg" alt="世纪公园" /><figcaption aria-hidden="true">世纪公园</figcaption>
</figure>
<span id="more"></span>
<h2 id="分析">分析</h2>
<h3 id="建立三角函数查找表">建立三角函数查找表</h3>
<p>为了避免三角函数的反复计算，根据离散后的角度信息，提前计算出所需的三角函数值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">createTrigTable</span><span class="params">( <span class="type">int</span> numangle, <span class="type">double</span> min_theta, <span class="type">double</span> theta_step,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">float</span> irho, <span class="type">float</span> *tabSin, <span class="type">float</span> *tabCos )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> ang = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(min_theta);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n = <span class="number">0</span>; n &lt; numangle; ang += (<span class="type">float</span>)theta_step, n++ )</span><br><span class="line">    &#123;</span><br><span class="line">        tabSin[n] = (<span class="type">float</span>)(<span class="built_in">sin</span>((<span class="type">double</span>)ang) * irho);</span><br><span class="line">        tabCos[n] = (<span class="type">float</span>)(<span class="built_in">cos</span>((<span class="type">double</span>)ang) * irho);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="计算离散点数">计算离散点数</h3>
<p>根据极经和极角的步长，极经和极角的范围，计算离散点数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> numangle = <span class="built_in">cvRound</span>((max_theta - min_theta) / theta);</span><br><span class="line"><span class="type">int</span> numrho = <span class="built_in">cvRound</span>(((max_rho - min_rho) + <span class="number">1</span>) / rho);</span><br></pre></td></tr></table></figure>
<h3 id="填充累加器">填充累加器</h3>
<p>计算图像中每个像素点的霍夫变换，其中极角<span class="math inline">\(\theta\)</span>按照离散化的点采样，计算极经值<code>rho</code>，并更新对应的累加器<code>accum</code>的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stage 1. fill accumulator</span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; height; i++ )</span><br><span class="line">    <span class="keyword">for</span>( j = <span class="number">0</span>; j &lt; width; j++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( image[i * step + j] != <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> n = <span class="number">0</span>; n &lt; numangle; n++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> r = <span class="built_in">cvRound</span>( j * tabCos[n] + i * tabSin[n] );</span><br><span class="line">                r += (numrho - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                accum[(n+<span class="number">1</span>) * (numrho+<span class="number">2</span>) + r+<span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找局部极大值">查找局部极大值</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">findLocalMaximums</span><span class="params">( <span class="type">int</span> numrho, <span class="type">int</span> numangle, <span class="type">int</span> threshold,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">const</span> <span class="type">int</span> *accum, std::vector&lt;<span class="type">int</span>&gt;&amp; sort_buf )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> r = <span class="number">0</span>; r &lt; numrho; r++ )</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n = <span class="number">0</span>; n &lt; numangle; n++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> base = (n+<span class="number">1</span>) * (numrho+<span class="number">2</span>) + r+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>( accum[base] &gt; threshold &amp;&amp;</span><br><span class="line">                accum[base] &gt; accum[base - <span class="number">1</span>] &amp;&amp; accum[base] &gt;= accum[base + <span class="number">1</span>] &amp;&amp;</span><br><span class="line">                accum[base] &gt; accum[base - numrho - <span class="number">2</span>] &amp;&amp; accum[base] &gt;= accum[base + numrho + <span class="number">2</span>] )</span><br><span class="line">                sort_buf.<span class="built_in">push_back</span>(base);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="排序">排序</h3>
<p>对累加器内部的数据进行排序，由大到小进行排序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stage 3. sort the detected lines by accumulator value</span></span><br><span class="line">std::<span class="built_in">sort</span>(_sort_buf.<span class="built_in">begin</span>(), _sort_buf.<span class="built_in">end</span>(), <span class="built_in">hough_cmp_gt</span>(accum));</span><br></pre></td></tr></table></figure>
<h3 id="输出直线">输出直线</h3>
<p>根据设定的最小直线数量和实际缓存的直线数量，求取最小的直线数。根据直线数从排过序的缓存中取最大的几组数据，并将这些数据转换成直线参数存储。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stage 4. store the first min(total,linesMax) lines to the output buffer</span></span><br><span class="line">linesMax = std::<span class="built_in">min</span>(linesMax, (<span class="type">int</span>)_sort_buf.<span class="built_in">size</span>());</span><br><span class="line"><span class="type">double</span> scale = <span class="number">1.</span>/(numrho+<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">lines.<span class="built_in">create</span>(linesMax, <span class="number">1</span>, type);</span><br><span class="line">Mat _lines = lines.<span class="built_in">getMat</span>();</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; linesMax; i++ )</span><br><span class="line">&#123;</span><br><span class="line">    LinePolar line;</span><br><span class="line">    <span class="type">int</span> idx = _sort_buf[i];</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">cvFloor</span>(idx*scale) - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> r = idx - (n+<span class="number">1</span>)*(numrho+<span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">    line.rho = (r - (numrho - <span class="number">1</span>)*<span class="number">0.5f</span>) * rho;</span><br><span class="line">    line.angle = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(min_theta) + n * theta;</span><br><span class="line">    <span class="keyword">if</span> (type == CV_32FC2)</span><br><span class="line">    &#123;</span><br><span class="line">        _lines.<span class="built_in">at</span>&lt;Vec2f&gt;(i) = <span class="built_in">Vec2f</span>(line.rho, line.angle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CV_DbgAssert</span>(type == CV_32FC3);</span><br><span class="line">        _lines.<span class="built_in">at</span>&lt;Vec3f&gt;(i) = <span class="built_in">Vec3f</span>(line.rho, line.angle, (<span class="type">float</span>)accum[idx]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<ol type="1">
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29wZW5jdi9vcGVuY3YvYmxvYi80LjEuMS9tb2R1bGVzL2ltZ3Byb2Mvc3JjL2hvdWdoLmNwcA==">GitHub源码<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9wZW5jdi5vcmcvNC4xLjEvZGQvZDFhL2dyb3VwX19pbWdwcm9jX19mZWF0dXJlLmh0bWwjZ2E0NmI0ZTU4ODkzNGY2YzhkZmQ1MDljYzZlMGU0NTQ1YQ==">文档说明<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>感知算法</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
        <tag>霍夫变换</tag>
      </tags>
  </entry>
  <entry>
    <title>控制算法-Stanley法</title>
    <url>/2020/02/23/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-Stanley%E6%B3%95/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>本文主要介绍Stanley方法的推导，该方法也称为前轮位置反馈。该方法基于车辆几何关系，算法简单，适合低速下的车辆路劲跟踪。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/hk7PBu8asVmbpox.jpg" alt="扬州廋西湖" /><figcaption aria-hidden="true">扬州廋西湖</figcaption>
</figure>
<span id="more"></span>
<h2 id="stanley方法">Stanley方法</h2>
<p><img data-src="https://i.loli.net/2021/08/30/kVdqQai6KhGrelT.png" style="zoom:80%;" /></p>
<p>Stanley方法是一种基于航迹误差<span class="math inline">\(e_{f}\)</span>的非线性反馈函数,该航向误差是车辆前轴中心点与目标路径最近点<span class="math inline">\((c_x,c_y)\)</span>的距离。由上图几何关系得</p>
<p><span class="math display">\[
\psi_e = \psi - \psi_{t} \tag{1}
\]</span></p>
<p>其中，<span class="math inline">\(\psi\)</span>表示车辆横向角，<span class="math inline">\(\psi_{t}\)</span>表示离车辆前轴中心最近目标路径点处的航向角。</p>
<p>前轮速度轴与目标路径航向之间的夹角<span class="math inline">\(\beta\)</span>为</p>
<p><span class="math display">\[
\beta = \arcsin(\frac{k\cdot e_{f}}{v_x}) \tag{2}
\]</span></p>
<p>但是在论文中都是使用反正切函数求<span class="math inline">\(\beta\)</span>角，可能原因是系数<span class="math inline">\(k\)</span>可以任意选择，选择可是的系数<span class="math inline">\(k\)</span>，确实可以转化为</p>
<p><span class="math display">\[
\beta = \arctan(\frac{k\cdot e_{f}}{v_x}) \tag{3}
\]</span></p>
<p>结合等式(1)和(3)得</p>
<p><span class="math display">\[
\begin{array}{cl}
\delta &amp;= \psi_e + \beta \\
&amp;= \psi - \psi_{t} +  \arctan(\dfrac{k\cdot e_{f}}{v_x})
\end{array}\tag{4}
\]</span></p>
]]></content>
      <categories>
        <category>控制算法</category>
        <category>路径跟踪</category>
      </categories>
      <tags>
        <tag>前轴反馈</tag>
        <tag>路径跟踪</tag>
        <tag>控制算法</tag>
      </tags>
  </entry>
  <entry>
    <title>控制算法-动力学模型</title>
    <url>/2019/12/02/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-%E5%8A%A8%E5%8A%9B%E5%AD%A6%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>当车辆速度很高时，单车模型中前后轮的速度矢量不再与轮子方向一致。此时运动学模型就不能准确地描述车辆的运动状态，这就需要使用动力学模型对车辆进行建模。车辆单车模型中需要考虑两个维度的信息，这两个维度分别指代表车辆横向位置信息的<span class="math inline">\(y\)</span>和表示车辆偏航角信息的<span class="math inline">\(\psi\)</span>。下面分析过程中，先不考虑路堤角度的影响。 <img data-src="https://i.loli.net/2021/08/30/fQ7RUE9SO6ADnXN.jpg" alt="菊花展" /></p>
<span id="more"></span>
<h2 id="受力分析">受力分析</h2>
<h3 id="平动">平动</h3>
<p>首先假设车辆为一个质点，对该质点进行受力分析，并根据牛顿第二定律得</p>
<p><span class="math display">\[
ma_y = F_{yf}+F_{yr} \tag{1}
\]</span></p>
<p>其中，<span class="math inline">\(a_y\)</span>为车辆重心处<span class="math inline">\(y\)</span>轴方向的惯性加速度，<span class="math inline">\(F_{yf}\)</span>和<span class="math inline">\(F_{yr}\)</span>为前后轮横向受到的力。平动过程中，有两种力共同作用于加速度<span class="math inline">\(a_y\)</span>：车辆延<span class="math inline">\(y\)</span>轴产生的惯性加速度<span class="math inline">\(\ddot{y}\)</span>和车辆绕旋转中心<span class="math inline">\(O\)</span>旋转产生的向心加速度<span class="math inline">\(a_c=V_x\dot{\psi}\)</span>。</p>
<p><span class="math display">\[
a_y = \ddot{y} + V_x\dot{\psi} \tag{2}
\]</span></p>
<p>将公式(2)带入公式(1)得</p>
<p><span class="math display">\[
m(\ddot{y} + V_x\dot{\psi}) = F_{yf}+F_{yr} \tag{3}
\]</span></p>
<h3 id="转动">转动</h3>
<p>假设车辆为刚体，刚体绕重心转动，该运动过程使用力矩和转动惯量进行描述。 车辆绕z轴旋转产生的力矩平衡，对应的偏航动力学方程为</p>
<p><span class="math display">\[
I_z\ddot{\psi} = l_fF_{yf} - l_rF_{yr} \tag{4}
\]</span></p>
<p>其中，<span class="math inline">\(l_f\)</span>和<span class="math inline">\(l_r\)</span>代表前后轮胎到重心的距离。</p>
<h3 id="受力计算">受力计算</h3>
<p>上述等式(3)和(4)中都用到了轮胎横向受力情况<span class="math inline">\(F_{yf}\)</span>和<span class="math inline">\(F_{yr}\)</span>，根据实验结果知，轮胎的横向力与小的滑移角存在正比例的关系,滑移角是轮胎方向与车轮速度矢量之间的夹角。</p>
<p><img data-src="https://i.loli.net/2021/08/30/zaCvGEqUsRDNJ8X.png" style="zoom: 67%;" /></p>
<p>根据上图可知 <span class="math display">\[
\alpha_f = \delta - \theta_{Vf} \tag{5}
\]</span></p>
<p>其中，<span class="math inline">\(\theta_{Vf}\)</span>代表速度矢量与车辆纵轴的夹角，<span class="math inline">\(\delta\)</span>代表前轮转向角。 同理，由于后轮转向角<span class="math inline">\(\delta\)</span>为0，故后轮滑移角为</p>
<p><span class="math display">\[
\alpha_r = -\theta_{Vr} \tag{6}
\]</span></p>
<p>车辆前轮的横向力可以表示为</p>
<p><span class="math display">\[
F_{yf} = 2C_{\alpha f}(\delta - \theta_{Vf} ) \tag{7}
\]</span></p>
<p>其中，比例常数<span class="math inline">\(C_{\alpha f}\)</span>代表每个前轮的侧偏刚度。</p>
<p>同理后轮的横向力可以写为</p>
<p><span class="math display">\[
F_{yr} = 2C_{\alpha r}(-\theta_{Vr}) \tag{8}
\]</span></p>
<p>其中，比例常数<span class="math inline">\(C_{\alpha r}\)</span>代表每个后轮的侧偏刚度。</p>
<h3 id="速度方向">速度方向</h3>
<p><img data-src="https://i.loli.net/2021/08/30/qBMO6K81ZVT2QNt.png" /></p>
<p>车辆平动产生的速度分量<span class="math inline">\(V_x\)</span>和<span class="math inline">\(V_y\)</span>，以及绕点<span class="math inline">\(C\)</span>转动产生的线速度<span class="math inline">\(l_f\dot{\psi}\)</span>和<span class="math inline">\(l_r\dot{\psi}\)</span>组成。根据上图得</p>
<p><span class="math display">\[
\tan(\theta_{Vf})=\frac{V_y + l_f\dot{\psi}}{V_x} \tag{9}
\]</span></p>
<p><span class="math display">\[
\tan(\theta_{Vr})=\frac{V_y - l_r\dot{\psi}}{V_x} \tag{10}
\]</span></p>
<p>由于通常情况下速度矢量的夹角很小，可以使用小角度近似原理得 <span class="math display">\[
\theta_{Vf}=\frac{\dot{y} + l_f\dot{\psi}}{V_x} \tag{11}
\]</span></p>
<p><span class="math display">\[
\theta_{Vr}=\frac{\dot{y} - l_r\dot{\psi}}{V_x} \tag{12}
\]</span></p>
<h2 id="微分方程">微分方程</h2>
<p>将等式(7)、(8)、(9)和(10)代入等式(3)中得</p>
<p><span class="math display">\[
m(\ddot{y} + V_x\dot{\psi}) = 2C_{\alpha f}(\delta - \frac{\dot{y} + l_f\dot{\psi}}{V_x} ) +2C_{\alpha r}(-\frac{\dot{y} - l_r\dot{\psi}}{V_x}) \tag{13}
\]</span></p>
<p>等式(13)左右两边同时除以<span class="math inline">\(m\)</span>，分别提取 <span class="math inline">\(\ddot{y}\)</span>、<span class="math inline">\(\dot{y}\)</span>、<span class="math inline">\(\dot{\psi}\)</span>和<span class="math inline">\(\delta\)</span>项得</p>
<p><span class="math display">\[
\ddot{y} = -\frac{2C_{\alpha f } + 2C_{\alpha r}}{mV_x}\dot{y}   - ( V_x +  \frac{2C_{\alpha f}l_f- 2C_{\alpha r}l_r}{mV_x})\dot{\psi}  + \frac{2C_{\alpha f}}{m} \delta \tag{14}
\]</span></p>
<p>转化为矩阵形式如下</p>
<p><span class="math display">\[
\frac{\mathrm{d}}{\mathrm{d}t} \dot{y} =
\begin{bmatrix}
0 &amp; -\dfrac{2C_{\alpha f } + 2C_{\alpha r}}{mV_x} &amp; 0 &amp; - ( V_x +  \dfrac{2C_{\alpha f}l_f- 2C_{\alpha r}l_r}{mV_x})
\end{bmatrix}
 \begin{bmatrix}
y\\
\dot{y}\\
\psi\\
\dot{\psi}
\end{bmatrix} + \frac{2C_{\alpha f}}{m}\delta \tag{15}
\]</span></p>
<p>同理，将等式(7)、(8)、(9)和(10)代入等式(4)中得</p>
<p><span class="math display">\[
I_z\ddot{\psi} = 2l_fC_{\alpha f}(\delta - \frac{\dot{y} + l_f\dot{\psi}}{V_x} )  - 2l_rC_{\alpha r}(-\frac{\dot{y} - l_r\dot{\psi}}{V_x}) \tag{16}
\]</span></p>
<p>等式(13)左右两边同时除以<span class="math inline">\(I_z\)</span>，分别提取<span class="math inline">\(\dot{y}\)</span>、 <span class="math inline">\(\ddot{\psi}\)</span>、<span class="math inline">\(\dot{\psi}\)</span>和<span class="math inline">\(\delta\)</span>项得</p>
<p><span class="math display">\[
\ddot{\psi} = - \frac{2l_fC_{\alpha f} - 2l_rC_{\alpha r}}{I_zV_x}\dot{y}  - \frac{2{l_f}^2C_{\alpha f} + 2{l_r}^2C_{\alpha r}}{I_zV_x}\dot{\psi} + \frac{2l_fC_{\alpha f}}{I_z}\delta\tag{17}
\]</span></p>
<p>等效的矩阵形式为</p>
<p><span class="math display">\[
\frac{\mathrm{d}}{\mathrm{d}t} \dot{\psi} = 
\begin{bmatrix}
0 &amp; - \dfrac{2l_fC_{\alpha f} - 2l_rC_{\alpha r}}{I_zV_x} &amp; 0 &amp; -\dfrac{2{l_f}^2C_{\alpha f} + 2{l_r}^2C_{\alpha r}}{I_zV_x}
\end{bmatrix}
 \begin{bmatrix}
y\\
\dot{y}\\
\psi\\
\dot{\psi}
\end{bmatrix} + \frac{2l_fC_{\alpha f}}{I_z}\delta \tag{18}
\]</span></p>
<p>根据等式(15)和(18)得</p>
<p><span class="math display">\[
\frac{\mathrm{d}}{\mathrm{d}t}\left \{ \begin{array}{cccc}
y\\
\dot{y}\\
\psi\\
\dot{\psi}
\end{array} \right\} =  
\begin{bmatrix}
0 &amp; 1 &amp; 0 &amp; 0\\
0 &amp; -\dfrac{2C_{\alpha f } + 2C_{\alpha r}}{mV_x} &amp; 0 &amp; - ( V_x +  \dfrac{2C_{\alpha f}l_f- 2C_{\alpha r}l_r}{mV_x})\\
0 &amp; 0 &amp; 0 &amp; 1\\
0 &amp; - \dfrac{2l_fC_{\alpha f} - 2l_rC_{\alpha r}}{I_zV_x} &amp; 0 &amp; -\dfrac{2{l_f}^2C_{\alpha f} + 2{l_r}^2C_{\alpha r}}{I_zV_x}
\end{bmatrix}
\begin{bmatrix}
y\\
\dot{y}\\
\psi\\
\dot{\psi}
\end{bmatrix}\\+
\begin{bmatrix}
0\\
\dfrac{2C_{\alpha f}}{m}\\
0\\
 \dfrac{2l_fC_{\alpha f}}{I_z}
\end{bmatrix}\delta \tag{19}
\]</span></p>
<ul>
<li>注意：上述动力学方程的推导建立在车辆滑移角很小的情况下，这时的轮胎作用力与滑移角可以近似为线性关系。当滑移角很大时，轮胎作用力与滑移角就不再是线性关系。</li>
</ul>
<h2 id="参考">参考</h2>
<ol type="1">
<li>“vehicle dynamics and control”</li>
</ol>
]]></content>
      <categories>
        <category>控制算法</category>
        <category>车辆模型</category>
      </categories>
      <tags>
        <tag>动力学</tag>
        <tag>车辆模型</tag>
        <tag>dynamics model</tag>
        <tag>车辆控制</tag>
      </tags>
  </entry>
  <entry>
    <title>直线特征提取</title>
    <url>/2019/11/22/%E6%84%9F%E7%9F%A5%E7%AE%97%E6%B3%95-%E7%9B%B4%E7%BA%BF%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/</url>
    <content><![CDATA[<h2 id="问题概述">问题概述</h2>
<p>常见的直线特征提取算法是最小二乘法进行的直线拟合，但是线性二次拟合的效果容易受噪声影响，导致拟合效果较差。本文基于直线方程的另一种形式，详细给出最优直线的推导过程。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/Q7SMVU8LzrANGlv.jpg" alt="菊花展" /><figcaption aria-hidden="true">菊花展</figcaption>
</figure>
<span id="more"></span>
<p>直线方程可以表示为</p>
<p><span class="math display">\[
r = \cos\theta*x + \sin\theta*y
\]</span></p>
<p>几何关系如下图所示</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/qEJyiMoPC2jwhLn.gif" alt="几何关系" /><figcaption aria-hidden="true">几何关系</figcaption>
</figure>
<p>假设一组数据集合为</p>
<p><span class="math display">\[
S_k= \{ (x_0,y_0),...,(x_k,y_k)\}
\]</span></p>
<p>该数据集符合直线分布，那么满足<span class="math inline">\(S_k\)</span>数据的最优直线<span class="math inline">\(L\)</span>为</p>
<p><span class="math display">\[
r = \cos\theta*x + \sin\theta*y \tag{1}
\]</span></p>
<p>这组数据集与直线<span class="math inline">\(L\)</span>的误差值为</p>
<p><span class="math display">\[
e_i = \| \cos\theta*x_i + \sin\theta*y_i - r\| \tag{2}
\]</span></p>
<p>方差值为</p>
<p><span class="math display">\[
E_2 =\sum_{S_k}e_i^2 \tag{3}
\]</span></p>
<p>那么求取与数据点<span class="math inline">\(S_k\)</span>匹配度最优的线段<span class="math inline">\(L\)</span>问题,就可以转化为求取方差<span class="math inline">\(E_2\)</span>的最小值问题。</p>
<h2 id="最值求解过程推导">最值求解过程推导</h2>
<h3 id="函数定义">函数定义</h3>
<p>根据最值原理，求最小值的问题，可以转化为求解函数导数为零的解的问题。 假设函数</p>
<p><span class="math display">\[
f(\theta,r) = \sum_{S_k}(\cos\theta*x_i + \sin\theta*y_i - r)^2 \tag{4}
\]</span></p>
<p>导数为</p>
<p><span class="math display">\[
\dot{f}(\theta,r) = 2\sum_{S_k}(\cos\theta*x_i + \sin\theta*y_i - r)&#39; \tag{5}
\]</span></p>
<p>根据函数参数 <span class="math inline">\(\theta\)</span> 和 <span class="math inline">\(r\)</span>，分别对其求偏导数得</p>
<p><span class="math display">\[
\dot{f}(\theta,r) = \frac{\partial f}{\partial \theta} + \frac{\partial f}{\partial r} \tag{6}
\]</span></p>
<p>故得</p>
<p><span class="math display">\[
\dot{f}(\theta,r) = 2\sum_{S_k}(\cos\theta*x_i + \sin\theta*y_i - r)(\cos\theta*y_i - \sin\theta*x_i -1) \tag{7}
\]</span></p>
<p>当 <span class="math inline">\(\dot{f}(\theta,r)= 0\)</span>得</p>
<p><span class="math display">\[
\sum_{S_k}(\cos\theta*x_i + \sin\theta*y_i - r)(\cos\theta*y_i - \sin\theta*x_i -1) = 0 \tag{8}
\]</span></p>
<h3 id="求解假设">求解假设</h3>
<p>假设</p>
<p><span class="math display">\[
\begin{array}{r}
\sum_{S_k}\cos\theta*x_i + \sin\theta*y_i - r = 0 \\
\cos\theta\sum_{i_0}^kx_i + \sin\theta\sum_{i_0}^ky_i - \sum_{i_0}^kr = 0 \tag{9}
\end{array}
\]</span></p>
<p>由上述得</p>
<p><span class="math display">\[
\begin{array}{l}
\sum_{i=0}^{k}r &amp;= \cos\theta\sum_{i=0}^kx_i + \sin\theta\sum_{i=0}^ky_i \\
 r &amp;= \cos\theta\frac{\sum_{i=0}^kx_i}{k} + \sin\theta\frac{\sum_{i=0}^ky_i}{k} \tag{10}
\end{array}
\]</span></p>
<p>令</p>
<p><span class="math display">\[
\begin{array}{l}
V_x = \frac{\sum_{i=0}^kx_i}{k} \\
V_y = \frac{\sum_{i=0}^ky_i}{k} \tag{11}
\end{array}
\]</span></p>
<p>上述公式可以表述为</p>
<p><span class="math display">\[
r = \cos\theta*V_x + \sin\theta*V_y \tag{12}
\]</span></p>
<h3 id="函数导数化简">函数导数化简</h3>
<p>由公式(8)得</p>
<p><span class="math display">\[
\sum_{i=0}^{k}(\cos\theta*x_i + \sin\theta*y_i)(\cos\theta*y_i - \sin\theta*x_i) -\sum_{i=0}^{k}(\cos\theta*x_i + \sin\theta*y_i)- 
\sum_{i=0}^{k}r(\cos\theta*y_i - \sin\theta*x_i) + \sum_{i=0}^{k}r = 0 \tag{13}
\]</span></p>
<p>将等式(12)带入等式(13),并将等式分解为一下4个部分</p>
<p><span class="math display">\[
\begin{array}{l}
A = \sum_{i=0}^{k}\cos^2\theta*x_iy_i - \sin\theta\cos\theta*x_i^2 + \sin\theta\cos\theta*y_i^2 -\sin^2\theta*x_iy_i \\
B = \sum_{i=0}^{k}(\cos\theta*x_i + \sin\theta*y_i) \\
C = \sum_{i=0}^{k}(\cos\theta*V_x + \sin\theta*V_y)(\cos\theta*y_i - \sin\theta*x_i) \\
D = \sum_{i=0}^{k}(\cos\theta*V_x + \sin\theta*V_y) \tag{14}
\end{array}
\]</span></p>
<p>等式(14)的四个部分可化简为</p>
<ul>
<li><strong>A</strong></li>
</ul>
<p><span class="math display">\[
\begin{array}{l}
A = \sum_{i=0}^{k}\cos^2\theta*x_iy_i - \sin\theta\cos\theta*x_i^2 + \sin\theta\cos\theta*y_i^2 -\sin^2\theta*x_iy_i\\
\quad = (\cos^2\theta - \sin^2\theta)\sum_{i=0}^{k}x_iy_i - \sin\theta\cos\theta(\sum_{i=0}^{k}x_i^2 - \sum_{i=0}^{k}y_i^2)\\
\quad = \cos2\theta\sum_{i=0}^{k}x_iy_i - 0.5\sin2\theta(\sum_{i=0}^{k}x_i^2 - \sum_{i=0}^{k}y_i^2) \tag{15}
\end{array}
\]</span></p>
<ul>
<li><strong>B</strong></li>
</ul>
<p><span class="math display">\[
\begin{array}{l}
B = \sum_{i=0}^{k}(\cos\theta*x_i + \sin\theta*y_i) \\
\quad = \cos\theta\sum_{i=0}^{k}x_i + \sin\theta\sum_{i=0}^{k}y_i \tag{16}
\end{array}
\]</span></p>
<ul>
<li><strong>C</strong></li>
</ul>
<p><span class="math display">\[
\begin{array}{l}
C = \sum_{i=0}^{k}(\cos\theta*V_x + \sin\theta*V_y)(\cos\theta*y_i - \sin\theta*x_i) \\
\quad =\cos^2\theta*V_x\sum_{i=0}^{k}y_i - \sin\theta\cos\theta*V_x\sum_{i=0}^{k}x_i+\sin\theta\cos\theta*V_y\sum_{i=0}^{k}y_i -\sin^2\theta*V_y\sum_{i=0}^{k}x_i\\
\quad =(\cos^2\theta - \sin^2\theta)\frac{\sum_{i=0}^{k}x_i\sum_{i=0}^{k}y_i}{k} - \sin\theta\cos\theta(V_x\sum_{i=0}^{k}x_i - V_y\sum_{i=0}^{k}y_i)\\
\quad =\cos2\theta\frac{\sum_{i=0}^{k}x_i\sum_{i=0}^{k}y_i}{k} - 0.5\sin2\theta(V_x\sum_{i=0}^{k}x_i - V_y\sum_{i=0}^{k}y_i)\tag{17}
\end{array}
\]</span></p>
<ul>
<li><strong>D</strong></li>
</ul>
<p><span class="math display">\[
\begin{array}{l}
D = \sum_{i=0}^{k}(\cos\theta*V_x + \sin\theta*V_y) \\
\quad =\cos\theta*V_x\sum_{i=0}^{k} + \sin\theta*V_y\sum_{i=0}^{k} \\
\quad =\cos\theta\sum_{i=0}^{k}x_i + \sin\theta\sum_{i=0}^{k}y_i \tag{18}
\end{array}
\]</span></p>
<p>故等式(13)可以表示为</p>
<p><span class="math display">\[
A - B - C + D = 0 \tag{19}
\]</span></p>
<p>根据等式(16)和(18)知，B和D相等，故等式(19)可以进一步简化为</p>
<p><span class="math display">\[
A - C = 0 \tag{20}
\]</span></p>
<p>等式(20)两端同时扩大两倍得</p>
<p><span class="math display">\[
2\cos2\theta\sum_{i=0}^{k}x_iy_i - \sin2\theta(\sum_{i=0}^{k}x_i^2 - \sum_{i=0}^{k}y_i^2) -2\cos2\theta\frac{\sum_{i=0}^{k}x_i\sum_{i=0}^{k}y_i}{k} + \sin2\theta(V_x\sum_{i=0}^{k}x_i - V_y\sum_{i=0}^{k}y_i) = 0\tag{21}
\]</span></p>
<p>合并同类项得</p>
<p><span class="math display">\[
\cos2\theta*2*(\sum_{i=0}^{k}x_iy_i - \frac{\sum_{i=0}^{k}x_i\sum_{i=0}^{k}y_i}{k}) + \sin2\theta(V_x\sum_{i=0}^{k}x_i - V_y\sum_{i=0}^{k}y_i - \sum_{i=0}^{k}x_i^2 + \sum_{i=0}^{k}y_i^2) = 0 \tag{22}
\]</span></p>
<p>令</p>
<ul>
<li><span class="math inline">\(V_{xy}\)</span></li>
</ul>
<p><span class="math display">\[
\begin{array}{l}
V_{xy} = \sum_{i=0}^{k}x_iy_i - \frac{\sum_{i=0}^{k}x_i\sum_{i=0}^{k}y_i}{k}\\
\qquad = \sum_{i=0}^{k}x_iy_i - \frac{\sum_{i=0}^{k}x_i\sum_{i=0}^{k}y_i}{k} -\frac{\sum_{i=0}^{k}x_i\sum_{i=0}^{k}y_i}{k} + \frac{\sum_{i=0}^{k}x_i\sum_{i=0}^{k}y_i}{k}\\
\qquad = \sum_{i=0}^{k}x_iy_i - \sum_{i=0}^{k}x_iV_y - \sum_{i=0}^{k}y_iV_x + \sum_{i=0}^{k}V_xV_y\\
\qquad = \sum_{i=0}^{k}(x_i - V_x)(y_i - V_y)\tag{23}
\end{array}
\]</span></p>
<ul>
<li><span class="math inline">\(V_{xx}\)</span></li>
</ul>
<p><span class="math display">\[
\begin{array}{l}
V_{xx} = \sum_{i=0}^{k}x_i^2 - V_x\sum_{i=0}^{k}x_i\\
\qquad = \sum_{i=0}^{k}x_i^2 - 2\frac{\sum_{i=0}^{k}x_i\sum_{i=0}^{k}x_i}{k} + \frac{\sum_{i=0}^{k}x_i\sum_{i=0}^{k}x_i}{k}\\
\qquad =\sum_{i=0}^{k}x_i^2 - 2V_x\sum_{i=0}^{k}x_i + \sum_{i=0}^{k}V_xV_x\\
\qquad =\sum_{i=0}^{k}(x_i - V_x)^2 \tag{24}
\end{array}
\]</span></p>
<ul>
<li><span class="math inline">\(V_{yy}\)</span></li>
</ul>
<p><span class="math display">\[
V_{yy} = \sum_{i=0}^{k}(y_i - V_y)^2 \tag{25}
\]</span></p>
<p>等式(22)可以表示为</p>
<p><span class="math display">\[
\cos2\theta*2*V_{xy} + \sin2\theta(V_{yy} - V_{xx}) = 0\tag{26}
\]</span></p>
<p>根据博客<a href="https://blog.csdn.net/zghforever/article/details/88644499">求解方程A<em>cos + B</em>sin = C</a>可知</p>
<p><span class="math display">\[
\theta = \arctan\frac{(V_{yy} - V_{xx}) - \sqrt{(V_{yy} - V_{xx})^2 + 4V_{xy}^2}}{2V_{xy}}\tag{27}
\]</span></p>
<p>根据数据集<span class="math inline">\(S_k\)</span>和等式(12)(27),可以求出最优的<span class="math inline">\(\theta\)</span>和<span class="math inline">\(r\)</span>参数。</p>
]]></content>
      <categories>
        <category>感知算法</category>
      </categories>
      <tags>
        <tag>超声波</tag>
        <tag>特征提取</tag>
      </tags>
  </entry>
  <entry>
    <title>控制算法-后轮位置反馈</title>
    <url>/2020/02/26/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-%E5%90%8E%E8%BD%AE%E4%BD%8D%E7%BD%AE%E5%8F%8D%E9%A6%88/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>本文介绍一种使用后轮位置反馈的路径跟踪算法，使用李亚普洛夫稳定判据，推导控制率。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/2lkhLy4KTODtR56.jpg" alt="黄山" /><figcaption aria-hidden="true">黄山</figcaption>
</figure>
<span id="more"></span>
<h2 id="误差">误差</h2>
<p><img data-src="https://i.loli.net/2021/08/30/yxLlDEZFpgoi5cj.png" alt="后轮位置跟踪示意图" style="zoom:80%;" /></p>
<h3 id="位置误差">位置误差</h3>
<p>关于位置误差的计算，首先搜寻参考路径与车辆后轴中心距离最近的点：</p>
<p><span class="math display">\[
s(t) = arg\min_{\gamma}\|\bigl(x_r(t),y_r(t)\bigr)-\bigl(x_{ref}(\gamma),y_{ref}(\gamma)\bigr) \| \tag{1}
\]</span></p>
<p>其中，<span class="math inline">\(\bigl(x_r(t),y_r(t)\bigr)\)</span>代表<span class="math inline">\(t\)</span>时刻车辆后轴中心位置坐标，<span class="math inline">\(\bigl(x_{ref}(\gamma),y_{ref}(\gamma)\bigr)\)</span>代表参考路径上离车辆后轴距离最近点的位置坐标，<span class="math inline">\(s(t)\)</span>代表<span class="math inline">\(t\)</span>时刻与车辆后轴中心点距离最近参考路径点的位置参数<span class="math inline">\(\gamma\)</span>。</p>
<p>关于参考路径在<span class="math inline">\(s(t)\)</span>参数处的单位切向量为</p>
<p><span class="math display">\[
\hat{t}=
\frac{
\Bigl(\dfrac{\partial x_{ref}}{\partial s}\|_{s(t)},\dfrac{\partial y_{ref}}{ \partial s}\|_{s(t)}
\Bigr)}
{\Bigg\|
\Bigl(\dfrac{ \partial x_{ref}\bigl(s(t)\bigr)}{ \partial s},\dfrac{ \partial y_{ref}\bigl(s(t)\bigr)}{ \partial s}\Bigr)
\Biggr\|}
=(t_x,t_y) \tag{2}
\]</span></p>
<p>跟踪误差向量表示如下：</p>
<p><span class="math display">\[
\vec{d}(t)=\Bigl(x_r(t) - x_{ref}\bigl(s(t)\bigr),y_r(t) - y_{ref}\bigl(s(t)\bigr)\Bigr)=(d_x,d_y)\tag{3}
\]</span></p>
<p>所以跟踪误差向量<span class="math inline">\(\vec{d}\)</span>和参考路径上最近点的单位切向量<span class="math inline">\(\hat{t}\)</span>的向量积为</p>
<p><span class="math display">\[
\vec{e} = \hat{t} \times \vec{d} =
\left\lvert 
\begin{array}{cl}
x &amp; y\\
t_x &amp; t_y\\
d_x &amp; d_y
\end{array}
\right\rvert=t_xd_y - t_yd_x \tag{4}
\]</span></p>
<h3 id="角度误差">角度误差</h3>
<p>关于车辆航向向量与目标路径切向量的夹角<span class="math inline">\(\psi_e\)</span>如下：</p>
<p><span class="math display">\[
\psi_e(t)=\psi-\arctan2(\frac{ \partial y_{ref}\bigl(s(t)\bigr)}{ \partial s},\frac{ \partial x_{ref}\bigl(s(t)\bigr)}{ \partial s}) \tag{5}
\]</span></p>
<h2 id="微分方程">微分方程</h2>
<h3 id="参考曲线最近点">参考曲线最近点</h3>
<p>关于参考曲线与车辆后轴中心最近点处的速度<span class="math inline">\(\dot{s}(t)\)</span>可以通过下图求得</p>
<p><img data-src="https://i.loli.net/2021/08/30/YbBKN6kUmxnAuWL.png" alt="最近点" style="zoom:80%;" /></p>
<p>如上图所示，车辆沿目标路径顺时针运动，点<span class="math inline">\(O\)</span>代表当前目标曲线点对应的旋转中心。很明显此时曲率为负值，即<span class="math inline">\(R &lt; 0\)</span>。根据矢量叉乘性质得，<span class="math inline">\(e &gt; 0\)</span>。假设以点<span class="math inline">\(O\)</span>为旋转中心的车辆后轴中心角速度<span class="math inline">\(\omega_r\)</span>和最近参考路径点处的角速度<span class="math inline">\(\omega_s\)</span>近似相等，得</p>
<p><span class="math display">\[
\omega_r = \omega_s &lt; 0\tag{6}
\]</span></p>
<p>根据车辆旋转角速度的计算等式<span class="math inline">\(\frac{V}{R}\)</span>，结合等式(6)得</p>
<p><span class="math display">\[
\frac{v_{rx}}{R-e} = \frac{\dot{s}}{R} \tag{7}
\]</span></p>
<p>故<span class="math inline">\(\dot{s}\)</span>结果如下</p>
<p><span class="math display">\[
\dot{s} = \frac{R \cdot v_{rx}}{R - e}=\frac{v_{r}\cdot\cos(\psi_e)}{1-k(s)e}\tag{8}
\]</span></p>
<h3 id="横向误差">横向误差</h3>
<p>车辆横向移动的速度<span class="math inline">\(\dot{e}\)</span>可以表示如下：</p>
<p><span class="math display">\[
\dot{e} = v_r \cdot \sin(\psi_e)\tag{9}
\]</span></p>
<h3 id="航向角误差">航向角误差</h3>
<p>关于车辆航向角误差的变化率表示如下：</p>
<p><span class="math display">\[
\begin{array}{cl}
\dot{\psi_e} &amp;= \dot{\psi} - \dot{\psi_{ref}} \\
&amp;= \dot{\psi} - \dot{s}\cdot k(s)\\
&amp;=\dot{\psi} - \dfrac{v_{r}\cdot\cos(\psi_e)\cdot k(s)}{1-k(s)e}
\end{array}\tag{10}
\]</span></p>
<h3 id="综述">综述</h3>
<p>基于上述参考曲线处的速度、横向误差变化率和航向角误差变化率，整理如下微分方程形式：</p>
<p><span class="math display">\[
\begin{array}{cl}
\dot{s} &amp;= \dfrac{v_{r}\cdot\cos(\psi_e)}{1-k(s)e}\\
\dot{e} &amp;= v_r \cdot \sin(\psi_e)\\
\dot{\psi_e} &amp;=\dot{\psi} - \dfrac{v_{r}\cdot\cos(\psi_e)\cdot k(s)}{1-k(s)e}
\end{array}\tag{11}
\]</span></p>
<h2 id="李亚普洛夫稳定判据">李亚普洛夫稳定判据</h2>
<h3 id="lyapunov函数">Lyapunov函数</h3>
<p>基于上述微分方程，定义李亚普洛夫函数形式如下：</p>
<p><span class="math display">\[
V(e,\psi_e) = \frac{1}{2}e^2 + \frac{1}{2k_2}\psi_e^2 \tag{12}
\]</span></p>
<p>其中<span class="math inline">\(k_2 &gt; 0\)</span>，为了使<span class="math inline">\((e,\psi_e)\)</span>在平衡点<span class="math inline">\((0,0)\)</span>处稳定，根据李亚普洛夫稳定判据，必须满足一下两个条件：</p>
<ol type="1">
<li><span class="math inline">\(\lim_{\rvert e,\psi_e \rvert \to \infty}V = \infty\)</span></li>
<li><span class="math inline">\(\begin{array}{rl}\dot{V} &lt; 0 &amp;(e \neq 0,\psi_e \neq 0)\end{array}\)</span></li>
</ol>
<p>对于条件1，等式(12)明显成立，所以李亚普洛夫稳定判据第一条满足。</p>
<p>对于<span class="math inline">\(\dot{V}\)</span>,结合等式(11)的微分方程，推导形式如下：</p>
<p><span class="math display">\[
\begin{array}{cl}
\dot{V} &amp;= e\dot{e} + \dfrac{1}{k_2}\psi_e\dot{\psi}_e\\
&amp;=e \cdot v_r \cdot \sin(\psi_e) + \dfrac{1}{k_2}\psi_e\Bigl(\dot{\psi} - \dfrac{v_{r}\cdot\cos(\psi_e)\cdot k(s)}{1-k(s)e}\Bigr)
\end{array}\tag{13}
\]</span></p>
<p>根据等式(13)，另<span class="math inline">\(\dot{V} = 0\)</span>，得</p>
<p><span class="math display">\[
\begin{array}{cl}
v_r \cdot \sin(\psi_e)\cdot e + \dfrac{1}{k_2}\psi_e\Bigl(\dot{\psi} - \dfrac{v_{r}\cdot\cos(\psi_e)\cdot k(s)}{1-k(s)e}\Bigr)=0\\
k_2 v_r \dfrac{\sin(\psi_e)}{\psi_e}e + \dot{\psi} - \dfrac{v_{r}\cdot\cos(\psi_e)\cdot k(s)}{1-k(s)e} = 0\\
\end{array} \tag{14}
\]</span></p>
<p>求出零界控制率<span class="math inline">\(\dot{\psi_e}\)</span> 如下：</p>
<p><span class="math display">\[
\dot{\psi}^* = \dfrac{v_{r}\cdot\cos(\psi_e)\cdot k(s)}{1-k(s)e} - k_2 v_r \dfrac{\sin(\psi_e)}{\psi_e}e \tag{15}
\]</span></p>
<p>为了满足第2条李亚普洛夫稳定判据，设置一个调节函数<span class="math inline">\(g(e, \psi_e, t) &gt; 0\)</span>,可以得出基于航向角变化率的控制命令：</p>
<p><span class="math display">\[
\dot{\psi} = \dot{\psi}^* - g(e,\psi_e,t)\psi_e\tag{16}
\]</span></p>
<p>设置<span class="math inline">\(g(e,{\psi}_e,t)= k_{\psi}|v_r|\)</span> ，其中<span class="math inline">\(k_{\psi} &gt; 0\)</span>。</p>
<p><span class="math display">\[
\dot{\psi} = \dfrac{v_{r}\cdot\cos(\psi_e)\cdot k(s)}{1-k(s)e} - k_2 v_r \dfrac{\sin(\psi_e)}{\psi_e}e - k_{\psi}|v_r|\psi_e \tag{17}
\]</span></p>
<p>将等式(17)带入等式(13)得</p>
<p><span class="math display">\[
\begin{array}{cl}
\dot{V} 
&amp;=v_r \cdot \sin(\psi_e) \cdot e + \dfrac{1}{k_2}\psi_e\Bigl(\dot{\psi} - \dfrac{v_{r}\cdot\cos(\psi_e)\cdot k(s)}{1-k(s)e}\Bigr)\\
&amp;=v_r \cdot \sin(\psi_e) \cdot e +\dfrac{1}{k_2}\psi_e\bigl(- k_2 v_r \dfrac{\sin(\psi_e)}{\psi_e}e - k_{\psi}|v_r|\psi_e\bigr)\\
&amp;=v_r \cdot \sin(\psi_e) \cdot e - v_r \cdot \sin(\psi_e) \cdot e -\dfrac{k_{\psi}}{k_2}|v_r|\psi_e^2\\
&amp;=-\dfrac{k_{\psi}}{k_2}|v_r|\psi_e^2 \leq 0
\end{array}\tag{18}
\]</span></p>
<p>所以设计得控制率满足稳定性条件。</p>
<h2 id="控制率">控制率</h2>
<p>根据车辆几何关系</p>
<p><span class="math display">\[
\tan(\delta) = \frac{L}{R} \tag{19}
\]</span></p>
<p>车辆航向变化率与车速和转弯半径的关系为<span class="math inline">\(\dot{\psi} = \frac{V}{R}\)</span>，结合等式(17)可得</p>
<p><span class="math display">\[
\tan(\delta) = \frac{\dot{\psi}L}{V} \tag{20}
\]</span></p>
<p>所以控制率<span class="math inline">\(\delta\)</span>为</p>
<p><span class="math display">\[
\delta = \arctan(\frac{\dot{\psi}L}{v_r})\tag{21}
\]</span></p>
<h2 id="仿真">仿真</h2>
<p><img data-src="https://i.loli.net/2021/08/30/8y5DujC4c3XSGWZ.png" style="zoom:80%;" /></p>
<p>根据上述控制系统框图，搭建仿真环境，分别测试三角函数曲线和圆弧曲线的跟踪效果。</p>
<h3 id="三角函数曲线跟踪">三角函数曲线跟踪</h3>
<p><img data-src="https://i.loli.net/2021/08/30/JbyuLNvZHDlhE6q.png" /></p>
<p><img data-src="https://i.loli.net/2021/08/30/qR7Zg6nM2ythaAk.png" /></p>
<h3 id="圆弧曲线跟踪">圆弧曲线跟踪</h3>
<p><img data-src="https://i.loli.net/2021/08/30/1An7yMSvCTNYpJz.png" /></p>
<p><img data-src="https://i.loli.net/2021/08/30/F7GJSnNzgyi6W3v.png" /></p>
<h2 id="实测数据">实测数据</h2>
<p>下图是实际车辆测试结果，测试条件如下：</p>
<ul>
<li>初始位置(0,0)，初始偏航角0°</li>
<li>目标位置(5,-5)，目标偏航角-90°</li>
<li>初始转向角0°</li>
<li>初始速度0.5m/s</li>
<li>跟踪圆弧曲率-0.2</li>
</ul>
<p><img data-src="https://i.loli.net/2021/08/30/FZNv236WHmxlnqw.png" /></p>
<p><img data-src="https://i.loli.net/2021/08/30/5FTyLDrlSiWg7tM.png" /></p>
<p>基于上图可知，跟踪过程主要分为三个阶段：</p>
<ol type="1">
<li>第一阶段(0,0.7)m：车辆按最大角速度转到右转最大角度500°左右</li>
<li>第二阶段(0.7,3)m：车辆保持最大转向角趋近于跟踪曲线</li>
<li>第三阶段(3,5)m：车辆跟踪目标曲线，按照控制率输出转向角</li>
</ol>
<h2 id="总结">总结</h2>
<p>后轴位置反馈控制对于曲率连续变化的曲线控制较好，但对于曲率恒定的曲线(圆弧)，控制输出存在抖动。实际车辆控制时，由于执行器本身可以等效为一个低通滤波器，实测控制抖动较小。</p>
]]></content>
      <categories>
        <category>控制算法</category>
        <category>路径跟踪</category>
      </categories>
      <tags>
        <tag>Rear Wheel Position Base Feedback</tag>
        <tag>后轮位置反馈</tag>
      </tags>
  </entry>
  <entry>
    <title>控制算法-基于运动模型的LQR优化</title>
    <url>/2020/02/18/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-%E5%9F%BA%E4%BA%8E%E8%BF%90%E5%8A%A8%E6%A8%A1%E5%9E%8B%E7%9A%84LQR%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>本文主要讲述基于运动学模型的车辆路径跟踪，并使用<strong>LQR</strong>算法求取最优控制率。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/ActOf2zWvkdC4GT.jpg" alt="宏村" /><figcaption aria-hidden="true">宏村</figcaption>
</figure>
<span id="more"></span>
<h2 id="分析">分析</h2>
<p><img data-src="https://i.loli.net/2021/08/30/YbBKN6kUmxnAuWL.png" /></p>
<h3 id="运动学微分方程">运动学微分方程</h3>
<p>根据上图运动学特性易得</p>
<p><span class="math display">\[
\begin{array}{cl}
\dot{s} &amp;= \dfrac{v_{r}\cdot\cos(\psi_e)}{1-k(s)e}\\
\dot{e} &amp;= v_r \cdot \sin(\psi_e)\\
\dot{\psi_e} &amp;=\dfrac{v_r}{L}\tan(\delta) - \dfrac{v_{r}\cdot\cos(\psi_e)\cdot k(s)}{1-k(s)e}
\end{array}\tag{1}
\]</span></p>
<p>其中关于误差的微分方程如下：</p>
<p><span class="math display">\[
\begin{array}{cl}
\dot{e}_s      &amp;= v_r \cdot \sin(e_\psi)\\
\dot{e}_\psi &amp;= \dfrac{v_r}{L}\tan(\delta) - \dfrac{v_{r}\cdot\cos(e_\psi)\cdot k(s)}{1-k(s)e_s}
\end{array}\tag{2}
\]</span></p>
<h3 id="线性化">线性化</h3>
<p>将上述等式(2)中的<span class="math inline">\(\sin\)</span>和<span class="math inline">\(\cos\)</span>函数在<span class="math inline">\(e_\psi = 0\)</span>处线性化，<span class="math inline">\(\tan\)</span>函数在<span class="math inline">\(\delta = 0\)</span>处线性化得</p>
<p><span class="math display">\[
\begin{array}{cl}
\dot{e}_s    &amp;= v_r \cdot e_\psi \\
\dot{e}_\psi &amp;= \dfrac{v_r}{L}\delta - \dfrac{v_{r}}{R-e_s}
\end{array}\tag{3}
\]</span></p>
<p>对等式(3)中<span class="math inline">\(e_s\)</span>在<span class="math inline">\(e_s = 0\)</span>处线性化得</p>
<p><span class="math display">\[
\begin{array}{cl}
\dot{e}_s    &amp;= v_r \cdot e_\psi \\
\dot{e}_\psi &amp;= \dfrac{v_r}{L}\delta - \dfrac{v_{r}}{R} - \dfrac{v_r}{R^2}e_s 
\end{array}\tag{4}
\]</span></p>
<p>则相应的二阶导数为</p>
<p><span class="math display">\[
\begin{array}{cl}
\ddot{e}_s    &amp;= \dot{v}_r \cdot e_\psi \\
\ddot{e}_\psi &amp;= \dfrac{\dot{v}_r}{L}\delta - \dfrac{\dot{v}_{r}}{R} - \dfrac{\dot{v}_r}{R^2}e_s 
\end{array}\tag{5}
\]</span></p>
<h3 id="状态空间方程">状态空间方程</h3>
<p>整理等式(5)，状态空间方程如下：</p>
<p><span class="math display">\[
\frac{\mathrm{d}}{\mathrm{d}t}
\left[\begin{array}{cl}
e_s\\
\dot{e}_s\\
e_{\psi}\\
\dot{e}_{\psi}
\end{array}\right]=
\left [
\begin{array}{cl}
0  &amp; 1 &amp; 0 &amp; 0\\
0  &amp; 0  &amp; \dot{v}_r &amp; 0\\
0  &amp; 0  &amp; 0 &amp; 1\\
-\dot{v}_r \cdot k^2  &amp; 0 &amp; 0 &amp; 0
\end{array}
\right ]
\left[
\begin{array}{cl}
e_s\\
\dot{e}_s\\
e_{\psi}\\
\dot{e}_{\psi}
\end{array}
\right]+
\left[
\begin{array}{cl}
0\\
0\\
0\\
\dfrac{\dot{v}}{L}
\end{array}
\right]\delta \tag{6}
\]</span></p>
<p>其中<span class="math inline">\(A=\left [ \begin{array}{cl} 0 &amp; 1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; \dot{v}_r &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1\\ -\dot{v}_r \cdot k^2 &amp; 0 &amp; 0 &amp; 0 \end{array}\right ]\)</span>，<span class="math inline">\(B=\left[ \begin{array}{cl} 0\\ 0\\ 0\\ \dfrac{\dot{v}}{L} \end{array}\right]\)</span>，<span class="math inline">\(X= \left[ \begin{array}{cl} e_s\\ \dot{e}_s\\ e_{\psi}\\ \dot{e}_{\psi} \end{array} \right]\)</span>，<span class="math inline">\(U=\delta\)</span>，等式(6)简写如下：</p>
<p><span class="math display">\[
\dot{X} = AX + BU \tag{7}
\]</span></p>
<h3 id="离散化">离散化</h3>
<p>对上述(7)的连续状态空间方程离散化处理，得到如下离散化状态空间方程形式：</p>
<p><span class="math display">\[
X[k+1]=GX[k] + HU[k] \tag{8}
\]</span></p>
<p>其中，<span class="math inline">\(G = I + AT\)</span>、<span class="math inline">\(H = BT\)</span>，采用常规离散化方法得</p>
<p><span class="math display">\[
X[k+1] = (I + AT)X[k] + BTU[k] \tag{9}
\]</span></p>
<p>其中<span class="math inline">\(A\)</span>矩阵离散化得</p>
<p><span class="math display">\[
\begin{array}{cl}
G &amp;= I + AT\\
&amp;=\left[ \begin{array}{cl} 
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right]+
\left [
\begin{array}{cl}
0  &amp; 1 &amp; 0 &amp; 0\\
0  &amp; 0  &amp; \dot{v}_{r(k)} &amp; 0\\
0  &amp; 0  &amp; 0 &amp; 1\\
-\dot{v}_r k^2  &amp; 0 &amp; 0 &amp; 0
\end{array}
\right ]
T\\
&amp;=\left[ \begin{array}{cl} 
1 &amp; T &amp; 0 &amp; 0\\
0 &amp; 1 &amp; \dot{v}_rT &amp; 0\\
0 &amp; 0 &amp; 1 &amp; T\\
-\dot{v}_{r(k)} k^2T &amp; 0 &amp; 0 &amp; 1
\end{array}\right]
\end{array} \tag{10}
\]</span></p>
<p>其中<span class="math inline">\(B\)</span>矩阵离散化得</p>
<p><span class="math display">\[
\begin{array}{cl}
H &amp;= BT\\
&amp;=\left[
\begin{array}{cl}
0\\
0\\
0\\
\dfrac{\dot{v}_{r(k)}T}{L}
\end{array}\right]
\end{array} \tag{11}
\]</span></p>
<p>整理离散空间方程得</p>
<p><span class="math display">\[
\left[\begin{array}{cl}
e_{s(k+1)}\\
\dot{e}_{s(k+1)}\\
e_{\psi(k+1)}\\
\dot{e}_{\psi(k+1)}
\end{array}\right]=
\left [
\begin{array}{cl}
1 &amp; T &amp; 0 &amp; 0\\
0 &amp; 1 &amp; \dot{v}_{r(k)}T &amp; 0\\
0 &amp; 0 &amp; 1 &amp; T\\
-\dot{v}_{r(k)} k^2T &amp; 0 &amp; 0 &amp; 1
\end{array}
\right ]
\left[
\begin{array}{cl}
e_{s(k)}\\
\dot{e}_{s(k)}\\
e_{\psi(k)}\\
\dot{e}_{\psi(k)}
\end{array}
\right]+
\left[
\begin{array}{cl}
0\\
0\\
0\\
\dfrac{\dot{v}_rT}{L}
\end{array}
\right]\delta \tag{12}
\]</span></p>
<h3 id="相关简化">相关简化</h3>
<p>对上述(12)离散空间方程整理得</p>
<p><span class="math display">\[
\begin{array}{cl}
e_{s(k+1)} &amp;= e_{s(k)} + \dot{e}_{s(k)}T\\
\dot{e}_{s(k+1)} &amp;= \dot{e}_{s(k)} + \dot{v}_{r(k)} T e_{\psi(k)}\\
e_{\psi(k+1)}&amp;=e_{\psi(k)} + \dot{e}_{\psi(k)}T\\
\dot{e}_{\psi(k+1)} &amp;=  \dot{e}_{\psi(k)} + \dot{v}_{r(k)}T(\dfrac{\delta}{L} -k^2e_{s(k)})
\end{array} \tag{13}
\]</span></p>
<p>等式(13)中<span class="math inline">\(\dot{e}_{s(k+1)}\)</span>项结合等式(4)可进一步化简得</p>
<p><span class="math display">\[
\begin{array}{cl}
\dot{e}_{s(k)} + \dot{v}_{r(k)} T e_{\psi(k)} &amp;= v_{r(k)}e_{\psi(k)} + dv_{r(k)}e_{\psi(k)}\\
&amp;= (v_{r(k)} + dv_{r(k)})e_{\psi(k)}\\
&amp;=v_{r(k+1)}e_{\psi(k)}
\end{array} \tag{14}
\]</span></p>
<p>等式(13)中<span class="math inline">\(\dot{e}_{\psi(k+1)}\)</span>项结合等式(4)可进一步化简得</p>
<p><span class="math display">\[
\begin{array}{cl}
\dot{e}_{\psi(k)} + \dot{v}_{r(k)}T(\dfrac{\delta}{L} -k^2e_{s(k)})
&amp;=v_{r(k)}(\dfrac{\delta}{L} - k^2e_{s(k)}) + dv_{r(k)}(\dfrac{\delta}{L} - k^2e_{s(k)})\\
&amp;=(v_{r(k)} + dv_{r(k)})(\dfrac{\delta}{L}-k^2e_{s(k)})\\
&amp;=v_{r(k+1)}(\dfrac{\delta}{L}-k^2e_{s(k)})
\end{array}\tag{15}
\]</span></p>
<p>其中<span class="math inline">\(\dot{v}_r = \dfrac{dv_r}{dt}\)</span>，等式(13)结合等式(14)和(15)得</p>
<p><span class="math display">\[
\begin{array}{cl}
e_{s(k+1)} &amp;= e_{s(k)} + \dot{e}_{s(k)}T\\
\dot{e}_{s(k+1)} &amp;= v_{r(k+1)} e_{\psi(k)}\\
e_{\psi(k+1)}&amp;=e_{\psi(k)} + \dot{e}_{\psi(k)}T\\
\dot{e}_{\psi(k+1)} &amp;=  - v_{r(k+1)}k^2e_{s(k)} + \dfrac{v_{r(k+1)}}{L}\delta
\end{array}\tag{16}
\]</span></p>
<p>上述等式(16)整理为状态空间方程的形式为</p>
<p><span class="math display">\[
\left[\begin{array}{cl}
e_{s(k+1)}\\
\dot{e}_{s(k+1)}\\
e_{\psi(k+1)}\\
\dot{e}_{\psi(k+1)}
\end{array}\right]=
\left [
\begin{array}{cl}
1 &amp; T &amp; 0 &amp; 0\\
0 &amp; 0 &amp; v_{r(k+1)} &amp; 0\\
0 &amp; 0 &amp; 1 &amp; T\\
-v_{r(k+1)} k^2 &amp; 0 &amp; 0 &amp; 0
\end{array}
\right ]
\left[
\begin{array}{cl}
e_{s(k)}\\
\dot{e}_{s(k)}\\
e_{\psi(k)}\\
\dot{e}_{\psi(k)}
\end{array}
\right]+
\left[
\begin{array}{cl}
0\\
0\\
0\\
\dfrac{v_{r(k+1)}}{L}
\end{array}
\right]\delta \tag{17}
\]</span></p>
<h2 id="求解">求解</h2>
<p>采用<strong>LQR</strong>算法进行控制率求解。</p>
<ol type="1">
<li>确定迭代范围<span class="math inline">\(N\)</span></li>
<li>设置迭代初始值<span class="math inline">\(P_N=Q_f\)</span></li>
<li>循环迭代，<span class="math inline">\(t = N,\dots,1\)</span></li>
</ol>
<p><span class="math display">\[
P_{t-1} = Q + A^TP_{t+1}A - A^TP_{t+1}B(R + B^TP_{t+1}B)^{-1}B^TP_{t+1}A
\]</span></p>
<ol start="4" type="1">
<li>则反馈系数<span class="math inline">\(K_t = -(R + B^TP_{t+1}B)^{-1}B^TP_{t+1}A\)</span>，对于时间<span class="math inline">\(t=0,\dots,N-1\)</span></li>
<li>优化的控制量<span class="math inline">\(u_t^{lqr}=K_tx_t\)</span></li>
</ol>
<h2 id="参考">参考</h2>
<ul>
<li><span class="exturl" data-url="aHR0cDovL3pnaDU1MS50b3AvMjAyMC8wMi8yMC8lRTUlOUYlQkElRTclQTElODAlRTclQUUlOTclRTYlQjMlOTUtTFFSLSVFNyVBNiVCQiVFNiU5NSVBMyVFNiU5NyVCNiVFOSU5NyVCNCVFNiU5QyU4OSVFOSU5OSU5MCVFOCVCRSVCOSVFNyU5NSU4Qy8jbW9yZQ==">LQR-离散时间有限边界<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>控制算法</category>
        <category>路径跟踪</category>
      </categories>
      <tags>
        <tag>LQR</tag>
        <tag>路径跟踪</tag>
        <tag>控制算法</tag>
        <tag>Path Tracking</tag>
        <tag>运动模型</tag>
      </tags>
  </entry>
  <entry>
    <title>控制算法-滑模控制介绍</title>
    <url>/2019/12/21/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-%E6%BB%91%E6%A8%A1%E6%8E%A7%E5%88%B6%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="一维运动模型">一维运动模型</h2>
<p>考虑简单的单位质量块的一维运动模型，使用位移和速度状态变量进行描述。</p>
<p><img data-src="https://i.loli.net/2021/08/30/5gi8qy1jdHrvePa.png" /></p>
<p>定义位移变量<span class="math inline">\(x_1 = x\)</span>和速度变量<span class="math inline">\(x_2 = \dot{x_1} = v\)</span>，运动模型的微分形式使用<span class="math inline">\(x_1\)</span>、<span class="math inline">\(x_2\)</span>表示如下：</p>
<p><span class="math display">\[
\left\{
\begin{array}{rl}
&amp;\dot{x_1} = x_2&amp; x_1(0)=x_{10}\\
&amp;\dot{x_2} = u + f(x_1,x_2,t) &amp;x_2(0)=x_{20}
\end{array} \right.\tag{1}
\]</span></p>
<span id="more"></span>
<p>其中,<span class="math inline">\(u\)</span>代表控制力，干扰项<span class="math inline">\(f(x_1,x_2,t)\)</span>包括干粘摩檫力的影响和一些未知的阻力，并假定有界。</p>
<p><span class="math display">\[
\rvert f(x_1,x_2,t)\rvert \leqslant L \gt 0 \tag{2}
\]</span></p>
<p>问题关键在于设计一个反馈控制率<span class="math inline">\(u = u(x_1,x_2)\)</span>，驱动质量块渐进到达原点。换句话说，控制变量<span class="math inline">\(u=f(x_1,x_2)\)</span>应该驱使状态变量趋近于0：<span class="math inline">\(\lim_{t \to \infty}{x_1,x_2} = 0\)</span>。</p>
<p>这个问题看似简单，但对于存在未知的边界干扰项<span class="math inline">\(f(x_1,x_2,t)\)</span>的情况下，使系统渐进收敛仍然存在着挑战。</p>
<h3 id="状态反馈控制">状态反馈控制</h3>
<p>例如，通过一个线性状态反馈控制率</p>
<p><span class="math display">\[
\begin{matrix}
u = -k_1x_1 - k_2x_2, &amp;\text{其中}(k_1&gt;0,&amp;k_2&gt;0)
\end{matrix}\tag{3}
\]</span></p>
<p>在外界干扰项<span class="math inline">\(f(x_1,x_2,t)\equiv 0\)</span>，即不存在外界干扰时，系统可以实现渐进收敛。</p>
<h3 id="仿真结果">仿真结果</h3>
<ul>
<li>初始条件<span class="math inline">\(x_{10}=1\)</span>、<span class="math inline">\(x_{20} = -2\)</span>、控制率参数<span class="math inline">\(k_1=3\)</span>、<span class="math inline">\(k_2=4\)</span>。</li>
</ul>
<p>如下图所示，是无外界干扰项时的渐近收敛效果图，图中蓝色线代表距离<span class="math inline">\(x\)</span>，橘黄色线代表速度<span class="math inline">\(v\)</span>，可以看出在反馈控制率<span class="math inline">\(u = u(x_1,x_2)\)</span>的作用下，距离和速度值都趋近于0。</p>
<p><img data-src="https://i.loli.net/2021/08/30/ezqd9oHvbYJwhCB.png" /></p>
<p>加入外部干扰<span class="math inline">\(f(x_1,x_2,t) = \sin(2t)\)</span>，响应波形如下：</p>
<p><img data-src="https://i.loli.net/2021/08/30/heN7REVItMlwbqf.png" /></p>
<p>对于干扰项<span class="math inline">\(\rvert f(x_1,x_2,t)\rvert \leq L &gt; 0\)</span>,产生的状态边界范围为<span class="math inline">\(\Omega=(k_1,k_2,L)\)</span> 。</p>
<p>现在问题在于，仅使用未知扰动范围的知识是否可以解决规定的控制问题。</p>
<h2 id="滑模控制的主要特性">滑模控制的主要特性</h2>
<p>介绍对于等式(1)系统，所需的补偿动力。一个较好的替代这些动力学特性的是齐次线性时不变微分方程：</p>
<p><span class="math display">\[
\begin{array}{rl}
\dot{x}_1 + c \cdot x_1 = 0 ,&amp; c &gt; 0 \tag{4}
\end{array}
\]</span></p>
<p>因为 <span class="math inline">\(x_2(t) = \dot{x}_1(t)\)</span>,等式(4)的通用解和它的微分形式如下：</p>
<p><span class="math display">\[
\begin{array}{}
&amp;x_1(t) = x_1(0)\exp(-ct)\\
&amp;x_2(t) = \dot{x_1}(t)=-c \cdot x_1(0)\exp(-ct)
\end{array}\tag{5}
\]</span></p>
<p>从等式(5)可以看出，<span class="math inline">\(x_1(t)\)</span>和<span class="math inline">\(x_2(t)\)</span>都是逐渐趋近于0。注意，无干扰项<span class="math inline">\(f(x_1,x_2,t)\)</span>的状态补偿动力学是很明显的。如何获得这些补偿动力。</p>
<h3 id="滑模变量">滑模变量</h3>
<p>首先介绍一个等式(1)系统的状态空间的新变量(<strong><em>滑模变量</em></strong>)：</p>
<p><span class="math display">\[
\sigma = \sigma(x_1,x_2) = x_2 + c \cdot x_1 \tag{6}
\]</span></p>
<p>在给定等式(5)收敛率且存在有界干扰<span class="math inline">\(f(x_1,x_2,t)\)</span>的情况下，为了使状态变量<span class="math inline">\(x_1\)</span>，<span class="math inline">\(x_2\)</span>逐渐收敛于0，即<span class="math inline">\(\lim_{t \to \infty} x_1,x_2 = 0\)</span>，不得不通过控制率<span class="math inline">\(u\)</span>使得等式(6)的变量<span class="math inline">\(\sigma\)</span>在有限的时间内趋于0。</p>
<p>为了完成这个任务利用李亚普洛夫函数技术，结合等式(1)和(6)推动出关于滑模变量<span class="math inline">\(\sigma\)</span>的动力学方程如下：</p>
<p><span class="math display">\[
\begin{array}{rl}
\dot{\sigma} = c \cdot x_2 + f(x_1,x_2,t) + u ,&amp;\sigma(0) = \sigma_0
\end{array} \tag{7}
\]</span></p>
<h3 id="稳定判据">稳定判据</h3>
<p>李亚普洛夫函数(Lyapunov)形式如下：</p>
<p><span class="math display">\[
V = \frac{1}{2}\sigma^2 \tag{8}
\]</span></p>
<p>为了使等式(6)在平衡点<span class="math inline">\(\sigma = 0\)</span>处渐进稳定，根据李亚普洛夫稳定判据，必须满足下面两个条件：</p>
<ol type="1">
<li><span class="math inline">\(\begin{array}{rl}\dot{V} &lt; 0 &amp;(\sigma \neq 0)\end{array}\)</span></li>
<li><span class="math inline">\(\lim_{\rvert \sigma \rvert \to \infty}V = \infty\)</span></li>
</ol>
<p>由等式(8)知，条件2明显满足。为了满足有限时间内渐进稳定，条件(1)可以修改为：</p>
<p><span class="math display">\[
\dot{V} \leq -\alpha {V}^{\frac{1}{2}} ,\qquad \alpha &gt; 0 \tag{9}
\]</span></p>
<p>在时间间隔<span class="math inline">\(0 \leq \tau \leq t\)</span>内，对等式(9)所示的微分方程进行变量分离求积分得</p>
<p><span class="math display">\[
\begin{array}{rl}
\int_{0}^{t} V(\tau)^{-\frac{1}{2}}dV(\tau) &amp;\leq -\alpha*\int_{0}^{t}1 d\tau\\
2*V(\tau)^{\frac{1}{2}}|_0^t &amp;\leq -\alpha*\tau|_0^t\\
2*[V(t)^{\frac{1}{2}} - V(0)^{\frac{1}{2}}] &amp;\leq -\alpha*t\\
V(t)^{\frac{1}{2}} &amp;\leq -\dfrac{1}{2}\alpha*t + V(0)^{\frac{1}{2}}
\end{array}\tag{10}
\]</span></p>
<p>故<span class="math inline">\(V(t)\)</span>在有限时间<span class="math inline">\(t_r\)</span>达到0时的边界，根据等式(26)得</p>
<p><span class="math display">\[
t_r \leq \frac{2V(0)^{\frac{1}{2}}}{\alpha} \tag{11}
\]</span></p>
<p>因此，设计一个控制器<span class="math inline">\(u\)</span>满足等式(9)，使得变量<span class="math inline">\(s\)</span>在有限的时间内趋近于0并在之后一直保持。</p>
<p><span class="math inline">\(V\)</span>的微分计算如下：</p>
<p><span class="math display">\[
\dot{V} = \sigma\dot{\sigma}=\sigma(c \cdot x_2 + f(x_1,x_2,t) + u) \tag{12}
\]</span> 假设 <span class="math inline">\(u = -c \cdot x_2 + v\)</span>，并将其带入等式(12)得 <span class="math display">\[
\dot{V} 
= \sigma\bigl( f(x_1,x_2,t) + v \bigr) 
= \sigma \cdot f(x_1,x_2,t) + \sigma v
\leq   \rvert \sigma \rvert L + \sigma v \tag{13}
\]</span></p>
<p>此处选择<span class="math inline">\(v = -\rho sign(\sigma)\)</span>，该函数表示为</p>
<p><span class="math display">\[
sign(x) =
\left \{
\begin{array}{rl}
&amp; 1 &amp; x &gt; 0\\
&amp; &amp; &amp;\\
&amp;-1 &amp; x &lt; 0
\end{array}
\right. \tag{14}
\]</span> 并且</p>
<p><span class="math display">\[
sign(0) \in [-1,1] \tag{15}
\]</span></p>
<p>由于<span class="math inline">\(\rho &gt; 0\)</span>，将其带入等式(13)得</p>
<p><span class="math display">\[
\dot{V} \leq \rvert \sigma  \rvert L - \rvert \sigma \rvert \rho 
= \rvert \sigma \rvert(L - \rho) \tag{16}
\]</span></p>
<p>考虑到等式(8)的形式，等式(9)可以表示为</p>
<p><span class="math display">\[
\dot{V} \leq -\alpha {V}^{\frac{1}{2}} = -\frac{\alpha}{\sqrt{2}}\rvert \sigma \rvert,\qquad \alpha &gt; 0 \tag{17}
\]</span></p>
<p>结合等式(16)和等式(17)得</p>
<p><span class="math display">\[
\dot{V} \leq \rvert \sigma \rvert(L - \rho)
=-\frac{\alpha}{\sqrt{2}}\rvert \sigma \rvert \tag{18}
\]</span></p>
<p>最终控制增益可以表示为</p>
<p><span class="math display">\[
\rho = L + \frac{\alpha}{\sqrt{2}} \tag{19}
\]</span></p>
<p>所以最终使滑模变量<span class="math inline">\(\sigma\)</span>在有限时间内趋近于0的控制率<span class="math inline">\(u\)</span>为</p>
<p><span class="math display">\[
u = -c \cdot x_2 - \rho \cdot sign(\sigma) \tag{20}
\]</span></p>
<blockquote>
<ol type="1">
<li>显然，为了成功地设计出等式(20)中的控制器，<span class="math inline">\(\dot{\sigma}\)</span>必须是控制率<span class="math inline">\(u\)</span>的函数。当设计像等式(6)中的滑模变量时，这个特性必须考虑其中。</li>
<li>等式(19)中控制增益<span class="math inline">\(\rho\)</span>的第一项被设计用来补偿有界干扰项<span class="math inline">\(f(x_1,x_2,t)\)</span>，同时第二项<span class="math inline">\(\frac{\alpha}{\sqrt{2}}\)</span>负责确定滑模面的到达时间。<span class="math inline">\(\alpha\)</span>的数值越大，到达时间就越短。</li>
</ol>
</blockquote>
<h3 id="基本定义">基本定义</h3>
<ul>
<li><strong>滑模变量</strong></li>
</ul>
<p>等式(6)中定义的变量<span class="math inline">\(\sigma\)</span>叫做 <strong>滑模变量</strong>(<code>sliding variable</code>)</p>
<ul>
<li><strong>滑模面</strong></li>
</ul>
<p>结合等式(4)和(5)，可以重新写成如下形式： <span class="math display">\[
\sigma = x_2 + c \cdot x_1 = 0, c &gt; 0 \tag{21}
\]</span> 相当于在系统(1)状态空间内的一条直线，这条直线被称为 <strong>滑模面</strong>(<code>sliding surface</code>)。</p>
<p>考虑到等式(9)可以等效于</p>
<p><span class="math display">\[
\sigma\dot{\sigma} \leq - \frac{\sigma}{\sqrt{2}} \rvert \sigma\rvert \tag{22}
\]</span></p>
<p>等式(22)经常被称为 <strong>到达条件</strong>(<code>reachability condition</code>)。满足<strong>到达条件</strong>意味着等式(1)系统的轨迹趋向于<strong>滑模面</strong>，并在此后一直保持。</p>
<ul>
<li><strong>滑模控制</strong></li>
</ul>
<p>等式(20)所对应的控制率<span class="math inline">\(u = u(x_1,x_2)\)</span>驱使状态变量<span class="math inline">\(x_1\)</span>、<span class="math inline">\(x_2\)</span>在有限时间<span class="math inline">\(t_r\)</span>内趋近于<strong>滑模面</strong>，并在存在有界干扰项<span class="math inline">\(f(x_1,x_2,t)\)</span>的情况下保持在该平面上，这个控制率<span class="math inline">\(u\)</span>就叫做 <strong>滑模控制</strong>。并且对于所有的<span class="math inline">\(t &gt; t_r\)</span>，系统都将产生一个<strong>理想滑动模态</strong>。</p>
<h3 id="仿真结果-1">仿真结果</h3>
<p>初始条件为<span class="math inline">\(x_1(0) = 1，x_2(0) = -2\)</span>，控制增益为<span class="math inline">\(\sigma = 2\)</span>，滑模参数为<span class="math inline">\(c = 1.5\)</span>同时干扰项为<span class="math inline">\(f(x_1,x_2,t) = \sin(2t)\)</span>。 使用等式(20)的滑模控制率的仿真结果如下：</p>
<p>下图表明，在有限的时间内，滑模变量趋近于0。</p>
<p><img data-src="https://i.loli.net/2021/08/30/LCQw2J7rU9axcKq.png" /></p>
<p>在干扰项作用的情况下，状态变量<span class="math inline">\(x\)</span>和<span class="math inline">\(v\)</span>逐渐收敛到0。</p>
<p><img data-src="https://i.loli.net/2021/08/30/jk5MfqmpabEFnAO.png" /></p>
<p>相图如下，展示了到达相位和滑移相位。</p>
<p><img data-src="https://i.loli.net/2021/08/30/k3HSfaLoPvgQ9C4.png" /></p>
<p>对上面的相图进行局部放大发现，在滑模状态下，状态变量存在小幅度且高频率的蜿蜒运动。</p>
<p><img data-src="https://i.loli.net/2021/08/30/7jGmgk14ruHwSOM.png" /></p>
<p>理想的滑模切换频率应该接近于无限并且蜿蜒运动的振幅接近于0。从下图可知，符号函数<span class="math inline">\(sign\)</span>不完美表现为在滑动模态中产生了有限幅度和频率的之字形运动，原因在于计算机仿真的离散特性，这样的影响叫做 <strong>抖振</strong>(<em>chattering</em>)。</p>
<p><img data-src="https://i.loli.net/2021/08/30/xme942slagIdZNK.png" /></p>
<p><img data-src="https://i.loli.net/2021/08/30/qvr8kst615cLNM4.png" /></p>
]]></content>
      <categories>
        <category>控制算法</category>
        <category>滑模控制</category>
      </categories>
      <tags>
        <tag>滑模控制</tag>
        <tag>滑模面</tag>
        <tag>滑模变量</tag>
        <tag>抖振</tag>
        <tag>sliding mode controller</tag>
        <tag>sliding mode variable</tag>
        <tag>sliding mode surface</tag>
        <tag>chattering</tag>
      </tags>
  </entry>
  <entry>
    <title>控制算法-滑模控制抖振消除</title>
    <url>/2019/12/27/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-%E6%BB%91%E6%A8%A1%E6%8E%A7%E5%88%B6%E6%8A%96%E6%8C%AF%E6%B6%88%E9%99%A4/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>在实际控制系统中，包括直流电机和飞机控制，通过连续或者平滑控制信号来避免控制抖振都是非常重要的方式。进一步说，飞机的气动表面不能高频来回运动，但同时对于边界模型不确定且存在外部干扰的控制系统，渴望保持其鲁棒性或不敏感度。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/e6fD51xMwEGqdnO.jpg" alt="重庆美术学院" /><figcaption aria-hidden="true">重庆美术学院</figcaption>
</figure>
<span id="more"></span>
<h2 id="消抖方法">消抖方法</h2>
<h3 id="抖振消除">抖振消除</h3>
<p>一个显而易见使控制函数连续且平滑的解决方案就是通过一些连续或平滑函数代替非连续函数<span class="math inline">\(v(\sigma) = -\rho sign(\sigma)\)</span>。进一步说，它可以被"sigmoid function"替代。</p>
<p><span class="math display">\[
sign(\sigma) \approx \frac{\sigma}{\rvert \sigma \rvert + \varepsilon} \tag{1}
\]</span></p>
<p>其中，<span class="math inline">\(\varepsilon\)</span>是一个很小的正标量。可以看出，对于所有<span class="math inline">\(\sigma \neq 0\)</span>，下述等式成立：</p>
<p><span class="math display">\[
\lim_{\varepsilon \to 0}\frac{\sigma}{\rvert \sigma \rvert + \varepsilon} = sign(\sigma) \tag{2}
\]</span></p>
<p>对于<span class="math inline">\(\varepsilon\)</span>的选择需要权衡既要保持系统的性能理想又要确保控制的平滑。</p>
<p>关于 Sigmoid Function 的图形如下：</p>
<p><img data-src="https://i.loli.net/2021/08/30/NoXcDfzSPqBFMQJ.png" /></p>
<p>使用伪滑动模态控制率如下：</p>
<p><span class="math display">\[
u = -c \cdot x_2 - \rho\frac{\sigma}{\rvert \sigma \rvert + \varepsilon} \tag{3}
\]</span></p>
<h4 id="仿真结果">仿真结果</h4>
<p><img data-src="https://i.loli.net/2021/08/30/gsIFvU3k7RONlBe.png" /></p>
<p><img data-src="https://i.loli.net/2021/08/30/FyCmKcoS1YnELZ6.png" /></p>
<p><img data-src="https://i.loli.net/2021/08/30/xA2XwCuNatFjLpk.png" /></p>
<p>由上图可知，平滑控制函数不能够在存在外部干扰项<span class="math inline">\(f(x_1,x_2,t)\)</span>时，使得滑模变量在有限时间内收敛于0。并且滑模变量和状态变量都不能收敛于0，但由于干扰项<span class="math inline">\(f(x_1,x_2,t) = \sin(2t)\)</span>影响，使其收敛到原点附近的范围。实现平滑控制函数的代价是鲁棒性的损失和准确性降低。因为滑模变量在有限的时间内没有趋向于0，所以等式(3)所设计的平滑控制从技术上讲不是滑模控制，在系统中也不是理想的滑动模态。但是在等式(3)中平滑控制率下的系统性能接近于离散滑模控制下的系统性能。这就为我们将等式(3)对应的平滑控制率称为<strong>准滑模控制</strong>(<em>quasi-sliding mode control</em>)提供了依据，而当滑模面收敛于原点时，就叫做 <strong>准滑动模态</strong>(<em>quasi-sliding mode</em>)</p>
<h3 id="抖振衰减">抖振衰减</h3>
<p>考虑设计另一种对边界干扰具有鲁棒性的连续控制器，设计思想就是根据控制函数的微分形式设计滑模控制器。在这种情况下，高频切换函数的积分作为实际控制是连续的。这种方法叫做 <strong>抖振衰减</strong>(<em>chattering attenuation</em>)，这是因为在高频切换函数积分后仍然能在滑模控制中观察到一些周期性残差。</p>
<h4 id="微分方程">微分方程</h4>
<p>系统微分方程如下：</p>
<p><span class="math display">\[
\left \{
\begin{array}{rl}
&amp;\dot{x}_1 = x_2 &amp;x_1(0) &amp;= x_{10}\\
&amp;\dot{x}_2 = u + f(x_1,x_2,t) &amp;x_2(0) &amp;= x_{20}\\
&amp;\dot{u} = v &amp;u(0) &amp;= 0
\end{array}
\right. \tag{4}
\]</span></p>
<p>如果滑模变量 <span class="math inline">\(\sigma = x_2 + c \cdot x_1\)</span>被限制在有限时间<span class="math inline">\(t = t_r\)</span>内收敛于0，同样对于所有<span class="math inline">\(t \geq t_r\)</span>,状态变量渐进收敛于0。这里假设<span class="math inline">\(\rvert f(x_1,x_2,t) \leq L\)</span>，此外其有界导数<span class="math inline">\(\rvert \dot{f}(x_1,x_2,t) \rvert \leq \bar{L}\)</span>是平滑的。</p>
<h4 id="辅助滑动变量">辅助滑动变量</h4>
<p>为了达到抖振衰减，定义如下辅助滑动变量</p>
<p><span class="math display">\[
s = \dot{\sigma} + \bar{c}\sigma \tag{5}
\]</span></p>
<p>如果设计一个控制率<span class="math inline">\(v\)</span>使得在有限时间内收敛<span class="math inline">\(s \to 0\)</span>，那么理想的滑动模态发生在如下滑模面上：</p>
<p><span class="math display">\[
s = \dot{\sigma} + \bar{c}\sigma = 0 \tag{6}
\]</span></p>
<p>随着时间的递增，即使存在有界的干扰<span class="math inline">\(f(x_1,x_2,t)\)</span>，只要<span class="math inline">\(\sigma,\dot{\sigma} \to 0\)</span>,与此同时<span class="math inline">\(x_1,x_2 \to 0\)</span>。但是因为原始滑模变量<span class="math inline">\(\sigma\)</span>只是渐进收敛于0，所以对于系统(4)而言，这不是理想的滑动模态，而是 <strong>渐进滑动模态</strong>(<em>asymptotic sliding mode</em>)，这就是衰减抖振所付出的代价。</p>
<p>根据等式(4)对辅组滑动变量<span class="math inline">\(s\)</span>拆解得</p>
<p><span class="math display">\[
\begin{array}{rl}
s &amp;= \dot{\sigma} + \bar{c}\sigma\\
&amp;= \dot{x}_2 + c\dot{x}_1 + \bar{c}(x_2 + cx_1)\\
&amp;= u + f(x_1,x_2,t) + cx_2 + \bar{c}x_2 + c\bar{c}x_1\\
&amp;=u + (c + \bar{c})x_2 + c\bar{c}x_1 + f(x_1,x_2,t)
\end{array} \tag{7}
\]</span></p>
<p>辅组滑动变量<span class="math inline">\(s\)</span>求导得</p>
<p><span class="math display">\[
\begin{array}{rl}
\dot{s} 
&amp;= \dot{u} + (c + \bar{c})\dot{x}_2 + c\bar{c}\dot{x}_1 + \dot{f}(x_1,x_2,t)\\
&amp;= v + (c + \bar{c})(u + f(x_1,x_2,t)) + c\bar{c}x_2 + \dot{f}(x_1,x_2,t)\\
&amp;= v + (c + \bar{c})u + c\bar{c}x_2 + (c + \bar{c})f(x_1,x_2,t) + \dot{f}(x_1,x_2,t)
\end{array} \tag{8}
\]</span></p>
<p>根据李亚普洛夫稳定条件，设计滑模控制项<span class="math inline">\(v\)</span>，得到如下等式：</p>
<p><span class="math display">\[
s\dot{s} = s
\bigl(
v + (c + \bar{c})u + c\bar{c}x_2 + (c + \bar{c})f(x_1,x_2,t) + \dot{f}(x_1,x_2,t)
\bigr) \tag{9}
\]</span></p>
<p>选择如下控制率：</p>
<p><span class="math display">\[
v = -c\bar{c}x_2 - (c + \bar{c})u + v_1 \tag{10}
\]</span></p>
<p>将等式(10)带入等式(9)得</p>
<p><span class="math display">\[
s\dot{s} = s
\bigl(
v_1 + (c + \bar{c})f(x_1,x_2,t) + \dot{f}(x_1,x_2,t)
\bigr) \tag{11}
\]</span></p>
<p>由于有界干扰项<span class="math inline">\(\rvert f(x_1,x_2,t) \leq L\)</span>且<span class="math inline">\(\rvert \dot{f(x_1,x_2,t)} \rvert \leq \bar{L}\)</span>，故得</p>
<p><span class="math display">\[
s\dot{s} \leq sv_1 + \rvert s \rvert \bigl( (c + \bar{c})L + \bar{L}\bigr) \tag{12}
\]</span></p>
<p>选择切换函数为<span class="math inline">\(v_1 = - \rho sign(s)\)</span>，其中<span class="math inline">\(\rho &gt; 0\)</span>，带入等式(12)得</p>
<p><span class="math display">\[
s\dot{s} \leq \rvert s \rvert \bigl(-\rho + \bar{L} + (c + \bar{c})L \bigr) \tag{13}
\]</span></p>
<p>根据有限时间收敛条件</p>
<p><span class="math display">\[
s\dot{s} \leq -\frac{\alpha}{\sqrt{2}}\rvert s\rvert \tag{14}
\]</span></p>
<p>结合等式(13)和(14),计算控制增益<span class="math inline">\(\rho\)</span>如下：</p>
<p><span class="math display">\[
\rho = \bar{L} + (c + \bar{c})L + \frac{\alpha}{\sqrt{2}} \tag{15}
\]</span></p>
<p>驱使<span class="math inline">\(s\)</span>在有限时间<span class="math inline">\(t_r \leq \frac{\sqrt{2}\rvert s(0) \rvert}{\alpha}\)</span>内使<span class="math inline">\(s\)</span>收敛于0的控制率<span class="math inline">\(v\)</span>为</p>
<p><span class="math display">\[
v = -c\bar{c}x_2 - (c + \bar{c})u - \rho \cdot sign(s) \tag{16}
\]</span></p>
<h4 id="仿真结果-1">仿真结果</h4>
<p>如下图所示，包含高频切换项的<span class="math inline">\(\rho sign(s)\)</span>的控制率导致了抖振。</p>
<p><img data-src="https://i.loli.net/2021/08/30/NvsdctofEuqlKni.png" /></p>
<p>但如下图所示，抖振在实际物理控制率<span class="math inline">\(u = \int vdt\)</span>中逐步衰减。</p>
<p><img data-src="https://i.loli.net/2021/08/30/gsIFvU3k7RONlBe.png" /></p>
]]></content>
      <categories>
        <category>控制算法</category>
        <category>滑模控制</category>
      </categories>
      <tags>
        <tag>滑模控制</tag>
        <tag>避免抖振</tag>
        <tag>chattering avoidance</tag>
        <tag>准滑动模态</tag>
        <tag>Quasi-Sliding Mode</tag>
        <tag>渐近滑动模态</tag>
        <tag>抖振衰减</tag>
        <tag>Chattering Attenuation</tag>
        <tag>抖振消除</tag>
        <tag>Chattering Elimination</tag>
      </tags>
  </entry>
  <entry>
    <title>控制算法-纯追踪法</title>
    <url>/2020/02/23/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-%E7%BA%AF%E8%BF%BD%E8%B8%AA%E6%B3%95/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>在机器人领域，一种最受欢迎的路径追踪算法就是几何路径追踪。这些方法主要利用车辆和路径之间的几何关系去设计相应的控制率解决路径跟踪问题。</p>
<h2 id="几何车辆模型">几何车辆模型</h2>
<p><img data-src="https://i.loli.net/2021/08/30/XA45nZvx1sIiMUD.jpg" alt="荷花"  /></p>
<span id="more"></span>
<p>对于几何路径跟踪一般简化车辆模型为单车模型，如上图所示，前轮转向角和后轴跟随曲线之间的几何关系可以表示如下：</p>
<p><span class="math display">\[
\tan(\delta) = \frac{L}{R}\tag{1}
\]</span></p>
<p>其中，<span class="math inline">\(\delta\)</span>代表前轮转向角、<span class="math inline">\(L\)</span>代表车辆轴距、<span class="math inline">\(R\)</span>代表转弯半径。</p>
<h2 id="纯追踪">纯追踪</h2>
<p><img data-src="https://i.loli.net/2021/08/30/prkjiz1ZAaHyW4u.png" alt="纯追踪" style="zoom:80%;" /></p>
<p>纯追踪算法包括几何关系计算出后轴位置与车辆前方目标曲线上目标点之间圆弧的曲率，其中目标点由从当前车辆后轴位置到目标路径的超前距离<span class="math inline">\(l_d\)</span>决定。而车辆的转向角<span class="math inline">\(\delta\)</span>只能使用目标点位置和车辆航向量与超前向量之间的夹角<span class="math inline">\(\alpha\)</span>。由正弦定理得</p>
<p><span class="math display">\[
\frac{l_d}{\sin(2\alpha)} = \frac{R}{\sin(\frac{\pi}{2}-\alpha)}\tag{2}
\]</span></p>
<p>根据三角函数性质，对等式(2)化简得</p>
<p><span class="math display">\[
\frac{l_d}{2\sin(\alpha)\cos(\alpha)} = \frac{R}{\cos(\alpha)} \tag{3}
\]</span></p>
<p>由于<span class="math inline">\(\cos(\alpha) \neq 0\)</span>，对等式(3)进一步化简得</p>
<p><span class="math display">\[
R = \frac{l_d}{2\sin(\alpha)} \tag{4}
\]</span></p>
<p>故曲率表示为</p>
<p><span class="math display">\[
k = \frac{2\sin(\alpha)}{l_d} \tag{5}
\]</span></p>
<p>根据等式(1)所示的车辆几何关系得</p>
<p><span class="math display">\[
\delta = \arctan(k\cdot L) \tag{6}
\]</span></p>
<p>将等式(5)带入等式(6)得</p>
<p><span class="math display">\[
\delta = \arctan(\frac{2\sin(\alpha)L}{l_d})\tag{7}
\]</span></p>
]]></content>
      <categories>
        <category>控制算法</category>
        <category>路径跟踪</category>
      </categories>
      <tags>
        <tag>几何模型</tag>
        <tag>路径追踪</tag>
        <tag>纯追踪法</tag>
      </tags>
  </entry>
  <entry>
    <title>控制算法-跟踪误差动力学模型</title>
    <url>/2019/12/04/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-%E8%B7%9F%E8%B8%AA%E8%AF%AF%E5%B7%AE%E5%8A%A8%E5%8A%9B%E5%AD%A6%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>使用相对与目标曲线的位置和方向误差作为动力学模型的状态变量开发转向控制系统似乎更合适一些，对于<a href="https://zgh551.github.io/2019/12/02/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-%E5%8A%A8%E5%8A%9B%E5%AD%A6%E6%A8%A1%E5%9E%8B/">车辆模型-动力学模型</a>章节中的动力学模型，需重新定义一下误差变量：</p>
<ul>
<li><span class="math inline">\(e_y\)</span>:车辆重心到目标曲线的距离；</li>
<li><span class="math inline">\(e_{\psi}\)</span>:车辆相对于目标曲线的方向误差；</li>
</ul>
<p>假设车辆纵向速度<span class="math inline">\(V_x\)</span>恒定且行驶路径的转弯半径<span class="math inline">\(R\)</span>不变，其中转弯半径<span class="math inline">\(R\)</span>足够大，以满足上述章节的小角度近似假设。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/SxsNHoFEdQjv5bP.jpg" alt="菊花展" /><figcaption aria-hidden="true">菊花展</figcaption>
</figure>
<span id="more"></span>
<h2 id="基本概念">基本概念</h2>
<h3 id="目标参数">目标参数</h3>
<ul>
<li>定义车辆<strong>目标偏航角速度</strong>为</li>
</ul>
<p><span class="math display">\[
\dot{\psi}_{des} = \frac{V_x}{R} \tag{1}
\]</span></p>
<ul>
<li>定义车辆<strong>目标向心加速度</strong>为</li>
</ul>
<p><span class="math display">\[
a_{des} = \frac{V_x^2}{R} = V_x\frac{V_x}{R}=V_x\dot{\psi}_{des}\tag{2}
\]</span></p>
<h3 id="误差定义">误差定义</h3>
<ul>
<li>定义车辆<strong>偏航角误差</strong>为</li>
</ul>
<p><span class="math display">\[
e_{\psi} = \psi - \psi_{des} \tag{3}
\]</span></p>
<ul>
<li>定义车辆<strong>偏航角速度误差</strong>为</li>
</ul>
<p><span class="math display">\[
\dot{e}_{\psi} = \dot{\psi} - \dot{\psi}_{des} \tag{4}
\]</span></p>
<ul>
<li>定义车辆<strong>偏航角加速度误差</strong>为</li>
</ul>
<p><span class="math display">\[
\ddot{e}_{\psi} = \ddot{\psi} - \ddot{\psi}_{des} \tag{5}
\]</span></p>
<ul>
<li>定义车辆<span class="math inline">\(y\)</span>轴方向的<strong>加速度误差</strong>为</li>
</ul>
<p><span class="math display">\[
\ddot{e}_y = a_y - a_{des} \qquad\qquad\qquad\\
=(\ddot{y} + V_x\dot{\psi}) - V_x\dot{\psi}_{des} \\
=\ddot{y} + V_x(\dot{\psi} - \dot{\psi}_{des})\quad \tag{3}
\]</span></p>
<ul>
<li>定义车辆<span class="math inline">\(y\)</span>轴方向的<strong>速度误差</strong>为</li>
</ul>
<p>当车辆纵向速度恒定时，<span class="math inline">\(y\)</span>轴方向的速度误差可以表示为</p>
<p><span class="math display">\[
\dot{e}_y = \int \ddot{e}_y\mathrm{d}t = \dot{y} + V_x(\psi - \psi_{des}) \tag{6}
\]</span></p>
<p>当纵向速度不再恒定，随着时间变化时，对等式(3)积分得 <span class="math display">\[
\dot{e}_y = \int \ddot{e}_y\mathrm{d}t = \dot{y} +\int V_x(\psi - \psi_{des})\mathrm{d}t \tag{7}
\]</span></p>
<p>这就使得模型非线性且时变，不利于控制系统的设计。因此解决方法就是假设纵向速度是恒定，这就获得了一个<strong>线性时不变</strong>(<strong>LTI</strong>)模型。如果速度变化，LTI模型就需要使用线性参变模型(LPV)替代，这个模型中纵向速度是一个随着时间变化的参数。</p>
<h2 id="跟踪误差动力学模型">跟踪误差动力学模型</h2>
<p>上述等式(3)、(6)可以变换如下：</p>
<p><span class="math display">\[
\ddot{y}  =\ddot{e}_y + V_x\dot{\psi}_{des} - V_x\dot{\psi}\tag{8}
\]</span></p>
<p><span class="math display">\[
 \dot{y} =\dot{e}_y - V_xe_{\psi} \tag{9}
\]</span></p>
<p>根据<a href="https://zgh551.github.io/2019/12/02/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-%E5%8A%A8%E5%8A%9B%E5%AD%A6%E6%A8%A1%E5%9E%8B/">车辆模型-动力学模型(Dynamics Model)</a>章节中的等式(14)</p>
<p><span class="math display">\[
\ddot{y} = -\frac{2C_{\alpha f } + 2C_{\alpha r}}{mV_x}\dot{y}   - ( V_x +  \frac{2C_{\alpha f}l_f- 2C_{\alpha r}l_r}{mV_x})\dot{\psi}  + \frac{2C_{\alpha f}}{m} \delta \tag{10}
\]</span></p>
<p>将等式(8)和(9)代入等式(10)得</p>
<p><span class="math display">\[
\ddot{e}_y + V_x\dot{\psi}_{des} = -\frac{2C_{\alpha f } + 2C_{\alpha r}}{mV_x}(\dot{e}_y - V_xe_{\psi})   - ( V_x +  \frac{2C_{\alpha f}l_f- 2C_{\alpha r}l_r}{mV_x})\dot{\psi}  + \frac{2C_{\alpha f}}{m} \delta \tag{11}
\]</span></p>
<p>对等式(11)进行简化，提取<span class="math inline">\(\ddot{e}_y\)</span>、<span class="math inline">\(\dot{e}_y\)</span>、<span class="math inline">\(e_y\)</span>、<span class="math inline">\(\dot{\psi}_{des}\)</span>和<span class="math inline">\(\delta\)</span>项得</p>
<p><span class="math display">\[
\ddot{e}_y = \frac{-2C_{\alpha f}-2C_{\alpha r}}{mV_x}\dot{e}_y + \frac{2C_{\alpha f}+2C_{\alpha r}}{m}e_{\psi} +
\frac{-2C_{\alpha f}l_f + 2C_{\alpha r}l_r}{mV_x}\dot{e}_{\psi} \\+ (\frac{-2C_{\alpha f}l_f + 2C_{\alpha r}l_r}{mV_x}-V_x)\dot{\psi}_{des} +\frac{2C_{\alpha f}}{m}\delta \tag{12}
\]</span></p>
<p>整理成矩阵形式为</p>
<p><span class="math display">\[
\frac{\mathrm{d}}{\mathrm{d}t}\dot{e}_y =
\begin{bmatrix}
0 &amp;
-\dfrac{2C_{\alpha f } + 2C_{\alpha r}}{mV_x} &amp;
\dfrac{2C_{\alpha f}+2C_{\alpha r}}{m} &amp;
\dfrac{-2C_{\alpha f}l_f + 2C_{\alpha r}l_r}{mV_x}
\end{bmatrix}
\begin{bmatrix}
e_y\\
\dot{e}_y\\
e_{\psi}\\
\dot{e}_{\psi}
\end{bmatrix}\\
+(\dfrac{-2C_{\alpha f}l_f + 2C_{\alpha r}l_r}{mV_x} - V_x)\dot{\psi}_{des}+\frac{2C_{\alpha f}}{m}\delta \tag{13}
\]</span></p>
<p>同理根据<a href="https://zgh551.github.io/2019/12/02/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-%E5%8A%A8%E5%8A%9B%E5%AD%A6%E6%A8%A1%E5%9E%8B/">车辆模型-动力学模型(Dynamics Model)</a>章节中的等式(17)</p>
<p><span class="math display">\[
\ddot{\psi} = - \frac{2l_fC_{\alpha f} - 2l_rC_{\alpha r}}{I_zV_x}\dot{y}  - \frac{2{l_f}^2C_{\alpha f} + 2{l_r}^2C_{\alpha r}}{I_zV_x}\dot{\psi} + \frac{2l_fC_{\alpha f}}{I_z}\delta\tag{14}
\]</span></p>
<p>将等式(5)、(8)和(9)代入等式(14)得</p>
<p><span class="math display">\[
\ddot{e}_{\psi}+ \ddot{\psi}_{des} = - \frac{2l_fC_{\alpha f} - 2l_rC_{\alpha r}}{I_zV_x}(\dot{e}_y - V_xe_{\psi})  - \frac{2{l_f}^2C_{\alpha f} + 2{l_r}^2C_{\alpha r}}{I_zV_x}\dot{\psi} + \frac{2l_fC_{\alpha f}}{I_z}\delta\tag{15}
\]</span></p>
<p>对等式(15)进行简化，提取<span class="math inline">\(\ddot{e}_y\)</span>、<span class="math inline">\(\dot{e}_y\)</span>、<span class="math inline">\(e_y\)</span>、<span class="math inline">\(\dot{\psi}_{des}\)</span>和<span class="math inline">\(\delta\)</span>项得</p>
<p><span class="math display">\[
\ddot{e}_{\psi} = - \frac{2l_fC_{\alpha f} - 2l_rC_{\alpha r}}{I_zV_x}\dot{e}_y + \frac{2l_fC_{\alpha f} - 2l_rC_{\alpha r}}{I_z}e_{\psi}\\
-\frac{2{l_f}^2C_{\alpha f} + 2{l_r}^2C_{\alpha r}}{I_zV_x}\dot{e}_{\psi}
-\frac{2{l_f}^2C_{\alpha f} + 2{l_r}^2C_{\alpha r}}{I_zV_x}\dot{\psi}_{des} + \frac{2l_fC_{\alpha f}}{I_z}\delta - \ddot{\psi}_{des} \tag{16}
\]</span></p>
<p>由于上述假设为<strong>线性时不变系统(LTI)</strong>(<span class="math inline">\(\dot{V}_x = 0\)</span>)，故<span class="math inline">\(\ddot{\psi}_{des}=\frac{\dot{V}_x}{R} = 0\)</span>，将上述等式整理成矩阵形式得</p>
<p><span class="math display">\[
\frac{\mathrm{d}}{\mathrm{d}t}\dot{e}_{\psi} =
\begin{bmatrix}
0 &amp;
-\dfrac{2l_fC_{\alpha f} - 2l_rC_{\alpha r}}{I_zV_x} &amp;
\dfrac{2l_fC_{\alpha f} - 2l_rC_{\alpha r}}{I_z} &amp;
-\dfrac{2{l_f}^2C_{\alpha f} + 2{l_r}^2C_{\alpha r}}{I_zV_x}
\end{bmatrix}
\begin{bmatrix}
e_y\\
\dot{e}_y\\
e_{\psi}\\
\dot{e}_{\psi}
\end{bmatrix}\\
-\frac{2{l_f}^2C_{\alpha f} + 2{l_r}^2C_{\alpha r}}{I_zV_x}\dot{\psi}_{des}+\frac{2l_fC_{\alpha f}}{I_z}\delta \tag{17}
\]</span></p>
<p>根据等式(13)和(17)，基于跟踪误差变量的状态空间模型表示为</p>
<p><span class="math display">\[
\frac{\mathrm{d}}{\mathrm{d}t}
\begin{bmatrix}
e_y\\
\dot{e}_y\\
e_{\psi}\\
\dot{e}_{\psi}
\end{bmatrix}=
\begin{bmatrix}
0 &amp; 1 &amp; 0 &amp; 0\\
0 &amp;
-\dfrac{2C_{\alpha f } + 2C_{\alpha r}}{mV_x} &amp;
\dfrac{2C_{\alpha f}+2C_{\alpha r}}{m} &amp;
\dfrac{-2C_{\alpha f}l_f + 2C_{\alpha r}l_r}{mV_x}\\
0 &amp; 0 &amp; 0 &amp; 1\\
0 &amp;
-\dfrac{2l_fC_{\alpha f} - 2l_rC_{\alpha r}}{I_zV_x} &amp;
\dfrac{2l_fC_{\alpha f} - 2l_rC_{\alpha r}}{I_z} &amp;
-\dfrac{2{l_f}^2C_{\alpha f} + 2{l_r}^2C_{\alpha r}}{I_zV_x}
\end{bmatrix}
\begin{bmatrix}
e_y\\
\dot{e}_y\\
e_{\psi}\\
\dot{e}_{\psi}
\end{bmatrix}\\
+
\begin{bmatrix}
0\\
\dfrac{2C_{\alpha f}}{m}\\
0\\
\dfrac{2l_fC_{\alpha f}}{I_z}
\end{bmatrix}\delta+
\begin{bmatrix}
0\\
(\dfrac{-2C_{\alpha f}l_f + 2C_{\alpha r}l_r}{mV_x} - V_x)\\
0\\
-\dfrac{2{l_f}^2C_{\alpha f} + 2{l_r}^2C_{\alpha r}}{I_zV_x}
\end{bmatrix}\dot{\psi}_{des}\tag{18}
\]</span></p>
<p>上述状态空间模型，将转向控制系统的目标跟踪问题转化为动力学的稳定性问题。 状态空间模型一般形式如下：</p>
<p><span class="math display">\[
\dot{x} = Ax + B_1\delta + B_2\dot{\psi}_{des}
\]</span></p>
]]></content>
      <categories>
        <category>控制算法</category>
        <category>车辆模型</category>
      </categories>
      <tags>
        <tag>跟踪误差模型</tag>
        <tag>动力学模型</tag>
      </tags>
  </entry>
  <entry>
    <title>控制算法-路径跟踪</title>
    <url>/2020/02/23/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-%E8%B7%AF%E5%BE%84%E8%B7%9F%E8%B8%AA%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>本文介绍常见几种路径跟踪算法，并分析各自的优势。目前主要分为基于几何关系控制设计和基于模型的控制设计。其中几何关系可以分为，纯追踪算法、前轴反馈和后轴反馈算法。基于模型可以分为运动模型和动力学模型，控制算法可以使用LQR优化或者使用MPC。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/H48QzVhRnge6Ec7.jpg" alt="喇叭花" /><figcaption aria-hidden="true">喇叭花</figcaption>
</figure>
<span id="more"></span>
<h2 id="基于几何关系设计">基于几何关系设计</h2>
<h3 id="纯追踪算法">纯追踪算法</h3>
<p>待补充</p>
<h3 id="前轴反馈">前轴反馈</h3>
<p>前轴反馈控制也就是常说的Stanley方法，几何关系如下：</p>
<p><img data-src="https://i.loli.net/2021/08/30/kVdqQai6KhGrelT.png" alt="前轴反馈" style="zoom:80%;" /></p>
<h4 id="三角函数曲线跟踪">三角函数曲线跟踪</h4>
<p><img data-src="https://i.loli.net/2021/08/30/to9hPGfxzk1LXnl.png" /></p>
<p><img data-src="https://i.loli.net/2021/08/30/qR7Zg6nM2ythaAk.png" /></p>
<h4 id="圆弧跟踪">圆弧跟踪</h4>
<p><img data-src="https://i.loli.net/2021/08/30/Qg3jSZLXif7Dqxc.png" /></p>
<p><img data-src="https://i.loli.net/2021/08/30/Hc4Ab2qGKdvZTwV.png" /></p>
<h3 id="后轴反馈">后轴反馈</h3>
<p><img data-src="https://i.loli.net/2021/08/30/YbBKN6kUmxnAuWL.png" alt="后轴反馈" style="zoom:80%;" /></p>
<h4 id="仿真系统框图">仿真系统框图</h4>
<p>基于下图框图，搭建仿真环境，仿真条件如下：</p>
<ol type="1">
<li>仿真周期20ms</li>
<li>目标曲线采样间隔 5</li>
<li>初始位置(0,0)</li>
<li>初始偏航角0度</li>
</ol>
<figure>
<img data-src="https://i.loli.net/2021/08/30/9YFO1wxWV3jsJuU.png" alt="仿真系统框图" /><figcaption aria-hidden="true">仿真系统框图</figcaption>
</figure>
<h4 id="余弦曲线跟踪">余弦曲线跟踪</h4>
<figure>
<img data-src="https://i.loli.net/2021/08/30/JbyuLNvZHDlhE6q.png" alt="余弦曲线跟踪误差对比" /><figcaption aria-hidden="true">余弦曲线跟踪误差对比</figcaption>
</figure>
<p>由上图可知，对于曲率连续变化的跟踪效果较好。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/qR7Zg6nM2ythaAk.png" alt="余弦曲线跟踪控制率" /><figcaption aria-hidden="true">余弦曲线跟踪控制率</figcaption>
</figure>
<p>输出控制抖动也较小。</p>
<h4 id="圆弧跟踪-1">圆弧跟踪</h4>
<figure>
<img data-src="https://i.loli.net/2021/08/30/1An7yMSvCTNYpJz.png" alt="圆弧跟踪误差对比" /><figcaption aria-hidden="true">圆弧跟踪误差对比</figcaption>
</figure>
<p>由上图可知，对于曲率恒定的圆弧曲线，控制效果较差，存在较大的位置偏差。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/F7GJSnNzgyi6W3v.png" alt="圆弧跟踪控制率" /><figcaption aria-hidden="true">圆弧跟踪控制率</figcaption>
</figure>
<p>由上图可知，控制率震荡较大。</p>
<h4 id="c仿真效果">C++仿真效果</h4>
<p>仿真条件：</p>
<ul>
<li>初始位置为<span class="math display">\[(0,0)\]</span></li>
<li>初始偏航角为<span class="math display">\[0\]</span>度</li>
<li>仿真周期20ms</li>
<li>目标曲线采样间隔 1</li>
</ul>
<p>车辆刚起步时，由于输出转向角为0，而此时的圆弧曲率为-0.2，所以存在一段转向角按照最大角速度转到目标转向角的过程。跟踪过程中，从图中转向角的振荡幅度存在小范围的变化。在两个圆弧的交界处，由于曲率由-0.2突变到0.2，方向盘转向角需要按照最大角速度转到目标角度。在该过程中存在较大误差，但是在角度达到目标角度后，误差逐渐缩小，最后完全跟踪上目标曲线。</p>
<h5 id="圆弧前进">圆弧前进</h5>
<figure>
<img data-src="https://i.loli.net/2021/08/30/uDGjqHKANykIg4U.gif" alt="圆弧前进" /><figcaption aria-hidden="true">圆弧前进</figcaption>
</figure>
<h5 id="圆弧后退">圆弧后退</h5>
<figure>
<img data-src="https://i.loli.net/2021/08/30/aWeYsn983ZXRbE7.gif" alt="圆弧后退" /><figcaption aria-hidden="true">圆弧后退</figcaption>
</figure>
<h2 id="基于模型设计">基于模型设计</h2>
<h3 id="运动学模型">运动学模型</h3>
<h3 id="动力学模型">动力学模型</h3>
<h2 id="参考">参考</h2>
<ol type="1">
<li><a href="https://zgh551.github.io/2020/02/23/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-Stanley%E6%B3%95/#more">前轴反馈控制算法</a></li>
<li><a href="https://zgh551.github.io/2020/02/26/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-%E5%90%8E%E8%BD%AE%E4%BD%8D%E7%BD%AE%E5%8F%8D%E9%A6%88/">后轴反馈控制算法</a></li>
<li><a href="https://zgh551.github.io/2020/02/23/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-%E7%BA%AF%E8%BF%BD%E8%B8%AA%E6%B3%95/">纯追踪控制算法</a></li>
</ol>
]]></content>
      <categories>
        <category>控制算法</category>
        <category>路径跟踪</category>
      </categories>
      <tags>
        <tag>路径跟踪</tag>
        <tag>纯追踪法</tag>
        <tag>动力学模型</tag>
        <tag>Stanley法</tag>
        <tag>运动学模型</tag>
        <tag>转向控制</tag>
      </tags>
  </entry>
  <entry>
    <title>车辆停车优化</title>
    <url>/2019/11/11/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-%E8%BD%A6%E8%BE%86%E5%81%9C%E8%BD%A6%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>车辆控制中，如何舒适平衡的停车也是一个比较讲究的事。日常生活中，对于一个刚接触车的新手，控车时可能会猛踩刹车，给人一种很冲的感觉。但是对于老司机，每次踩刹车都是先轻踩，然后逐渐增大踩刹车的力度，这样对于乘客来说就会感觉很舒适。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/T3i8DBrFA7zSRPv.jpg" alt="世纪公园" /><figcaption aria-hidden="true">世纪公园</figcaption>
</figure>
<span id="more"></span>
<h2 id="模型">模型</h2>
<p>为了模拟出舒适的停车体验，使用变减速度的速度模型进行车辆停车控制。假设<strong>加速度的变化率</strong>为<span class="math inline">\(\dot{a}\)</span>，则<strong>加速度</strong>与<strong>加速度变化率</strong>的关系为</p>
<p><span class="math display">\[
\dot{a} * t = a \tag{1}
\]</span></p>
<p>对应的减速度曲线如下图所示：</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/exlCYdmJbpOk1IA.png" alt="减速度曲线" /><figcaption aria-hidden="true">减速度曲线</figcaption>
</figure>
<p>对等式(1)求导得<strong>速度</strong>与<strong>加速度的变化率</strong>的关系为 <span class="math display">\[
v_0 - \int_0^{t}a*dt = v \Longrightarrow v_0 - \frac{1}{2}\dot{a}*t^2 = v \tag{2}
\]</span></p>
<p>由于减速度一直变化，对应的速度曲线如下图所示：</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/peAHWyGjz6cCm8L.png" alt="速度曲线" /><figcaption aria-hidden="true">速度曲线</figcaption>
</figure>
<p>图中速度曲线下方的面积<span class="math inline">\(S\)</span>为行驶的位移，根据上述速度曲线，车辆运动模型如下：</p>
<p><span class="math display">\[
\int_0^{t}vdt = S \Longrightarrow v_0*t - \frac{1}{6}\dot{a}t^3 = S
\]</span></p>
<p>当速度从<span class="math inline">\(v_0\)</span>下降到0的过程中，时间<span class="math inline">\(t_0\)</span>为：</p>
<p><span class="math display">\[
v_0 - \frac{1}{2}\dot{a}*t^2 = 0 \Longrightarrow t_0 = {(\frac{2*v_0}{\dot{a}})}^{\frac{1}{2}}
\]</span></p>
<p>将时间<span class="math inline">\(t_0\)</span>代入得：</p>
<p><span class="math display">\[
t_0*(v_0 - \frac{1}{6}\dot{a}{t_0}^2) = S \Longrightarrow {(\frac{2*v_0}{\dot{a}})}^{\frac{1}{2}} * (v_0 - \frac{1}{6}\dot{a}\frac{2*v_0}{\dot{a}}) = S\\
{(\frac{2*v_0}{\dot{a}})}^{\frac{1}{2}}*\frac{2*v_0}{3} = S
\]</span></p>
<p>计算<span class="math inline">\(\dot{a}\)</span>得：</p>
<p><span class="math display">\[
\dot{a} = \frac{8 {v_0}^3}{9S^2}
\]</span></p>
<p>所以当控制车辆减速时，根据当前车辆速度<span class="math inline">\(v_0\)</span>和距离停车点的位移<span class="math inline">\(S\)</span>，计算出减速度的增量<span class="math inline">\(\dot{a}\)</span>，控制输出的减速度<span class="math inline">\(a = a - \dot{a}*dt\)</span>。</p>
]]></content>
      <categories>
        <category>控制算法</category>
      </categories>
      <tags>
        <tag>速度曲线</tag>
      </tags>
  </entry>
  <entry>
    <title>控制算法-运动学模型</title>
    <url>/2019/12/02/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-%E8%BF%90%E5%8A%A8%E5%AD%A6%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>车辆横向运动学模型描述了车辆横向运动的数学模型，该模型不考虑车辆的受力情况。一般考虑运动学模型时，将车辆模型简化成单车模型(bicycle model)。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/ot5fGZUwzhgNx94.jpg" alt="菊花展" /><figcaption aria-hidden="true">菊花展</figcaption>
</figure>
<span id="more"></span>
<h2 id="单车模型">单车模型</h2>
<p><img data-src="https://i.loli.net/2021/08/30/vNEmAlxMSaX9cWu.png" style="zoom: 80%;" /></p>
<p>单车模型中：</p>
<ul>
<li><p><strong>左右轮等效为单个轮子</strong> 左右前轮合并为单个轮子，其中心点为<span class="math inline">\(A\)</span>点，同样后轮等效后的中心点为<span class="math inline">\(B\)</span>点。</p></li>
<li><p><strong>转向角</strong> 前后轮的转向角用<span class="math inline">\(\delta_f\)</span>和<span class="math inline">\(\delta_r\)</span>表示，模型中前后轮都可以转向，对于只有前轮转向的系统，后轮转向角<span class="math inline">\(\delta_r\)</span>可以设置为0.</p></li>
<li><p><strong>重心</strong> 点<span class="math inline">\(C\)</span>代表车辆的重心，<span class="math inline">\(A\)</span>点和<span class="math inline">\(B\)</span>点到重心的距离分别用<span class="math inline">\(l_f\)</span>和<span class="math inline">\(l_r\)</span>表示，轴距表示为<span class="math inline">\(L = l_f + l_r\)</span>。</p></li>
<li><p><strong>速度</strong> 车辆重心的速度用<span class="math inline">\(V\)</span>表示，与车辆纵向轴的夹角为<span class="math inline">\(\beta\)</span>，该角度叫做车辆的滑移角。</p></li>
<li><p><strong>运动描述</strong> 假设车辆平动，车辆运动状态可以用三个坐标量描述：<span class="math inline">\(X\)</span> 、 <span class="math inline">\(Y\)</span> 和 <span class="math inline">\(\psi\)</span>。其中<span class="math inline">\((X,Y)\)</span>代表车辆重心的位置，<span class="math inline">\(\Psi\)</span>描述了车辆的方向。</p></li>
<li><p><strong>条件假设</strong> 假设速度矢量<span class="math inline">\(V\)</span>的方向在点<span class="math inline">\(A\)</span>点和<span class="math inline">\(B\)</span>点的方向与转向角的方向相同，换句话说，在A点的速度矢量与车辆纵轴的夹角为<span class="math inline">\(\delta_f\)</span>，同样<span class="math inline">\(B\)</span>点的速度矢量与车辆纵轴的夹角为<span class="math inline">\(\delta_r\)</span>。也就是说前后轮的滑移角都为0。该条件假设成立前提的是车辆速度很低(&lt;5m/s)，此时轮胎产生的横向力很小，可以忽略。</p></li>
<li><p><strong>轨迹半径</strong> 点<span class="math inline">\(O\)</span>代表车辆的瞬时旋转中心，线段<span class="math inline">\(AO\)</span>与<span class="math inline">\(BO\)</span>与前后两个转轮方向垂直，他们的交点即为<span class="math inline">\(O\)</span>点，线段<span class="math inline">\(OC\)</span>的长度代表车辆的轨迹半径<span class="math inline">\(R\)</span>。</p></li>
<li><p><strong>航迹角</strong> 车辆重心处的速度垂直于<span class="math inline">\(OC\)</span>,车辆速度矢量与车辆纵轴的夹角为<span class="math inline">\(\beta\)</span>，车辆的航向角为<span class="math inline">\(\psi\)</span>，则航迹角为<span class="math inline">\(\gamma = \psi + \beta\)</span>。</p></li>
</ul>
<h2 id="运动方程">运动方程</h2>
<p>运动方程可以根据单车模型几何关系推导出，下面根据单车模型的几何关系，推导出车辆运动的微分方程。</p>
<h3 id="姿态信息偏航角">姿态信息(偏航角)</h3>
<p>三角形<span class="math inline">\(OCA\)</span>根据正弦定理得</p>
<p><span class="math display">\[
\frac{\sin(\delta_f - \beta)}{l_f} = \frac{\sin(\frac{\pi}{2} - \delta_f)}{R} \tag{1}
\]</span></p>
<p>同理，三角形<span class="math inline">\(OCB\)</span>根据正弦定理可得</p>
<p><span class="math display">\[
\frac{\sin(\beta - \delta_r)}{l_r} = \frac{\sin(\frac{\pi}{2} + \delta_r)}{R} \tag{2}
\]</span></p>
<p>根据<strong>和差定理</strong>，等式(1)得</p>
<p><span class="math display">\[
\frac{\sin(\delta_f)\cos(\beta) - \cos(\delta_f)\sin(\beta)}{l_f} = \frac{\cos(\delta_f)}{R} \tag{3}
\]</span></p>
<p>同理，根据等式(2)得</p>
<p><span class="math display">\[
\frac{\cos(\delta_r)\sin(\beta) - \cos(\beta)\sin(\delta_r)}{l_r} = \frac{\cos(\delta_f)}{R} \tag{4}
\]</span></p>
<p>等式(3)两边同时乘<span class="math inline">\(\frac{l_f}{\cos(\delta_f)}\)</span>得</p>
<p><span class="math display">\[
\tan(\delta_f)\cos(\beta) - sin(\beta) = \frac{l_f}{R} \tag{5}
\]</span></p>
<p>同理，等式(4)两边同时乘<span class="math inline">\(\frac{l_r}{\cos(\delta_r)}\)</span>得</p>
<p><span class="math display">\[
sin(\beta) - \tan(\delta_r)\cos(\beta) = \frac{l_r}{R} \tag{6}
\]</span></p>
<p>等式(5)和(6)相加得</p>
<p><span class="math display">\[
\{\tan(\delta_f) - \tan(\delta_r)\}\cos(\beta) = \frac{l_f + l_r}{R} \tag{7}
\]</span></p>
<p>根据条件假设，车辆速度很低，车辆的轨迹半径变化就很慢。车辆偏航角的变化率(<span class="math inline">\(\dot{\psi}\)</span>)可以近似等于车辆的角速度(<span class="math inline">\(\omega\)</span>)。根据车辆角速度<span class="math inline">\(\omega = \frac{V}{R}\)</span>得</p>
<p><span class="math display">\[
\dot{\psi} = \frac{V}{R} \tag{8}
\]</span></p>
<p>将等式(8)带入等式(7)中，消除<span class="math inline">\(R\)</span>项得</p>
<p><span class="math display">\[
\dot{\psi} = \frac{V\cos(\beta)}{l_f + l_r}\{\tan(\delta_f) - \tan(\delta_r)\} \tag{9}
\]</span></p>
<p>上述等式一共三个输入变量：<span class="math inline">\(\delta_f\)</span> 、<span class="math inline">\(\delta_r\)</span>和<span class="math inline">\(V\)</span>。其中<span class="math inline">\(\delta_f\)</span>和<span class="math inline">\(\delta_r\)</span>是车辆的转向角，可以通过车身传感器获得。<span class="math inline">\(V\)</span>是一个外部变量，可以假设其为时变函数，可以从纵向控制中获得。</p>
<h4 id="滑移角beta的计算">滑移角<span class="math inline">\(\beta\)</span>的计算</h4>
<p>等式(5)乘以<span class="math inline">\(l_r\)</span>，</p>
<p><span class="math display">\[
\tan(\delta_f)\cos(\beta)l_r - sin(\beta)l_r = \frac{l_f*l_r}{R} \tag{10}
\]</span></p>
<p>等式(6)乘以<span class="math inline">\(l_f\)</span>得</p>
<p><span class="math display">\[
sin(\beta)l_f - \tan(\delta_r)\cos(\beta)l_f = \frac{l_f*l_r}{R} \tag{11}
\]</span></p>
<p>等式(10)和(11)相减得</p>
<p><span class="math display">\[
\cos(\beta)(l_f\tan(\delta_r) + l_r\tan(\delta_f)) = \sin(\beta)(l_f + l_r) \tag{12}
\]</span></p>
<p>等式(12)两端同时乘以<span class="math inline">\(\frac{1}{\cos(\beta)}\)</span>得</p>
<p><span class="math display">\[
\tan(\beta) = \frac{l_f\tan(\delta_r) + l_r\tan(\delta_f)}{l_f + l_r} \tag{13}
\]</span></p>
<p>故取反三角函数得</p>
<p><span class="math display">\[
\beta = \arctan(\frac{l_f\tan(\delta_r) + l_r\tan(\delta_f)}{l_f + l_r} \tag{13})
\]</span></p>
<h3 id="位置信息">位置信息</h3>
<p>根据单车模型得</p>
<p><span class="math display">\[
\dot{X} = V\cos(\beta + \psi) \tag{14}
\]</span> <span class="math display">\[
\dot{Y} = V\sin(\beta + \psi) \tag{15}
\]</span></p>
<h2 id="补充">补充</h2>
<p><img data-src="https://i.loli.net/2021/08/30/CZdbvJf1uQzR47S.png" style="zoom: 80%;" /></p>
<p>由上图可知，<span class="math inline">\(l_w\)</span>为车轴宽度，为了避免与上述单车模型的转向角定义重复，使用<span class="math inline">\(\delta_o\)</span>表示外部转向角，<span class="math inline">\(\delta_i\)</span>表示内部转向角。由于轴距<span class="math inline">\(L = l_f + l_r\)</span>远远小于轨迹半径<span class="math inline">\(R\)</span>，滑移角<span class="math inline">\(\beta\)</span>接近于0。一般车辆模型后轴为固定轴，故<span class="math inline">\(\delta_r\)</span>为0，所以等式(9)可以近似为</p>
<p><span class="math display">\[
\dot{\psi} = \frac{V}{L}\tan(\delta_f) \tag{16}
\]</span></p>
<p>由于<span class="math inline">\(\delta_f\)</span>很小</p>
<p><span class="math display">\[
\tan(\delta_f) \approx \delta_f \tag{17}
\]</span></p>
<p>根据等式(8)和等式(16)得</p>
<p><span class="math display">\[
\frac{\dot{\psi}}{V} \approx \frac{\delta_f}{L} = \frac{1}{R} \tag{18}
\]</span></p>
<p>故不区分前后轴，等效转向角为</p>
<p><span class="math display">\[
\delta = \frac{L}{R} \tag{19}
\]</span></p>
<p>由于内外轮的转弯半径不同，根据等式(19),外轮转角为</p>
<p><span class="math display">\[
\delta_o = \frac{L}{R + \frac{l_w}{2}} \tag{20}
\]</span></p>
<p>内轮转角为</p>
<p><span class="math display">\[
\delta_i = \frac{L}{R - \frac{l_w}{2}} \tag{21}
\]</span></p>
<p>故前轮平均转向角为</p>
<p><span class="math display">\[
\delta = \frac{\delta_o + \delta_i}{2} = \frac{L}{R - \frac{l_w^2}{4R}} \tag{22}
\]</span></p>
<p>由于<span class="math inline">\(\frac{l_w^2}{4R}\)</span>项中，<span class="math inline">\(l_w\)</span>远远小于<span class="math inline">\(R\)</span>,且<span class="math inline">\(l_w\)</span>的二次项更小，故</p>
<p><span class="math display">\[
\frac{l_w^2}{4R} \cong 0 \tag{23}
\]</span></p>
<p>所以等式(22)可以近似为</p>
<p><span class="math display">\[
\delta = \frac{L}{R} \tag{24}
\]</span></p>
<p>比较等式(20)和(21)知，<span class="math inline">\(\delta_i\)</span>始终大于<span class="math inline">\(\delta_o\)</span>，故</p>
<p><span class="math display">\[
\delta_i - \delta_o = \frac{L}{R - \frac{l_w}{2}} - \frac{L}{R + \frac{l_w}{2}} \quad\\
=\frac{Ll_w}{R^2 - \frac{l_w^2}{4}} \qquad\\
\cong \frac{L}{R^2}l_w = \delta^2\frac{l_w}{L} \tag{25}
\]</span></p>
<p>根据等式(25)可知，前轮内外转向角的差值接近于平均转向角的二次方，所以当前轮转向角较大时，内外轮的转向角误差就越大。</p>
<h2 id="结论">结论</h2>
<p>车辆运动模型基于单车模型推导，推导过程不考虑车辆受到的横向力，故该模型只适用于车辆速度很低的情形。</p>
<p><span class="math display">\[
a = \frac{mV^2}{R} \tag{26}
\]</span></p>
<p>根据等式(26)知，速度很小时，车辆受到的向心力可以忽略不记，所以才有公式(8)的成立。所以当车辆的运动场景速度较低时，可以使用该模型描述车辆的运动。</p>
<h3 id="微分方程形式">微分方程形式</h3>
<p>根据等式(9)、(14)和(15)，对于前轮转向系统，<span class="math inline">\(\delta_r = 0\)</span>，可得</p>
<p><span class="math display">\[
\dot{X} = V\cos(\beta + \psi) \qquad\\
\dot{Y} = V\sin(\beta + \psi) \qquad\\
\dot{\psi} = \frac{V\cos(\beta)\tan(\delta_f)}{L}
\]</span></p>
<p>其中</p>
<p><span class="math display">\[
\beta = \arctan(\frac{l_r\tan(\delta_f)}{l_f + l_r})
\]</span></p>
<p>假设车辆重心点在后轴中心点，则<span class="math inline">\(beta \cong 0\)</span>，由上述微分方程得</p>
<p><span class="math display">\[
\dot{X} = V\cos(\psi) \quad\\
\dot{Y} = V\sin(\psi) \quad\\
\dot{\psi} = \frac{V\tan(\delta_f)}{L}
\]</span></p>
<h2 id="参考">参考</h2>
<ol type="1">
<li>" vehicle dynamics and control "</li>
</ol>
]]></content>
      <categories>
        <category>控制算法</category>
        <category>车辆模型</category>
      </categories>
      <tags>
        <tag>车辆模型</tag>
        <tag>车辆控制</tag>
        <tag>运动模型</tag>
        <tag>单车模型</tag>
        <tag>Kinematic Model</tag>
        <tag>bycycle model</tag>
      </tags>
  </entry>
  <entry>
    <title>控制算法-非时间参考的车辆路径跟踪</title>
    <url>/2019/12/23/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-%E9%9D%9E%E6%97%B6%E9%97%B4%E5%8F%82%E8%80%83%E7%9A%84%E8%BD%A6%E8%BE%86%E8%B7%AF%E5%BE%84%E8%B7%9F%E8%B8%AA/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>基于非时间的参考的路径跟踪方法最早应用于机器人的路径跟踪系统，通过引入非时间参考量代替时间参考量，解决传统路径跟踪方法中将期望轨迹视为时间函数的问题。该方法选择移动机器人实际路径在某参考系下的x 轴投影作为非时间参考量。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/KaPA5HQMmo8WnDZ.jpg" alt="国家会议中心" /><figcaption aria-hidden="true">国家会议中心</figcaption>
</figure>
<span id="more"></span>
<h2 id="非时间参考量下的微分方程">非时间参考量下的微分方程</h2>
<h3 id="定义">定义</h3>
<p>定义一个非时间参考的标量<span class="math inline">\(s\)</span>,该<span class="math inline">\(s\)</span>为时间t的单调递增函数。</p>
<p><span class="math display">\[
\left\{
\begin{array}{rl}
&amp;s = S(t)\\
&amp;\dot{S}(t) &gt; 0
\end{array}
\right.\tag{1}
\]</span></p>
<p>在车辆控制中，可以定义车辆的位移<span class="math inline">\(x\)</span>为非时间参考量，为了满足随时间递增的要求，且泊车时速度为负值<span class="math inline">\((v&lt;0)\)</span>，选取的非时间参考量为</p>
<p><span class="math display">\[
f = -x(t) \tag{2}
\]</span></p>
<p>对上式求导得</p>
<p><span class="math display">\[
\dot{f}(t) = -v(t)\cos\psi(t) \tag{3}
\]</span></p>
<p>由于车辆泊车过程中偏航角<span class="math inline">\(\psi \in (-\frac{\pi}{2},\frac{\pi}{2})\)</span>，故<span class="math inline">\(\dot{f}(t)&gt;0\)</span>，满足非时间参考量随时间变化单调递增得要求。</p>
<p>基于非时间参考的车辆运动学方程可表示为: <span class="math display">\[
\left \{
\begin{array}{cl}
&amp;\dfrac{dx}{df}= \dfrac{dx}{dt}\dfrac{dt}{df} = \dfrac{\dot{x}(t)}{\dot{f}(t)}\\
&amp;\dfrac{dy}{df}= \dfrac{dy}{dt}\dfrac{dt}{df} = \dfrac{\dot{y}(t)}{\dot{f}(t)}\\
&amp;\dfrac{d\psi}{df}= \dfrac{d\psi}{dt}\dfrac{dt}{df} = \dfrac{\dot{\psi}(t)}{\dot{f}(t)}
\end{array}
\right. \tag{4}
\]</span></p>
<h3 id="目标路径曲线">目标路径曲线</h3>
<p>假设目标路径曲线函数为<span class="math inline">\(y_r = F(x_r)\)</span>，如果车辆可以无误差地跟踪，当车辆后轴中心横坐标为<span class="math inline">\(x_r\)</span>时，对应的纵坐标为<span class="math inline">\(y_r\)</span>、航向角为<span class="math inline">\(\psi_r\)</span>、前轮等效转角为<span class="math inline">\(\delta_r\)</span>。</p>
<ul>
<li>目标航向角<span class="math inline">\(\psi_r\)</span>计算</li>
</ul>
<p>目标航向角<span class="math inline">\(\psi_r\)</span>可以看作是函数<span class="math inline">\(y_r = F(x_r)\)</span>在点<span class="math inline">\(x_r\)</span>处的斜率所对应的航向角度，即</p>
<p><span class="math display">\[
\tan(\psi_r) = \dot{F}(x_r)= \frac{dy_r}{dx_r} \tag{5}
\]</span></p>
<p>通过反三角函数求得目标航向角为</p>
<p><span class="math display">\[
\psi_r = \arctan\bigl(\dot{F}(x_r)\bigr)= \arctan(\frac{dy_r}{dx_r}) \tag{6}
\]</span></p>
<ul>
<li>目标转向角<span class="math inline">\(\delta_r\)</span>计算</li>
</ul>
<p>根据转向角的几何关系得</p>
<p><span class="math display">\[
\delta_r = \arctan(l*k) \tag{7}
\]</span></p>
<p>其中，<span class="math inline">\(l\)</span>代表车辆轴距、<span class="math inline">\(k\)</span>代表点<span class="math inline">\(x_r\)</span>处的目标路径曲线的曲率。</p>
<p>根据轨迹函数<span class="math inline">\(y_r = F(x_r)\)</span>的一阶导数和二阶导数，曲率计算公式表示如下：</p>
<p><span class="math display">\[
k = \frac{\rvert\ddot{F}(x_r)\rvert}{[1+\dot{F}(x_r)^{2}]^\frac{3}{2}} \tag{8}
\]</span></p>
<p>根据目标路径曲线，如果某段曲线是凸的，对应的二阶导数<span class="math inline">\(\ddot{F}(x_r) &lt; 0\)</span>。很明显，当偏航角满足<span class="math inline">\(\psi \in (-\frac{\pi}{2},\frac{\pi}{2})\)</span>时，如果希望车辆跟踪凸形路线，对应的转向角应该为负值。同理，当曲线某段是凹形，对应的二阶导数<span class="math inline">\(\ddot{F}(x_r) &gt; 0\)</span>，要想继续跟踪路线，转向角应该为正值。考虑<span class="math inline">\(\delta_r\)</span>的正负性与曲线函数<span class="math inline">\(\ddot{F}(x_r)\)</span>的二阶导数符号一致，等式(8)的绝对值符号可以消除，将其带入等式(7)得</p>
<p><span class="math display">\[
\delta_r = \arctan\Biggl( l*\frac{\ddot{F}(x_r)}{[1+\dot{F}(x_r)^{2}]^\frac{3}{2}}\Biggr)\tag{9}
\]</span></p>
<p>将等式(5)带入等式(9)得</p>
<p><span class="math display">\[
\delta_r = \arctan\Bigl(l*\cos(\psi_r)^{3}\ddot{F}(x_r)\Bigr) \tag{10}
\]</span></p>
<p>通过等式(6)和(10)可知，已知目标路径函数的前提下，可以计算得到横坐标为<span class="math inline">\(x_r\)</span>下的车辆理想状态参数。</p>
<p><span class="math display">\[
\left \{
\begin{array}{cl}
&amp;\psi_r = \arctan\bigl(\dot{F}(x_r)\bigr)\\
&amp;\delta_r = \arctan\Bigl(l*\cos(\psi_r)^{3}\ddot{F}(x_r)\Bigr)
\end{array}
\right. \tag{11}
\]</span></p>
<h3 id="车辆跟踪误差模型">车辆跟踪误差模型</h3>
<p>车辆的跟踪误差表示如下： <span class="math display">\[
\left \{
\begin{array}{rl}
&amp;e_x= 0\\
&amp;e_y = y_r - y\\
&amp;e_\psi = \psi_r - \psi
\end{array}
\right.\tag{12}
\]</span></p>
<p>其中，<span class="math inline">\(y\)</span>和<span class="math inline">\(\psi\)</span>为车辆后轴中心点横坐标为<span class="math inline">\(x_r\)</span>时，对应的车辆实际状态参数。<span class="math inline">\(e_x\)</span>、<span class="math inline">\(e_y\)</span>和<span class="math inline">\(e_\psi\)</span>分别表示纵向误差、横向误差和航向角误差。</p>
<p>则以非时间参考量<span class="math inline">\(f = -x(t)\)</span>为参考的路径跟踪误差微分方程如下：</p>
<ul>
<li>纵向距离误差的微分方程</li>
</ul>
<p><span class="math display">\[
\begin{array}{rl}
\dfrac{dy_e}{-dx} &amp;= \dfrac{d(y_r-y)}{-dx}\\
&amp;=\dfrac{-dy_r}{dx} + \dfrac{dy}{dx}\\
&amp;=-tan(\psi_r) + \tan(\psi)
\end{array}\tag{13}
\]</span></p>
<ul>
<li>偏航角误差微分方程</li>
</ul>
<p>由等式(10)得</p>
<p><span class="math display">\[
\tan(\delta_r) = l*\cos(\varphi_r)^{3}\ddot{F}(x_r) \tag{14}
\]</span></p>
<p>等式(5)对<span class="math inline">\(x\)</span>求导得</p>
<p><span class="math display">\[
[1 + \tan(\psi_r)^2]*\frac{d\psi_r}{dx} = \ddot{F}(x_r) \tag{15}
\]</span></p>
<p>等式(15)带入等式(14)得</p>
<p><span class="math display">\[
\begin{array}{cl}
\tan(\delta_r) &amp;= l*\cos(\psi_r)^{3}*[1+\tan(\psi_r)^{2}]*\dfrac{d\psi_r}{dx}\\
&amp;= l*\cos(\psi_r)*\dfrac{d\psi_r}{dx}
\end{array} \tag{16}
\]</span></p>
<p>由于<span class="math inline">\(\psi \in (-\frac{\pi}{2},\frac{\pi}{2})\)</span>，故<span class="math inline">\(\cos(\psi_r) \neq 0\)</span>，等式(16)移项整理得</p>
<p><span class="math display">\[
\frac{d\psi_r}{dx} = \frac{\tan(\delta_r)}{l*\cos(\psi_r)} \tag{17}
\]</span></p>
<p>根据等式(17)，可得航向角误差的微分方程为</p>
<p><span class="math display">\[
\begin{array}{rl}
\dfrac{d\psi_e}{-dx} &amp;= -\dfrac{d\psi_r}{dx} + \dfrac{d\psi}{dx}\\
&amp;=-\dfrac{\tan(\delta_r)}{l*\cos(\psi_r)} + \dfrac{\tan(\delta)}{l*\cos(\psi)}
\end{array}\tag{18}
\]</span></p>
<p>整理等式(13)和(18)得</p>
<p><span class="math display">\[
\left \{
\begin{array}{rl}
&amp; \dfrac{de_y}{-dx} = -tan(\psi_r) + \tan(\psi)\\
&amp; \dfrac{de_\psi}{-dx} = -\dfrac{\tan(\delta_r)}{l*\cos(\psi_r)} + \dfrac{\tan(\delta)}{l*\cos(\psi)}
\end{array}
\right. \tag{19}
\]</span></p>
<h2 id="滑模控制器设计">滑模控制器设计</h2>
<p>滑模控制算法因算法简单、鲁棒性好、适应性强、实用性而被广泛运用。滑模控制的核心是设计处合适的切换函数和变结构控制率，使系统状态轨迹线能快速到达设计的切换面进行滑动模态运动。</p>
<h3 id="微分方程">微分方程</h3>
<p>系统参考状态量为：</p>
<p><span class="math display">\[
\left \{
\begin{array}{rl}
&amp;x_1 = y_r - y\\
&amp;x_2 = -tan(\psi_r) + \tan(\psi)
\end{array}
\right. \tag{20}
\]</span></p>
<p>结合等式(12)、(17)，对应的微分方程为：</p>
<p><span class="math display">\[
\left \{
\begin{array}{rl}
&amp;\dot{x_1} &amp;= \dfrac{dx_1}{-dx} &amp;= \dfrac{y_r - y}{-dx} &amp;= x_2\\
&amp;\dot{x_2} &amp;= \dfrac{dx_2}{-dx} &amp;=\dfrac{-tan(\psi_r) + \tan(\psi)}{-dx} 
&amp;= \dfrac{\tan(\delta_r)}{l*\cos(\psi_r)^3} - \dfrac{\tan(\delta)}{l*\cos(\psi)^3}
\end{array}
\right. \tag{21}
\]</span></p>
<h3 id="滑模面">滑模面</h3>
<p>定义滑模变量<span class="math inline">\(s\)</span>为：</p>
<p><span class="math display">\[
s = x_2 + c \cdot x_1 \tag{22}
\]</span></p>
<p>其中<span class="math inline">\(c &gt; 0\)</span>，结合等式(20)和(21)，对等式(22)求导得：</p>
<p><span class="math display">\[
\dot{s}=\frac{ds}{-dx} = \dfrac{\tan(\delta_r)}{l*\cos(\psi_r)^3} -\dfrac{\tan(\delta)}{l*\cos(\psi)^3} + c \cdot \bigl(\tan(\psi)-tan(\psi_r)\bigr) \tag{23}
\]</span></p>
<h3 id="基于趋近律的滑模控制">基于趋近律的滑模控制</h3>
<p>采用指数趋近率<span class="math inline">\(\dot{s} = -\rho \cdot sign(s) - k\cdot s\)</span>，可以减弱变结构控制系统的抖振。通过调整趋近率参数<span class="math inline">\(\rho\)</span>和<span class="math inline">\(k\)</span>，既可以保证滑动模态到达过程的动态品质，又可以减弱控制信号的高频抖振，但是较大的<span class="math inline">\(\rho\)</span>会引起抖振。</p>
<p>采用指数趋近率为</p>
<p><span class="math display">\[
\dot{s} = -\rho \cdot sign(s) - k\cdot s \tag{24}
\]</span></p>
<p>其中<span class="math inline">\(\rho &gt; 0\)</span>、<span class="math inline">\(k &gt; 0\)</span>、<span class="math inline">\(sign(s)\)</span>为符号函数。</p>
<h3 id="稳定判据">稳定判据</h3>
<p>定义李亚普洛夫函数(<strong>Lyapunov</strong>)形式如下：</p>
<p><span class="math display">\[
V = \frac{1}{2}s^2 \tag{25}
\]</span></p>
<p>为了使滑模变量在平衡点<span class="math inline">\(s = 0\)</span>处渐进稳定，根据李亚普洛夫稳定判据，必须满足下面两个条件：</p>
<ol type="1">
<li><span class="math inline">\(\begin{array}{rl}\dot{V} &lt; 0 &amp;(s \neq 0)\end{array}\)</span></li>
<li><span class="math inline">\(\lim_{\rvert s\rvert \to \infty}V = \infty\)</span></li>
</ol>
<p>由等式(25)的形式可知，条件2明显满足。将等式(24)所示的指数趋近率代入，并计算<span class="math inline">\(\dot{V}\)</span>得</p>
<p><span class="math display">\[
\begin{array}{rl}
\dot{V} = s\dot{s} &amp;= s(-\rho \cdot sign(s) - k\cdot s)\\
&amp;=-k \cdot s^2 - \rho \cdot sign(s) \cdot s\\
&amp;= -k \cdot \rvert s \rvert ^2 - \rho \cdot \rvert s \rvert
\end{array} \tag{26}
\]</span></p>
<p>其中<span class="math inline">\(k &gt; 0\)</span>，<span class="math inline">\(\rho &gt; 0\)</span>，很明显等式(26)中<span class="math inline">\(\dot{V} &lt; 0\)</span>，即满足条件1。因此采用等式(24)的指数趋近率可以使滑模变量渐进稳定。</p>
<h3 id="控制率">控制率</h3>
<p>驱使滑模变量<span class="math inline">\(s\)</span>变为0的控制率可以根据等式(23)和(24)得：</p>
<p><span class="math display">\[
\dfrac{\tan(\delta_r)}{l*\cos(\psi_r)^3} -\dfrac{\tan(\delta)}{l*\cos(\psi)^3} + c \cdot \bigl(\tan(\psi)-tan(\psi_r)\bigr) = -\rho \cdot sign(s) - k\cdot s \tag{27}
\]</span></p>
<p>根据等式(27)，提取<span class="math inline">\(\delta\)</span>项得</p>
<p><span class="math display">\[
\delta = \arctan
\Biggl(
    l*\cos(\psi)^3 \cdot
    \Bigl(
        \dfrac{\tan(\delta_r)}{l*\cos(\psi_r)^3} +
        c \cdot \bigl(\tan(\psi)-tan(\psi_r)\bigr) +
        \rho \cdot sign(s) +
        k\cdot s
    \Bigr)
\Biggr) \tag{28}
\]</span></p>
<p>等式(28)进一步化简为如下形式：</p>
<p><span class="math display">\[
\delta = \arctan
\Biggl(
l*\cos(\psi)^3 \cdot
    \Bigl(
        \dfrac{\tan(\delta_r)}{l*\cos(\psi_r)^3} +
        c \cdot x_2 +
        \rho \cdot sign(s) +
        k\cdot s
    \Bigr)
\Biggr) \tag{29}
\]</span></p>
<h3 id="切换函数">切换函数</h3>
<p>由于上述滑模控制器中使用的是符号函数<span class="math inline">\(sign(s)\)</span>，系统会出现不连续的开关特性，使得滑模变结构系统在滑动模态下存在高频的振动现象，从而导致路径跟踪过程中控制器出现较大波动，继而影响泊车的控制精度。</p>
<p>为了抑制振动，本文分别采用饱和函数<span class="math inline">\(sat(\dfrac{s}{\Delta})\)</span>和<span class="math inline">\(sigmoid\)</span>函数代替符号函数<span class="math inline">\(sign(s)\)</span>，保证系统的切换面附近光滑连续。</p>
<ul>
<li><strong>Sigmoid Function</strong>: <span class="math display">\[
Sigmoid(x) = \frac{x}{\rvert x \rvert + \varepsilon} \tag{30}
\]</span></li>
</ul>
<p>其中<span class="math inline">\(\varepsilon\)</span>是很小的正标量，下图为<span class="math inline">\(\varepsilon = 0.001\)</span>时，<span class="math inline">\(Sigmoid(x)\)</span>函数的波形图入下：</p>
<p><img data-src="https://i.loli.net/2021/08/30/NoXcDfzSPqBFMQJ.png" /></p>
<ul>
<li><strong>Sat Function</strong>:</li>
</ul>
<p><span class="math display">\[
Sat(\frac{x}{\Delta}) =
\left \{
\begin{array}{rl}
&amp;1  &amp; , &amp;x \geq \Delta\\
&amp;\dfrac{x}{\Delta}  &amp; , &amp;\rvert x \rvert &lt; \Delta\\
&amp;-1 &amp; , &amp;x \leq -\Delta
\end{array}
\right. \tag{31}
\]</span></p>
<p>其中，<span class="math inline">\(\Delta\)</span>为很小的正标量，代表边界层的厚度，当<span class="math inline">\(\Delta = 0.05\)</span>时，<span class="math inline">\(Sat(x)\)</span>波形图如下：</p>
<p><img data-src="https://i.loli.net/2021/08/30/Uag93Qfq14nL6uh.png" /></p>
<h2 id="性能分析">性能分析</h2>
<p>根据如下控制系统框图，搭建仿真环境。</p>
<p><img data-src="https://i.loli.net/2021/08/30/i8oHQE4J5k1UPeq.png" style="zoom:67%;" /></p>
<ul>
<li>滑模变量<span class="math inline">\(s\)</span> 下图所示，是滑模变量<span class="math inline">\(s\)</span>随距离<span class="math inline">\(x\)</span>变化的图形。随着距离的增大，滑模变量<span class="math inline">\(s\)</span>趋近于0，系统也趋近于稳定，但是滑模变量在0附近存在抖振。</li>
</ul>
<p><img data-src="https://i.loli.net/2021/08/30/F4KWyDJEi8BwRbC.png" /></p>
<ul>
<li>相图 如下图所示，是系统的相图，可以看出，系统逐渐收敛于原点。</li>
</ul>
<figure>
<img data-src="https://i.loli.net/2021/08/30/gOeB8KIDYdZkQoP.png" alt="相图" /><figcaption aria-hidden="true">相图</figcaption>
</figure>
<ul>
<li>路径跟踪图 如下图所示，是系统的路径跟踪波形图。刚开始时，跟踪存在偏差。经过一段时间的修正，跟踪路径趋近于一致。</li>
</ul>
<figure>
<img data-src="https://i.loli.net/2021/08/30/PmykNo5iZcAXsap.png" alt="路径跟踪图" /><figcaption aria-hidden="true">路径跟踪图</figcaption>
</figure>
<ul>
<li>转向角图 如下图所示，是系统控制产生的转向角信号。从图中可以发现，系统在趋于稳定时，控制信号存在抖振现象。</li>
</ul>
<figure>
<img data-src="https://i.loli.net/2021/08/30/6UVk2o1cSsT5iym.png" alt="转向角图" /><figcaption aria-hidden="true">转向角图</figcaption>
</figure>
<ul>
<li>轨迹误差图 如下图所示，是系统产生的轨迹误差图，随着时间推移，估计误差趋近于0。</li>
</ul>
<figure>
<img data-src="https://i.loli.net/2021/08/30/J4fnwU5QmtpLS78.png" alt="轨迹误差图" /><figcaption aria-hidden="true">轨迹误差图</figcaption>
</figure>
]]></content>
      <categories>
        <category>控制算法</category>
        <category>路径跟踪</category>
      </categories>
      <tags>
        <tag>路径跟踪</tag>
        <tag>滑模控制</tag>
        <tag>非时间参考系</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派系统安装</title>
    <url>/2022/12/26/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>本文讲述了树莓派系统的安装过程，并描述系统环境的配置，让其可以满足基本开发需求。</p>
<figure>
<img data-src="https://s3.bmp.ovh/imgs/2023/01/01/48c15813d627dec0.jpg" alt="高达模型" /><figcaption aria-hidden="true">高达模型</figcaption>
</figure>
<span id="more"></span>
<h2 id="硬件环境准备">硬件环境准备</h2>
<h3 id="卡片计算机">卡片计算机</h3>
<p>本文演示所用的计算机是 Raspberry Pi 3 Model B，其参数如下：</p>
<ul>
<li>Quad Core 1.2GHz Broadcom BCM2837 64bit CPU</li>
<li>1GB RAM</li>
<li>BCM43438 wireless LAN and Bluetooth Low Energy (BLE) on board</li>
<li>100 Base Ethernet</li>
<li>40-pin extended GPIO</li>
<li>4 USB 2 ports</li>
<li>4 Pole stereo output and composite video port</li>
<li>Full size HDMI</li>
<li>CSI camera port for connecting a Raspberry Pi camera</li>
<li>DSI display port for connecting a Raspberry Pi touchscreen display</li>
<li>Micro SD port for loading your operating system and storing data</li>
<li>Upgraded switched Micro USB power source up to 2.5A</li>
</ul>
<h3 id="电源适配器">电源适配器</h3>
<p>根据官方推荐参数，请选用输出电流可达2.5A的电源适配器，如果电源适配的输出功率不够，可能会导致系统不稳定的情况。例如在使用ssh连接卡片计算机时，如果计算机负载过高，会出现ssh连接断开的的情况。</p>
<h3 id="sd卡">SD卡</h3>
<p>推荐选用SD卡的容量至少32GB，该容量可以满足大部分场景需求。</p>
<h2 id="软件环境准备">软件环境准备</h2>
<h3 id="系统下载">系统下载</h3>
<p>首先从 <span class="exturl" data-url="aHR0cHM6Ly93d3cucmFzcGJlcnJ5cGkuY29tL3NvZnR3YXJlL29wZXJhdGluZy1zeXN0ZW1zLw==">树莓派官网<i class="fa fa-external-link-alt"></i></span> 下载最新的系统镜像，本文演示的系统镜像信息如下：</p>
<ul>
<li><p>Raspberry Pi OS Lite</p></li>
<li><p>Release date: September 22nd 2022</p></li>
<li><p>System: 64-bit</p></li>
<li><p>Kernel version: 5.15</p></li>
<li><p>Debian version: 11 (bullseye)</p></li>
<li><p>Size: 289MB：72c773781a0a57160eb3fa8bb2a927642fe60c3af62bc980827057bcecb7b98b</p></li>
</ul>
<h3 id="镜像烧录工具下载">镜像烧录工具下载</h3>
<p>从树莓派官网下载 <span class="exturl" data-url="aHR0cHM6Ly93d3cucmFzcGJlcnJ5cGkuY29tL3NvZnR3YXJlLw==">Raspberry Pi Imager<i class="fa fa-external-link-alt"></i></span> 工具，进行系统镜像的烧录。</p>
<p><img data-src="https://s3.bmp.ovh/imgs/2022/12/26/a6df9e3221c7bd5d.png" /></p>
<p>点击右下角的设置按钮，开启SSH功能并创建用户名和密码，如果希望通过wifi连接，可以配置wifi热点名和密码。</p>
<h2 id="系统准备">系统准备</h2>
<h3 id="更新镜像源">更新镜像源</h3>
<p>参考 <span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuL2hlbHAvcmFzcGJpYW4v">清华树莓派镜像站<i class="fa fa-external-link-alt"></i></span> 配置系统镜像源。</p>
<p>备份镜像源文件，通过如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /etc/apt/sources.list /tmp/sources.list.backup</span><br></pre></td></tr></table></figure>
<p>通过下面的指令替换原文件的内容并更新到系统镜像源。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sed -e &#x27;s/http:\/\/deb.debian.org/https:\/\/mirrors.tuna.tsinghua.edu.cn/;s/http:\/\/security.debian.org/https:\/\/mirrors.tuna.tsinghua.edu.cn/&#x27; /tmp/sources.list.backup &gt; /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p>同理，执行下述命令，替换为清华镜像源:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /etc/apt/sources.list.d/raspi.list /tmp/raspi.list.backup</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sed -e &#x27;s/http:\/\/archive.raspberrypi.org\/debian/https:\/\/mirrors.tuna.tsinghua.edu.cn\/raspberrypi/&#x27; /tmp/raspi.list.backup &gt; /etc/apt/sources.list.d/raspi.list</span><br></pre></td></tr></table></figure>
<p>执行下述命令，更新系统镜像源:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update --fix-missing</span><br><span class="line">sudo apt-get upgrade -y</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>安装教程</tag>
        <tag>Raspberry Pi</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>碰撞检测-apollo</title>
    <url>/2020/11/04/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B-apollo/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>本文主要分析<strong>aplollo</strong>代码中关于障碍物碰撞检测相关算法，该算法通过将车辆抽象成二维矩形盒(Box)，建立点与矩形盒、线段与矩形盒、矩形盒与矩形盒的碰撞检测算法。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/WiSODpuQYsy4KkC.jpg" alt="大连" /><figcaption aria-hidden="true">大连</figcaption>
</figure>
<span id="more"></span>
<h2 id="碰撞判断">碰撞判断</h2>
<h3 id="点与矩形盒">点与矩形盒</h3>
<p>关于点与矩形盒子的位置关系,可能情况为点在矩形盒内,点在矩形边框上和点在矩形盒外部,如果点在矩形盒的外部,可以求取点到矩形盒的距离值.</p>
<h4 id="判定点是否在矩形盒内">判定点是否在矩形盒内</h4>
<p>如下图所示,红色圆点与矩形盒的关系如下图左侧,为了便于判定红点是否在矩形盒内,将下图左侧整体按照航向角顺时针旋转<span class="math inline">\(\theta\)</span>角度,得到下图右侧状态.此时,只需要判定红点的坐标<span class="math inline">\((dx,dy)\)</span>是否满足<span class="math inline">\(\mid dx \mid &lt;= length_h\)</span> 或者 <span class="math inline">\(\mid dy \mid &lt;= width_h\)</span>，则说明红点位于矩形盒内.</p>
<p><img data-src="https://i.loli.net/2020/11/04/NwXoO1iQdxHSm4R.png" alt="point_in_box" style="zoom:80%;" /></p>
<p>其中,</p>
<ul>
<li><span class="math inline">\(length_{half}\)</span>: 车长的一半;</li>
<li><span class="math inline">\(width_{half}\)</span>: 车宽的一半;</li>
</ul>
<h4 id="判定点是否在矩形盒边界上">判定点是否在矩形盒边界上</h4>
<p>如下图所示,当红点位于矩形盒的边界上时,先以航向角顺时针旋转<span class="math inline">\(\theta\)</span>角度,然后通过判断旋转后的红点坐标<span class="math inline">\((dx,dy)\)</span>是否满足<span class="math inline">\(\mid \mid dx \mid - length_h \mid == 0\)</span> 或者 <span class="math inline">\(\mid \mid dy \mid - width_h \mid == 0\)</span>,则说明点红点位于矩形盒边界上.</p>
<p><img data-src="https://i.loli.net/2020/11/04/8PclGvub46QxOrR.png" alt="point_on_box_bound" style="zoom:80%;" /></p>
<p>其中,</p>
<ul>
<li><span class="math inline">\(length_{half}\)</span>: 车长的一半;</li>
<li><span class="math inline">\(width_{half}\)</span>: 车宽的一半;</li>
</ul>
<h4 id="计算点到矩形盒的距离">计算点到矩形盒的距离</h4>
<p>如下图所示,点到矩形盒的距离可以分为如下三种情况:</p>
<ol type="1">
<li><code>dx &lt;= 0</code>:如果红点在<span class="math inline">\(x\)</span>轴上的投影小于等于车长距离的一半,则此时的距离可以表示为<span class="math inline">\(\mid dy \mid\)</span>;</li>
<li><code>dy &lt;= 0</code>:如果条件1不满足,即<code>dx &gt; 0</code>,则判断红点在<span class="math inline">\(y\)</span>轴上的投影是否小于等于车宽的一半,如果满足条件,则距离可以表示为<span class="math inline">\(\mid dx \mid\)</span>;</li>
<li><code>dx &gt; 0 and dy &gt; 0</code>: 如果条件1和2都不满足,则距离可以表示为红点与矩形盒边角点的距离,即<span class="math inline">\(\sqrt{dx^2 + dy^2}\)</span>;</li>
</ol>
<p><img data-src="https://i.loli.net/2020/11/06/pqGR8F4jxWJ5fCV.png" alt="point_to_box_distance" style="zoom:80%;" /></p>
<h3 id="线段与矩形盒">线段与矩形盒</h3>
<h4 id="判定线段与矩形盒是否交叠">判定线段与矩形盒是否交叠</h4>
<p>关于某线段与矩形盒关系的判定,先计算线段的长度,如果线段的长度为0,则可以把该线段当作一个点,利用点和矩形盒的距离来判断是否交叠;如果线段的长度不为0,则先进行线段与矩形盒的粗判定,即线段的起始点与终点是否落在矩形盒的一边,如下图所示,表示线段位于矩形盒一边的四种情况.如果线段不满足如下关系,则交叠关系可以通过距离来判断.</p>
<p><img data-src="https://i.loli.net/2020/11/04/9NrinbFamEds1p6.png" alt="line_to_box_outside" style="zoom:50%;" /></p>
<h4 id="计算线段到矩形盒的距离">计算线段到矩形盒的距离</h4>
<h5 id="区域划分">区域划分</h5>
<p>如下图所示,将矩形盒的外围分成如下8个区域,关于区域的划分,可以根据线段起始点和终点分别在<span class="math inline">\(x\)</span>轴和<span class="math inline">\(y\)</span>轴的投影,表示为<span class="math inline">\((p_x,p_y)\)</span>;以车辆中心<span class="math inline">\(o\)</span>为原点,则四个边角点可以表示为<span class="math inline">\((box_x,box_y)\)</span>,<span class="math inline">\((box_x,-box_y)\)</span>,<span class="math inline">\((-box_x,box_y)\)</span>,<span class="math inline">\((-box_x,-box_y)\)</span>.</p>
<p>其中,根据点在<span class="math inline">\(x\)</span>轴的投影,可以将区域值表示如下:</p>
<p><span class="math display">\[
g_x=\begin{cases}
1  &amp; \text{if } (p_x &gt;= box_x),\\
0  &amp; \text{if } (-box_x &lt; p_x &lt; box_x),\\
-1 &amp; \text{if } (p_x &lt;= -box_x),\\
\end{cases}
\]</span></p>
<p><img data-src="https://i.loli.net/2020/11/04/uriBfCcGEX3H4Sl.png" alt="line_to_box_group" style="zoom:80%;" /></p>
<p>根据上图,区域的值表示如下:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">区域</th>
<th style="text-align: center;">gx</th>
<th>gy</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td>1</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">0</td>
<td>1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">-1</td>
<td>1</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">-1</td>
<td>0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">5</td>
<td style="text-align: center;">-1</td>
<td>-1</td>
</tr>
<tr class="even">
<td style="text-align: center;">6</td>
<td style="text-align: center;">0</td>
<td>-1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">7</td>
<td style="text-align: center;">1</td>
<td>-1</td>
</tr>
<tr class="even">
<td style="text-align: center;">8</td>
<td style="text-align: center;">1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>其中,区域<span class="math inline">\((0,0)\)</span>位于矩形盒内,即线段中有一点位于矩形盒内,必定与矩形盒交叠.因此去除点位于区域<span class="math inline">\((0,0)\)</span>的情形,考虑线段两个端点与矩形盒的关系共有<span class="math inline">\(8 \times 8 = 64\)</span>种情况.</p>
<h5 id="对称变换">对称变换</h5>
<p>首先将起始点通过<span class="math inline">\(x\)</span>轴和<span class="math inline">\(y\)</span>轴对称变换,将落在区域3,4,5,6,7的点变换到区域1,2,8中.对于区域2和8,进行<span class="math inline">\(xy\)</span>轴对称变换,将区域2变换为区域8.所以经过三种轴对称转换后,起始点将会落在区域1和区域8两种区域状态.</p>
<ul>
<li>区域1</li>
</ul>
<p>当<strong>起始点</strong>位于区域1,则将终点进行<span class="math inline">\(xy\)</span>轴对称变换,将位于区域2,3,4的终点,对称变换到区域8,7,6中.因此关于终点的所在区域的情况只需考虑落在区域1,8,7,6,5,这五个区域的情况;</p>
<ul>
<li>区域8</li>
</ul>
<p>当<strong>起始点</strong>位于区域8,对终点进行<span class="math inline">\(y\)</span>轴对称变换,将位于<span class="math inline">\(y\)</span>轴下方的区域变换到<span class="math inline">\(y\)</span>轴上方,即区域5,6,7对称变换到区域3,2,1.因此终点只需考虑区域8,1,2,3,4五个区域的请况.</p>
<p>通过上述对称变换,可以将原先的64种线段与矩形的关系减少到10种,从而减少相关计算量.</p>
<h5 id="线段与矩形盒距离计算">线段与矩形盒距离计算</h5>
<p>如下图所示,线段起始点与矩形盒边角点之间的向量表示为<span class="math inline">\(\vec{sb}\)</span>,起始点与终点之间的向量表示为<span class="math inline">\(\vec{sg}\)</span>.</p>
<ul>
<li>当<span class="math inline">\(\vec{sb}\cdot\vec{sg} &lt;= 0\)</span>时,即下图浅绿色表示的区域,此时,线段与矩形盒的距离表示为<span class="math inline">\(\mid \vec{sb}\mid\)</span>.</li>
</ul>
<p><img data-src="https://i.loli.net/2020/11/05/DknoJSP8vbcrLaU.png" alt="vector_cdot_less_zero" style="zoom:80%;" /></p>
<ul>
<li>当<span class="math inline">\(\vec{sb}\cdot\vec{sg} &gt;= \vec{sg} \cdot \vec{sg}\)</span>,即下图浅绿色区域,线段与矩形盒的距离可以表示为<span class="math inline">\(\mid \vec{sb}-\vec{sg}\mid\)</span>.</li>
</ul>
<p><img data-src="https://i.loli.net/2020/11/07/fMP1eUWuH2dngjS.png" alt="vector_cdot_length_two" style="zoom:80%;" /></p>
<ul>
<li>当上述条件都不满足时,即位于下图浅黄色区域,线段与矩形盒的距离可以表示为<span class="math inline">\(\mid \vec{sb} \mid \sin{\theta}\)</span>,可使用向量叉乘得到<span class="math inline">\(\frac{\vec{sb}\times\vec{sg}}{\mid \vec{sg} \mid}\)</span>.</li>
</ul>
<p><img data-src="https://i.loli.net/2020/11/05/j1CodMGyezNSWwB.png" alt="vector_times" style="zoom:80%;" /></p>
<h5 id="起始点区域1">起始点区域1</h5>
<ol type="1">
<li>当终点位于区域1时,直接使用上述方法计算距离值;</li>
<li>当终点位于区域8时,先判定起始点与终点的<span class="math inline">\(x\)</span>轴坐标的关系,当起始点坐标的<span class="math inline">\(x\)</span>轴坐标大于终点的<span class="math inline">\(x\)</span>轴坐标,则距离值为<span class="math inline">\(\mid g_x - b_x \mid\)</span>,否则按照上述方法计算距离值;</li>
<li>当终点位于区域7时,先判定起始点与终点的<span class="math inline">\(x\)</span>轴坐标的关系,选取不同的矩形盒的边角点;</li>
<li>当终点位于区域6时,先判定线段与矩形盒是否交叠,如下图所示,通过计算向量叉乘<span class="math inline">\(\vec{sg}\times\vec{sb}\)</span>,判断线段是否与矩形盒交叠.</li>
</ol>
<figure>
<img data-src="https://i.loli.net/2020/11/05/XS4Q7WVujPgZhmc.png" alt="vector_times_less_zero" /><figcaption aria-hidden="true">vector_times_less_zero</figcaption>
</figure>
<ol start="5" type="1">
<li>当终点位于区域5时,矩形盒的边角点分两种,首先判断与右下角的边角点的关系,如果不交叠则直接按上述方法计算距离值,否则判断与左上角边角点的关系,如果无交叠则按上述方法计算距离值.</li>
</ol>
<figure>
<img data-src="https://i.loli.net/2020/11/05/QZCTfSRhJEa2zLA.png" alt="vector_times_two_bound_zero" /><figcaption aria-hidden="true">vector_times_two_bound_zero</figcaption>
</figure>
<h5 id="起始点区域8">起始点区域8</h5>
<ol type="1">
<li>当终点位于区域1时,如下图所示,先判定起始点与终点的<span class="math inline">\(x\)</span>轴坐标的关系,如果起始点小于终点,则距离值为<span class="math inline">\(\mid s_x - b_x \mid\)</span>,否则计算线段与矩形盒的距离;</li>
</ol>
<figure>
<img data-src="https://i.loli.net/2020/11/05/aAnrLxq2S1f9GTQ.png" alt="zoom8_1" /><figcaption aria-hidden="true">zoom8_1</figcaption>
</figure>
<ol start="2" type="1">
<li><p>当终点位于区域8时,选取起始点与终点中离矩形盒最近的点到矩形盒的距离,即<span class="math inline">\(\mid min(s_x,g_x) -b_x \mid\)</span>;</p></li>
<li><p>当终点位于区域2和3时,如下图所示,通过右上边角点与线段的起始点,终点形成的矢量,进行矢量叉乘,通过数值的正负判断线段是否与矩形盒交叠;</p></li>
</ol>
<p><img data-src="https://i.loli.net/2020/11/05/dsHiLS9M5FO4xZm.png" alt="zoom8_23" style="zoom:80%;" /></p>
<ol start="4" type="1">
<li>当终点位于区域4时,线段与矩形盒一定交叠;</li>
</ol>
<h3 id="矩形盒与矩形盒">矩形盒与矩形盒</h3>
<p>关于矩形盒与矩形盒的碰撞检测采用分离轴原理,即通过判断任意两个<strong>凸多边形</strong>在任意角度下的投影是否均存在重叠，来判断是否发生碰撞。若在某一角度光源下，两物体的投影存在间隙，则为不碰撞，否则为发生碰撞。 如下图所示,将左右两个矩形盒投影到左侧矩形盒长边所在轴上,从图中可以看出投影重叠;</p>
<p><img data-src="https://i.loli.net/2020/11/06/cvArUsyTKzZHPqJ.png" alt="projection_1" style="zoom:50%;" /></p>
<p>如下图所示,以左侧矩形盒短边为轴,将矩形盒投影到该轴上,可以发现投影无重叠,只要存在一种投影方式无重叠,则说明无碰撞。</p>
<p><img data-src="https://i.loli.net/2020/11/06/3xbcGn8ViREtNmp.png" alt="projection_2" style="zoom: 50%;" /></p>
]]></content>
      <categories>
        <category>碰撞检测算法</category>
      </categories>
      <tags>
        <tag>collision checker</tag>
        <tag>obstacle collision</tag>
        <tag>碰撞检测</tag>
        <tag>apllo碰撞检测分析</tag>
      </tags>
  </entry>
  <entry>
    <title>算法优化-1bit转8bit-NEON处理</title>
    <url>/2021/03/17/%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96_NEON%E5%90%8E%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>使用IVE可以加速sobel滤波器和canny滤波器，但是IVE生成的滤波器结果格式不满足实际需求。为此，需要通过软件方式将IVE的输出结果转化成需要的形式，可以使用c语言、NEON Intrinscis和NEON汇编等方式去实现。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/luRx6nbg58KvOp2.jpg" alt="大连" /><figcaption aria-hidden="true">大连</figcaption>
</figure>
<span id="more"></span>
<h2 id="sobel滤波">Sobel滤波</h2>
<p>Sobel滤波器的结果形式如下，使用16比特存储<code>x</code>和<code>y</code>方向的梯度值，其中低8位表示<code>x</code>轴方向梯度，高8位表示<code>y</code>轴方向梯度。</p>
<figure>
<img data-src="https://i.loli.net/2021/03/22/aREjy9znB63wgOH.png" alt="IVE-sobel_result_form" /><figcaption aria-hidden="true">IVE-sobel_result_form</figcaption>
</figure>
<p>实际需求要将<code>x</code>和<code>y</code>方向的梯度拆分为两个字节，具体形式如下：</p>
<p><img data-src="https://i.loli.net/2021/03/22/bvPYqLWknwjQdu9.png" alt="sobel_result_form_xy" style="zoom:150%;" /></p>
<h3 id="nfsu16tou8withtwo函数实现">NfsU16ToU8WithTwo函数实现</h3>
<p>该函数实现将<code>16bit</code>的高低位拆分为两个独立的字节，并将拆分后的字节单独输出。</p>
<h4 id="c语言代码">C语言代码</h4>
<p>使用C语言编写代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int32_t</span> i = <span class="number">0</span>; i &lt; IMG_BUF_SIZE; i++)</span><br><span class="line">&#123;</span><br><span class="line">    sobel_x[i] =  data_sobel[i]       &amp; <span class="number">0xff</span>;</span><br><span class="line">    sobel_y[i] = (data_sobel[i] &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Running Time</strong> : 14.3ms</p>
</blockquote>
<h3 id="nfsu16tou8square-函数实现">NfsU16ToU8Square 函数实现</h3>
<p>该函数实现将<code>16bit</code>的高低位拆分为两个独立的字节(x,y)，并计算<span class="math inline">\(x^2 + y^2\)</span>，将<code>x</code>和<code>y</code>轴的梯度求平方和后按照<code>16bit</code>输出结果。</p>
<h4 id="c语言代码-1">C语言代码</h4>
<p>使用C语言编写代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span> temp_x, temp_y; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int32_t</span> i = <span class="number">0</span>; i &lt; IMG_BUF_SIZE; i++)</span><br><span class="line">&#123;</span><br><span class="line">     temp_x =  data_sobel[i]       &amp; <span class="number">0xff</span>;</span><br><span class="line">     temp_y = (data_sobel[i] &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">     output_sobel[i] = temp_x * temp_x + temp_y * temp_y;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Running Time</strong> : 18.2ms</p>
</blockquote>
<h4 id="intrinsics优化">Intrinsics优化</h4>
<p>首先想到的优化方式是采用<strong>NEON Intrinsics</strong>方式对上述<strong>C</strong>语言代码进行重构，该方式相比于编写汇编代码更加简单，且便于移植。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int32_t</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint16x8_t</span> v_in;</span><br><span class="line"><span class="type">uint8x8_t</span> x, y;</span><br><span class="line"><span class="type">uint16x8_t</span> x2;</span><br><span class="line"><span class="type">uint16x8_t</span> xy_square;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i + <span class="number">7</span> &lt; size; i += <span class="number">8</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// load the input data</span></span><br><span class="line">    v_in = vld1q_u8(input + i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// seprate the u16 to two u8</span></span><br><span class="line">    x = vmovn_u16(v_in); <span class="comment">// mov low 8bit to the x </span></span><br><span class="line">    y = vshrn_n_u16(v_in, <span class="number">8</span>); <span class="comment">// the element right shift 8bit </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate the x^2 + y^2</span></span><br><span class="line">    x2 = vmull_u8(x, x);</span><br><span class="line">    xy_square = vmlal_u8(x2, y, y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// store the result</span></span><br><span class="line">    vst1q_u16(output + i, xy_square);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Running Time</strong> : 3.42ms</p>
</blockquote>
<h4 id="数据加载优化">数据加载优化</h4>
<p>随着对NEON指令集理解的深入，可以直接使用<code>VLD2</code>指令直接在加载数据时就实现<code>x</code>和<code>y</code>通道的拆分，从而进一步提升了处理的速度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int32_t</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8x8x2_t</span> v_in;</span><br><span class="line"><span class="type">uint16x8_t</span> x2;</span><br><span class="line"><span class="type">uint16x8_t</span> xy_square;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i + <span class="number">7</span> &lt; size; i += <span class="number">8</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// load the input data</span></span><br><span class="line">    v_in = vld2_u8((<span class="type">uint8_t</span>*)input + i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate the x^2 + y^2</span></span><br><span class="line">    x2 = vmull_u8(v_in.val[<span class="number">0</span>], v_in.val[<span class="number">0</span>]);</span><br><span class="line">    xy_square = vmlal_u8(x2, v_in.val[<span class="number">1</span>], v_in.val[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// store the result</span></span><br><span class="line">    vst1q_u16(output + i, xy_square);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过该方式，处理器时可以减少一次<code>mov</code>操作和一次<code>shift</code>操作。如下图所示，<code>VLD2.8</code>直接加载<code>sobel_x</code>进<code>D8</code>，同时加载<code>sobel_y</code>进<code>D9</code>。</p>
<p><img data-src="https://i.loli.net/2021/03/22/CSVYXb1ADeKv3M2.png" alt="IVE-u16totwobyte_load2" style="zoom: 50%;" /></p>
<blockquote>
<p><strong>Running Time</strong>: 2.64ms</p>
</blockquote>
<h4 id="使能向量优化">使能向量优化</h4>
<p>在使用<code>NEON Intinsics</code>时，编译选项中需要使能向量化，具体编译参数如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -mcpu=cortex-a9 -mfloat-abi=hard -ftree-vectorize -O2 </span><br></pre></td></tr></table></figure>
<h2 id="canny滤波">Canny滤波</h2>
<p>Canny滤波器的结果使用一个字节表示8个像素信息，具体形式如下：</p>
<figure>
<img data-src="https://i.loli.net/2021/03/22/jchBaQpVIzUw6FE.png" alt="IVE-one_bit_to_byte" /><figcaption aria-hidden="true">IVE-one_bit_to_byte</figcaption>
</figure>
<p>因此，需要通过软件的方式将字节中的每一个bit像素拆分为一个字节表示，将上图中的两个字节数据进行转换，结果如下图所示：</p>
<figure>
<img data-src="https://i.loli.net/2021/03/22/NwAekVfE3v18PF7.png" alt="one_bit_to_byte_split" /><figcaption aria-hidden="true">one_bit_to_byte_split</figcaption>
</figure>
<h3 id="nfsonebittou8函数实现">NfsOneBitToU8函数实现</h3>
<h4 id="c语言代码-2">C语言代码</h4>
<p>使用C语言编写代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; IMG_BUF_SIZE; i++)</span><br><span class="line">&#123;</span><br><span class="line">    data_canny_8bit[i]  = ((data_canny[i/<span class="number">8</span>] &gt;&gt; (i % <span class="number">8</span>)) &amp; <span class="number">0x01</span>) &lt;&lt; <span class="number">7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="汇编语言代码">汇编语言代码</h4>
<h5 id="算法思路">算法思路</h5>
<p>上述功能可以使用NEON汇编进行加速，具体思路如下：</p>
<ol type="1">
<li><strong>加载</strong>操作 使用<code>VLD1</code>指令从内存空间加载图像数据到<code>Q6</code>寄存器，该指令可以一次加载16个字节数据，对应图像的128个像素值；</li>
</ol>
<figure>
<img data-src="https://i.loli.net/2021/03/22/AcrYxXTozQDMNq4.png" alt="one_bit_to_byte_neon1" /><figcaption aria-hidden="true">one_bit_to_byte_neon1</figcaption>
</figure>
<ol start="2" type="1">
<li><strong>位与</strong>操作 使用<code>VAND</code>指令，对<code>Q6</code>与<code>Q4</code>寄存器的元素进行<code>位与</code>操作，并将结果存入<code>Q7</code>寄存器，其中<code>Q4</code>寄存器可使用<code>DUP</code>指令全部置为<code>0x01</code>；此步骤将每个元素的低位像素值取出放入<code>Q7</code>寄存器中；</li>
</ol>
<figure>
<img data-src="https://i.loli.net/2021/03/22/auqrLtTUV3CO1WP.png" alt="one_bit_to_byte_neon2" /><figcaption aria-hidden="true">one_bit_to_byte_neon2</figcaption>
</figure>
<ol start="3" type="1">
<li><strong>比较</strong>操作 使用<code>VCGT</code>指令对<code>Q7</code>和<code>Q5</code>寄存器的元素逐个进行比较，判断<code>Q7</code>寄存器的元素是否大于对应<code>Q5</code>中的元素，其计算结果保存在<code>Q8</code>寄存器中。如果<code>Q7</code>的元素大于<code>Q5</code>的元素，则对应<code>Q8</code>元素设置为<strong>255</strong>,否则设置为<strong>0</strong>。</li>
</ol>
<figure>
<img data-src="https://i.loli.net/2021/03/22/fvabiuxP3wOpdZk.png" alt="one_bit_to_byte_neon3" /><figcaption aria-hidden="true">one_bit_to_byte_neon3</figcaption>
</figure>
<ol start="4" type="1">
<li><strong>移位</strong>操作 使用<code>VSHR</code>指令，将<code>Q6</code>中的元素整体向右移动1比特位，即将下一组像素移到元素最低位，方便循环取出图像像素值。</li>
</ol>
<figure>
<img data-src="https://i.loli.net/2021/03/22/A9rf8uEphmtJ1nR.png" alt="one_bit_to_byte_neon4" /><figcaption aria-hidden="true">one_bit_to_byte_neon4</figcaption>
</figure>
<ol start="5" type="1">
<li><strong>循环</strong>操作 循环上述2、3、4步骤，将<code>Q6</code>寄存器中的像素值分别取出，放入<code>Q8~Q15</code>寄存器中。</li>
</ol>
<figure>
<img data-src="https://i.loli.net/2021/03/22/y4FhAPkxJOp3b5B.png" alt="one_bit_to_byte_neon5" /><figcaption aria-hidden="true">one_bit_to_byte_neon5</figcaption>
</figure>
<ol start="6" type="1">
<li><strong>打包</strong>操作 使用<code>VZIP</code>指令每隔4个<code>Q</code>寄存器进行一次打包操作，如下图所示，使像素索引号间隔4排列。该步骤的目的是未了方便下一步的存储操作。</li>
</ol>
<figure>
<img data-src="https://i.loli.net/2021/03/22/i4ovKyuaHsO5T1P.png" alt="one_bit_to_byte_neon6" /><figcaption aria-hidden="true">one_bit_to_byte_neon6</figcaption>
</figure>
<ol start="7" type="1">
<li><strong>存储</strong>操作 使用<code>VST4</code>指令将上述打包好的数据，按照像素循序存储相应的内存地址。</li>
</ol>
<p><img data-src="https://i.loli.net/2021/03/22/gtaHZXzmK685opf.png" alt="one_bit_to_byte_neon7" style="zoom:80%;" /></p>
<h5 id="汇编代码">3.1.2.2 汇编代码</h5>
<p>使用<strong>NEON Assembly</strong>编写上述功能代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NfsOneBitToU8Asm</span><span class="params">(<span class="type">uint8_t</span>* <span class="keyword">restrict</span> input, <span class="type">uint8_t</span>* <span class="keyword">restrict</span> output, <span class="type">uint32_t</span> size)</span> &#123;</span><br><span class="line">  <span class="type">uint8_t</span>* input_temp = input;</span><br><span class="line">  <span class="type">uint8_t</span>* output_temp = output;</span><br><span class="line">  <span class="type">uint32_t</span> size_tmp = size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;vmov.i8      q4, #0x01         \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vmov.i8      q5, #0x00         \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;100:                           \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vld1.8      &#123;q6&#125;, [%0]!        \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;pld         [%0, #128]         \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vshr.u8     q9, q6, #1         \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vshr.u8     q10, q6, #2        \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vshr.u8     q11, q6, #3        \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vshr.u8     q12, q6, #4        \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vshr.u8     q13, q6, #5        \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vshr.u8     q14, q6, #6        \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vshr.u8     q15, q6, #7        \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vand.i8     q8, q6, q4         \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vand.i8     q9, q9, q4         \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vand.i8     q10, q10, q4       \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vand.i8     q11, q11, q4       \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vand.i8     q12, q12, q4       \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vand.i8     q13, q13, q4       \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vand.i8     q14, q14, q4       \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vand.i8     q15, q15, q4       \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vcgt.s8     q8, q8, q5         \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vcgt.s8     q9, q9, q5         \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vcgt.s8     q10, q10, q5       \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vcgt.s8     q11, q11, q5       \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vcgt.s8     q12, q12, q5       \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vcgt.s8     q13, q13, q5       \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vcgt.s8     q14, q14, q5       \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vcgt.s8     q15, q15, q5       \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vzip.8      q8, q12            \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vzip.8      q9, q13            \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vzip.8      q10, q14           \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vzip.8      q11, q15           \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vst4.8      &#123;d16, d18, d20, d22&#125;, [%1]! \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vst4.8      &#123;d17, d19, d21, d23&#125;, [%1]! \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vst4.8      &#123;d24, d26, d28, d30&#125;, [%1]! \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vst4.8      &#123;d25, d27, d29, d31&#125;, [%1]! \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;subs        %2, #16             \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;bgt         100b                \n&quot;</span></span></span><br><span class="line"><span class="params">               : <span class="string">&quot;=r&quot;</span>(input_temp), <span class="string">&quot;=r&quot;</span>(output_temp), <span class="string">&quot;=r&quot;</span>(size_tmp)</span></span><br><span class="line"><span class="params">               : <span class="string">&quot;0&quot;</span>(input_temp), <span class="string">&quot;1&quot;</span>(output_temp), <span class="string">&quot;2&quot;</span>(size_tmp)</span></span><br><span class="line"><span class="params">               : <span class="string">&quot;memory&quot;</span>,</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;cc&quot;</span>,</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;q4&quot;</span>,</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;q5&quot;</span>,</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;q6&quot;</span>,</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;q7&quot;</span>,</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;q8&quot;</span>,</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;q9&quot;</span>,</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;q10&quot;</span>,</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;q11&quot;</span>,</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;q12&quot;</span>,</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;q13&quot;</span>,</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;q14&quot;</span>,</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;q15&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性能对比">性能对比</h2>
<p>如下表所示，上述代码在联咏<strong>NT96565A</strong>平台运行时间如下：</p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>C language</th>
<th>Intrinsics</th>
<th>Assembly</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>NfsU16ToU8WithTwo</strong></td>
<td>14.3</td>
<td><strong>3.2</strong></td>
<td>3.56</td>
</tr>
<tr class="even">
<td><strong>NfsU16ToU8Square</strong></td>
<td>18.6</td>
<td><strong>2.64</strong></td>
<td>2.82</td>
</tr>
<tr class="odd">
<td><strong>NfsOneBitToU8</strong></td>
<td>10.2</td>
<td>2.13</td>
<td><strong>1.78</strong></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>算法优化</category>
        <category>NEON</category>
      </categories>
      <tags>
        <tag>图像算法加速</tag>
        <tag>NEON</tag>
        <tag>联咏</tag>
      </tags>
  </entry>
  <entry>
    <title>路径规划-ReedsShepp曲线</title>
    <url>/2020/04/15/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92-ReedsShepp%E6%9B%B2%E7%BA%BF/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p><strong>ReedsShepp</strong>算法简称<strong>RS</strong>，由 <strong>J.AReeds</strong>和<strong>L.A.Sheep</strong>于1990年发表的论文<span class="exturl" data-url="aHR0cHM6Ly9wcm9qZWN0ZXVjbGlkLm9yZy9kb3dubG9hZC9wZGZfMS9ldWNsaWQucGptLzExMDI2NDU0NTA=">(optimal path for a car that goes both forward and backwards)<i class="fa fa-external-link-alt"></i></span>。该方法基于<strong>Dubins</strong>算法进行改进，将反向运动加入到规划中，这就使得在某些情况下可以得出比<strong>Dubins</strong>曲线更优的解。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/ESWCixm4uDdRv61.jpg" alt="青岛" /><figcaption aria-hidden="true">青岛</figcaption>
</figure>
<span id="more"></span>
<h2 id="曲线">曲线</h2>
<h3 id="dubins曲线">Dubins曲线</h3>
<p>关于<strong>Dubins</strong>曲线，不考虑车辆后退，且不允许出现尖瓣。<strong>Dubins</strong>给出了充分的路径集合，该集合里所包含的曲线叫做<strong>测地线</strong>或<strong>最佳路径</strong>。但是这个充分集合很小，对于每种特定终点情况下的集合中，最多只有6个可选曲线,分别表示如下：</p>
<p><span class="math display">\[
\begin{array}{cl}
\{&amp;LRL  &amp;LSL  &amp;LSR  &amp;RLR  &amp;RSR  &amp;RSL &amp;\} \tag{1}
\end{array}
\]</span></p>
<p>其中等式(1)中符号含义如下：</p>
<table>
<thead>
<tr class="header">
<th>符号</th>
<th>含义</th>
<th>绕单位圆</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>L</strong></td>
<td>左转</td>
<td>逆时针</td>
</tr>
<tr class="even">
<td><strong>R</strong></td>
<td>右转</td>
<td>顺时针</td>
</tr>
<tr class="odd">
<td><strong>S</strong></td>
<td>直走</td>
<td>直走</td>
</tr>
</tbody>
</table>
<p><strong>Dubins</strong>证明，一个最优路径一定是由分段圆弧(单位圆)和线段组成的平滑曲线，且最多3部分组成。可以进一步简化表示为如下形式：</p>
<p><span class="math display">\[
\begin{array}{cl}
CCC&amp;\to&amp;\{&amp;LRL &amp;RLR &amp;&amp;&amp;\} \\
CSC&amp;\to&amp;\{&amp;LSL &amp;RSR &amp;LSR &amp;RSL&amp;\}
\end{array} \tag{2}
\]</span></p>
<p>等式(2)中符号含义如下：</p>
<table>
<thead>
<tr class="header">
<th><strong>符号</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>C</strong></td>
<td>单位圆弧</td>
</tr>
<tr class="even">
<td><strong>S</strong></td>
<td>一条直线段</td>
</tr>
</tbody>
</table>
<p>一个字段表示相应的一类路径，使用文字符号的下标指定相应弧长和线段的长度，比如<span class="math inline">\((L_tS_uR_v)\)</span>。</p>
<h3 id="reedsheep曲线">ReedSHeep曲线</h3>
<p>在<strong>ReedSHeep</strong>曲线的路径中，允许尖瓣存在。为了表示，需要在字段中的字母上加入上标，用来表示运动方向，表示如下：</p>
<table>
<thead>
<tr class="header">
<th>符号</th>
<th>含义</th>
<th>绕单位圆</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math display">\[L^+\]</span></td>
<td>向<strong>前</strong>左转</td>
<td>逆时针</td>
</tr>
<tr class="even">
<td><span class="math display">\[L^-\]</span></td>
<td>向<strong>后</strong>左转</td>
<td>顺时针</td>
</tr>
<tr class="odd">
<td><span class="math display">\[R^+\]</span></td>
<td>向<strong>前</strong>右转</td>
<td>逆时针</td>
</tr>
<tr class="even">
<td><span class="math display">\[R^-\]</span></td>
<td>向<strong>后</strong>右转</td>
<td>顺时针</td>
</tr>
<tr class="odd">
<td><span class="math display">\[S^+\]</span></td>
<td>向<strong>前</strong>直走</td>
<td>/</td>
</tr>
<tr class="even">
<td><span class="math display">\[S^-\]</span></td>
<td>向<strong>后</strong>直走</td>
<td>/</td>
</tr>
</tbody>
</table>
<p>例如：<span class="math inline">\(L^+R^-\)</span>拥有一个尖瓣而<span class="math inline">\(L^+R^+\)</span>无尖瓣。</p>
<blockquote>
<p>在车辆中，字母L、R、S参考方向盘转角，符号<span class="math inline">\(+\)</span>和<span class="math inline">\(-\)</span>参考挡位切换</p>
</blockquote>
<p>使用C、S字符可以给出如下集合：</p>
<p><span class="math display">\[
\begin{array}{cl}
CCC \gets \{&amp;C^+C^-C^+ &amp;C^+C^-C^-  &amp;C^+C^+C^- &amp;C^+C^+_uC^-_uC^- &amp;C^+C^-_uC^-_uC^+&amp;\}\\
CSC \gets \{&amp;C^+S^+C^+ &amp;C^-C^+_{\pi/2}S^+C^+ &amp;C^+S^+C^+_{\pi/2}C^- &amp;C^-C^+_{\pi/2}S^+C^+_{\pi/2}C^-&amp;&amp;\}
\end{array}\tag{3}
\]</span></p>
<p>以及通过反转等式(3)的符号可以获得新的的字段。上式(3)中，<span class="math inline">\(C\)</span>表示<span class="math inline">\(L\)</span>或者<span class="math inline">\(R\)</span>，<span class="math inline">\(C^+_{\pi/2}\)</span>表示相应的<span class="math inline">\(L\)</span>或<span class="math inline">\(R\)</span>的弧长为<span class="math inline">\(\pi/2\)</span>，<span class="math inline">\(C_uC_u\)</span>组合表示相应的弧段拥有相等的长度。</p>
<h4 id="下标符号">下标符号</h4>
<p>为了更加缜密表示，在<span class="math inline">\(C^\pm_t,L^\pm_t,R^\pm_t,S^\pm_t\)</span>中使用有点多余的约定，规定<span class="math inline">\(t\)</span>的符号与方向匹配。</p>
<blockquote>
<p>如果<span class="math inline">\(t &gt; 0\)</span>：车辆前进，符号<span class="math inline">\(+\)</span> 如果<span class="math inline">\(t&lt;0\)</span>：车辆后退，符号<span class="math inline">\(-\)</span></p>
</blockquote>
<h4 id="自由参数数量">自由参数数量</h4>
<p>在等式(3)的曲线族中，<span class="math inline">\(C^+_tC^-_uC^-_vC^+_w\)</span>具有自由参数<span class="math inline">\((t,u,v,w)\)</span>的数量比最终情形的数量多一个。优化路径族通过给定额外的方程式，例如<span class="math inline">\(u=v\)</span>或者<span class="math inline">\(v = \pi/2\)</span>。确保等式(3)中的每个情形只有3个自由参数。</p>
<h4 id="紧凑表示">紧凑表示</h4>
<p>为了以紧凑的表示，避免<span class="math inline">\(\pm\)</span>，可以写出充分路径的列表如下：</p>
<p><span class="math display">\[
\begin{array}{cl}
CCC \gets \{&amp;C\mid C\mid C &amp;C\mid CC  &amp;CC\mid C &amp;CC_u\mid C_uC &amp;C\mid C_uC_u\mid C&amp;\}\\
CSC \gets \{&amp;CSC &amp;C\mid C_{\pi/2}SC &amp;CSC_{\pi/2}\mid C &amp;C\mid C_{\pi/2}SC_{\pi/2}\mid C&amp;&amp;\}\\
\end{array}\tag{4}
\]</span></p>
<p>其中，<span class="math inline">\(|\)</span>表示方向反转。当等式(3)和(4)中的<span class="math inline">\(C\)</span>被替换为<span class="math inline">\(C = L\)</span>或<span class="math inline">\(C=R\)</span>，共有48种字段，以<span class="math inline">\(L^\pm,R^\pm,S^\pm\)</span>的形式表示。这48个字段中的一些对于字段类型的实际路径存在两种公式。对于给定的任意情形，至多68个公式。</p>
<p>任何长度小于<span class="math inline">\(\pi/8\)</span>的最佳路径一定是<span class="math inline">\(CSC\)</span>形式。很容易得出结论，任何最佳路径一定是由<span class="math inline">\(C\)</span>和<span class="math inline">\(S\)</span>的字段组成。使用一系列的特殊参数，可将所有有限的字段简化为<span class="math inline">\(CCC\)</span>或<span class="math inline">\(CSC\)</span>的形式。</p>
<h4 id="充分集合">充分集合</h4>
<p>下表列出了充分集合中的48个字段，以及相应的缩写形式<span class="math inline">\(C \mid C\)</span>和<span class="math inline">\(C^\pm\)</span>，最后一列给出了给定字段的长度公式。</p>
<table>
<colgroup>
<col style="width: 40%" />
<col style="width: 43%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="header">
<th>形式<span class="math inline">\(C\mid C\)</span></th>
<th>形式<span class="math inline">\(C^\pm\)</span></th>
<th>明确表示</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math display">\[ \begin{array}{cl} C\mid C \mid C \end{array} \]</span></td>
<td><span class="math display">\[ \begin{array}{cl} &amp;C^+C^-C^+ \\&amp;C^-C^+C^- \end{array} \]</span></td>
<td><span class="math display">\[ \begin{array}{cl}&amp;L^+R^-L^+ &amp;R^+L^-R^+ \\ &amp;L^-R^+L^- &amp;R^-L^+R^- \end{array} \]</span></td>
</tr>
<tr class="even">
<td><span class="math display">\[ \begin{array}{cl}C \mid CC \end{array}\]</span></td>
<td><span class="math display">\[ \begin{array}{cl}&amp;C^+C^-C^- \\&amp;C^-C^+C^+ \end{array} \]</span></td>
<td><span class="math display">\[ \begin{array}{cl}&amp;L^+R^-L^- &amp;R^+L^-R^-\\&amp;L^-R^+L^+  &amp;R^-L^+R^+ \end{array} \]</span></td>
</tr>
<tr class="odd">
<td><span class="math display">\[ CC \mid C \]</span></td>
<td><span class="math display">\[ \begin{array}{cl}&amp;C^+C^+C^- \\&amp;C^-C^-C^+ \end{array} \]</span></td>
<td><span class="math display">\[ \begin{array}{cl}&amp;L^+R^+L^- &amp;R^+L^+R^-\\&amp;L^-R^-L^+  &amp;R^-L^-R^+ \end{array} \]</span></td>
</tr>
<tr class="even">
<td><span class="math display">\[ CC_u \mid C_uC \]</span></td>
<td><span class="math display">\[ \begin{array}{cl}&amp;C^+C^+_uC^-_{-u}C^- \\&amp;C^-C^-_{-u}C^+_uC^+ \end{array} \]</span></td>
<td><span class="math display">\[ \begin{array}{cl}&amp;L^+R^+_uL^-_{-u}R^- &amp;R^+L^+_uR^-_{-u}L^-\\&amp;L^-R^-_{-u}L^+_uR^+  &amp;R^-L^-_{-u}R^+_uL^+ \end{array} \]</span></td>
</tr>
<tr class="odd">
<td><span class="math display">\[ C \mid C_uC_u \mid C \]</span></td>
<td><span class="math display">\[ \begin{array}{cl}&amp;C^+C^-_{-u}C^-_{-u}C^+ \\&amp;C^-C^+_{u}C^+_uC^- \end{array} \]</span></td>
<td><span class="math display">\[ \begin{array}{cl}&amp;L^+R^-_{-u}L^-_{-u}R^+ &amp;R^+L^-_{-u}R^-_{-u}L^+\\&amp;L^-R^+_{u}L^+_uR^-  &amp;R^-L^+_{u}R^+_uL^-\end{array} \]</span></td>
</tr>
<tr class="even">
<td><span class="math display">\[ CSC \]</span></td>
<td><span class="math display">\[ \begin{array}{cl}&amp;C^+C^+C^+ \\&amp;C^-C^-C^-\end{array} \]</span></td>
<td><span class="math display">\[ \begin{array}{cl}&amp;L^+S^+L^+ &amp;R^+S^+R^+\\&amp;L^+S^+R^+  &amp;R^+S^+L^+\\&amp;L^-S^-L^- &amp;R^-S^-R^-\\&amp;L^-S^-R^-  &amp;R^-S^-L^-\end{array} \]</span></td>
</tr>
<tr class="odd">
<td><span class="math display">\[ C \mid C_{\pi/2}SC \]</span></td>
<td><span class="math display">\[ \begin{array}{cl}&amp;C^+C^-_{-\pi/2}S^-C^- \\&amp;C^-C^+_{\pi/2}S^+C^+\end{array} \]</span></td>
<td><span class="math display">\[ \begin{array}{cl}&amp;L^+R^-_{-\pi/2}S^-L^- &amp;R^+L^-_{-\pi/2}S^-R^-\\&amp;L^+R^-_{-\pi/2}S^-R^- &amp;R^+L^-_{-\pi/2}S^-L^-\\&amp;L^-R^+_{\pi/2}S^+L^+ &amp;R^-L^+_{\pi/2}S^+R^+\\&amp;L^-R^+_{\pi/2}S^+R^+ &amp;R^-L^+_{\pi/2}S^+L\\\end{array} \]</span></td>
</tr>
<tr class="even">
<td><span class="math display">\[ CSC_{\pi/2} \mid C \]</span></td>
<td><span class="math display">\[ \begin{array}{cl}&amp;C^+S^+C^+_{\pi/2}C^- \\&amp;C^-S^-C^-_{\pi/2}C^+\end{array}\]</span></td>
<td><span class="math display">\[\begin{array}{cl}&amp;L^+S^+R^+_{\pi/2}L^- &amp;R^+S^+L^+_{\pi/2}R^-\\&amp;R^+S^+R^+_{\pi/2}L^- &amp;L^+S^+L^+_{\pi/2}R^-\\&amp;L^-S^-R^-_{-\pi/2}L^+ &amp;R^-S^-L^-_{-\pi/2}R^+\\&amp;R^-S^-R^-_{-\pi/2}L^+ &amp;L^-S^-L^-_{-\pi/2}R^+ \end{array} \]</span></td>
</tr>
<tr class="odd">
<td><span class="math display">\[ C\mid C_{\pi/2}SC_{\pi/2}C \]</span></td>
<td><span class="math display">\[ \begin{array}{cl}&amp;C^+C^-_{-\pi/2}S^-C^-_{-\pi/2}C^+ \\&amp;C^-C^+_{\pi/2}S^+C^+_{\pi/2}C^-\end{array}\]</span></td>
<td><span class="math display">\[\begin{array}{cl}&amp;L^+R^-_{-\pi/2}S^-L^-_{-\pi/2}R^+ &amp;R^+L^-_{-\pi/2}S^-R^-_{-\pi/2}L^+\\&amp;L^-R^+_{\pi/2}S^+L^+_{\pi/2}R^-  &amp;R^-L^+_{\pi/2}S^+R^+_{\pi/2}L^-\end{array} \]</span></td>
</tr>
</tbody>
</table>
<h2 id="允许路径">允许路径</h2>
<p>根据车辆运动学模型的微分方程如下：</p>
<p><span class="math display">\[
\begin{array}{cl}
\dot{x}(t) &amp;= V(t)\cos\bigl(\psi(t)\bigr) \quad\\
\dot{y}(t) &amp;= V(t)\sin\bigl(\psi(t)\bigr) \quad\\
\dot{\psi}(t) &amp;= \dfrac{V(t)}{R(t)}
\end{array}\tag{5}
\]</span></p>
<p>为了更好的表示路径，对车辆行驶路径进行归一化处理，简化路径的表示方法。即限制<span class="math inline">\(V(t)= \pm1\)</span>、<span class="math inline">\(|\dot{\psi}(t)| =1\)</span>，所以车辆只能在自身方向<span class="math inline">\(\psi(t)\)</span>上以速度<span class="math inline">\(|V(t)=1|\)</span>前进或后退，并且变化率<span class="math inline">\(\dot{\psi}(t)\leq1\)</span><strong>rad/s</strong>。对于车辆的转弯半径可以通过缩放变换到1，即车辆绕单位圆行驶。这样表示的好处在于车辆行驶的弧长与变化的角度一致。如果直线行驶，则<span class="math inline">\(\dot{\psi}(t) = 0\)</span>，令<span class="math inline">\(\dot{\psi}\)</span></p>
<p>其积分形式如下：</p>
<p><span class="math display">\[
\begin{array}{cl}
x(t) &amp;= x(0) + \int^t_0V(\tau)\cos\bigl(\psi(\tau)\bigr)d\tau\\
y(t) &amp;= y(0) + \int^t_0V(\tau)\sin\bigl(\psi(\tau)\bigr)d\tau\\
\psi(t) &amp;= \psi(0) + \int^t_0\dot{\psi}(\tau)d\tau
\end{array}\tag{6}
\]</span></p>
<p>一个允许的路径或者曲线可以表示成函数<span class="math inline">\(\gamma(t) = \bigl(x(t),y(t),\psi(t)\bigr)\)</span>的形式。对于任意曲线从<span class="math inline">\(t_0\)</span>到<span class="math inline">\(t_1\)</span>，其中<span class="math inline">\(t_0 &lt; t_1\)</span>，<span class="math inline">\(\gamma(t_0) = a\)</span>，<span class="math inline">\(\gamma(t_1)=b\)</span>，则路径的长度为<span class="math inline">\(L(\gamma)= t_1 - t_0\)</span>。所以关于最短路径的问题，就转换为求取对于任意a和b<span class="math inline">\(\in \Re^3\)</span>,使得<span class="math inline">\(L(\gamma)\)</span>最小的<span class="math inline">\(\gamma\)</span>。</p>
<h3 id="可行路径">可行路径</h3>
<p>对于时间<span class="math inline">\(t \in \Re\)</span>，使用</p>
<p><span class="math display">\[
\begin{array}{cl}
L_t:\Re^3 \to \Re^3\\
R_t: \Re^3 \to \Re^3\\
S_t: \Re^3 \to \Re^3
\end{array}\tag{7}
\]</span></p>
<p>表示单位圆<span class="math inline">\(L_t\)</span>或<span class="math inline">\(R_t\)</span>和线段<span class="math inline">\(S_t\)</span>的位置和方向信息，起始坐标表示为<span class="math inline">\((x,y,\psi)\)</span>，所以经过时间<span class="math inline">\(t\)</span>，根据等式(6)积分得：</p>
<p><span class="math display">\[
\begin{array}{cl}
x(t) &amp;= x + \sin(\tau)|^{\psi+t}_{\psi}\\
y(t) &amp;= y - \cos(\tau)|^{\psi+t}_{\psi}\\
\psi(t) &amp;= t
\end{array}
\]</span></p>
<p>对应的路径如下：</p>
<p><span class="math display">\[
\begin{array}{cl}
L_t^+(x,y,\psi) &amp;= \bigl(x + \sin(\psi+t)- \sin(\psi),y - \cos(\psi+t)+\cos(\psi),\psi + t\bigr)\\
R_t^+(x,y,\psi) &amp;= \bigl(x - \sin(\psi-t)+ \sin(\psi),y + \cos(\psi-t)-\cos(\psi),\psi - t\bigr)\\
S_t^+(x,y,\psi) &amp;= (x+t\cos(\psi),y + t\sin(\psi),\psi)
\end{array}\tag{8}
\]</span></p>
<p><span class="math display">\[
\begin{array}{cl}
L_t^-(x,y,\psi) &amp;= \bigl(x - \sin(\psi-t)+ \sin(\psi),y + \cos(\psi-t)-\cos(\psi),\psi - t\bigr)\\
R_t^-(x,y,\psi) &amp;= \bigl(x + \sin(\psi+t)- \sin(\psi),y - \cos(\psi+t)+\cos(\psi),\psi + t\bigr)\\
S_t^-(x,y,\psi) &amp;= (x-t\cos(\psi),y - t\sin(\psi),\psi)
\end{array}
\]</span></p>
<ul>
<li>举例</li>
</ul>
<p>假设一个曲线<span class="math inline">\(L^+_tR^-_uS^-_vL^-_w\)</span>，起始于点<span class="math inline">\((0,0,0)\)</span>，一定终止于</p>
<p><span class="math display">\[
\bigl(X(t,u,v,w),Y(t,u,v,w),\Psi(t,u,v,w)\bigr)= R_w(S_v(R_u(L_t(0,0,0))))
\]</span></p>
<p>其长度为<span class="math inline">\(L(t,u,v,w) = |t|+ |u| + |v| + |w|\)</span>。</p>
<h3 id="位置姿态统一">位置姿态统一</h3>
<p>由于车辆的起始位置和终点位置无法穷举，所以一般在计算路径之前，需要将车辆的位置和姿态作归一化：</p>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>坐标</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>起始姿态</td>
<td><span class="math inline">\(( 0, 0, 0 )\)</span></td>
</tr>
<tr class="even">
<td>目标姿态</td>
<td><span class="math inline">\((x, y, \psi )\)</span></td>
</tr>
<tr class="odd">
<td>转弯半径</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>假设起始姿态为<span class="math inline">\(q_i=(x_1,y_1,\psi_1)\)</span>，目标姿态为<span class="math inline">\(q_g=(x_2,y_2,\psi_2)\)</span>，车辆转弯半径为<span class="math inline">\(r=\rho\)</span>。</p>
<ul>
<li>平移</li>
</ul>
<p>首先将向量<span class="math inline">\(\vec{q_iq_g}\)</span>平移到远点<span class="math inline">\((0,0)\)</span>，平移向量为<span class="math inline">\((-x_1,-y_1)\)</span>。则<span class="math inline">\(q_i\)</span>平移到<span class="math inline">\((0,0)\)</span>，<span class="math inline">\(q_g\)</span>平移到<span class="math inline">\((x_2-x_1,y_2-y_1)\)</span>，最终得到的平移向量：</p>
<p><span class="math display">\[
\vec{q_iq_g}=
\left[
\begin{array}{cl}
x_2-x_1\\
y_2-y_1
\end{array}\right]=
\left[
\begin{array}{cl}
x\\
y
\end{array}
\right]\tag{9}
\]</span></p>
<ul>
<li>旋转</li>
</ul>
<p>应用旋转矩阵，将车辆的起始点朝向转到x轴正向，对应得旋转角度为<span class="math inline">\(\psi_1\)</span>，旋转矩阵如下：</p>
<p><span class="math display">\[
\left[
\begin{array}{cl}
\cos(\psi_1) &amp;\sin(\psi_1)\\
-\sin(\psi_1) &amp;\cos(\psi_1)
\end{array}
\right]\tag{10}
\]</span></p>
<p>则向量<span class="math inline">\(\vec{q_iq_g}\)</span>旋转后得</p>
<p><span class="math display">\[
\vec{q_iq_g}=
\left[
\begin{array}{cl}
x\\
y
\end{array}
\right]=
\left[
\begin{array}{cl}
\cos(\psi_1) &amp;\sin(\psi_1)\\
-\sin(\psi_1) &amp;\cos(\psi_1)
\end{array}
\right]
\left[
\begin{array}{cl}
x\\
y
\end{array}
\right]=
\left[
\begin{array}{cl}
x\cos(\psi_1) + y\sin(\psi_1)\\
-x\sin(\psi_1)+y\cos(\psi_1)
\end{array}
\right]
\tag{11}
\]</span></p>
<p>通过上述旋转后，目标位置朝向为<span class="math inline">\(\psi = \psi_2 - \psi_1\)</span>。</p>
<ul>
<li>缩放</li>
</ul>
<p>对于车辆的转弯半径<span class="math inline">\(\rho\)</span>，将车辆转向半径缩放到1，得到最终的车辆其实姿态为:</p>
<p><span class="math display">\[
q_i=
\left[
\begin{array}{cl}
0\\
0\\
0
\end{array}
\right]\tag{12}
\]</span></p>
<p>目标姿态为：</p>
<p><span class="math display">\[
q_g=
\left[
\begin{array}{cl}
\bigl(x\cos(\psi_1) + y\sin(\psi_1)\bigr)/\rho\\
\bigl(-x\sin(\psi_1)+y\cos(\psi_1)\bigr)/\rho\\
\psi_2-\psi_1
\end{array}
\right]\tag{13}
\]</span></p>
<h2 id="类型转换">类型转换</h2>
<p>上述48个字段中的某些方程的最小值拥有两个解，所以实际公式将达到68个。凭经验观察，似乎只要48个表达式在任何情况下都需要，一些表达式无疑是方程的虚假解。在可以考虑的48种不同的字符模式中，由于存在一些基本变换，没有必要给出所有的形式。下面列出3种常见的转换模式：</p>
<h3 id="时间变换timeflip">时间变换(timeflip)</h3>
<p>时间变换通过交换字母上标符号<span class="math inline">\(+\)</span>和<span class="math inline">\(-\)</span>，即车取反辆的行进方向。也就是说，<span class="math inline">\(L^-R^+S^+L^+\)</span>表达式可以通过<span class="math inline">\(L^+R^-S^-L^-\)</span>表达式通过时间变换获得。其中<span class="math inline">\(+\)</span>和<span class="math inline">\(-\)</span>交换。如果原始路径从<span class="math inline">\((0,0,0)\)</span>到<span class="math inline">\((x,y,\psi)\)</span>，显而易见时间变换的路径将从<span class="math inline">\((0,0,0)\)</span>到<span class="math inline">\((-x,y,-\psi)\)</span>。因此，如果一个路径表达式<span class="math inline">\(L^+_tR^-_{-\pi/2}S^-_uL^-_v\)</span>从点<span class="math inline">\((0,0,0)\)</span>到<span class="math inline">\((-x,y,-\psi)\)</span>，查找的合适弧长为t、u、v。这就等效于路径表达式<span class="math inline">\(L^-_tR^+_{\pi/2}S^+_uL^+_v\)</span>从点<span class="math inline">\((0,0,0)\)</span>到<span class="math inline">\((x,y,\psi)\)</span>查找相应的弧长。所以，通过时间变换将上述列表中第一个字母符号为"<span class="math inline">\(-\)</span>"的字段消除。</p>
<h3 id="反射变换reflect">反射变换(reflect)</h3>
<p>反射变换通过交换字母<span class="math inline">\(L\)</span>和<span class="math inline">\(R\)</span>，即取反车辆转向。也就是说，一个路径表达式<span class="math inline">\(R^+L^-S^-R^-\)</span>的解可以通过反射变换从路径表达式<span class="math inline">\(L^+R^-S^-L^-\)</span>的解中获得，即沿着该路径交换<span class="math inline">\(L\)</span>和<span class="math inline">\(R\)</span>。相应的参考路径由<span class="math inline">\((x,y,\psi)\)</span>变为<span class="math inline">\((x,-y,-\psi)\)</span>。</p>
<p>假设已知路径<span class="math inline">\(L^+_tR^-_{-\pi/2}S^-_uL^-_v\)</span>解的表达式，从点<span class="math inline">\((0,0,0) \to (x,-y,-\psi)\)</span>的最优弧长为t、u、v。</p>
<p><span class="math display">\[
\begin{array}{cl}
&amp;L^+_tR^-_{-\pi/2}S^-_uL^-_v :(0,0,0) \to (x,-y,-\psi)\\
\end{array}
\]</span></p>
<p>则从点<span class="math inline">\((0,0,0) \to (x,y,\psi)\)</span>的最优弧长为t、u、v，对应路径<span class="math inline">\(R^+_tL^-_{-\pi/2}S^-_uR^-_v\)</span>的解，</p>
<p><span class="math display">\[
\begin{array}{cl}
&amp;R^+_tL^-_{-\pi/2}S^-_uR^-_v :(0,0,0) \to (x,y,\psi)\\
\end{array}
\]</span></p>
<p>所以，通过反射变换可以将上述列表中以<span class="math inline">\(L^+\)</span>开头的字段消除。</p>
<h3 id="逆向变换backwards">逆向变换(backwards)</h3>
<p>逆向变换通过将原路径按照相反方向行走。也就是说，路径<span class="math inline">\(L^-S^-R^-L^+\)</span>的公式可以使用逆向变换从路径<span class="math inline">\(L^+R^-S^-L^-\)</span>的公式中获得，即按照相反的顺序运动。</p>
<p>逆向变换将目标点<span class="math inline">\((x,y,\psi)\)</span>转化为<span class="math inline">\(\bigl(x\cos(\psi)+y\sin(\psi),x\sin(\psi)-y\cos(\psi),\psi\bigr)\)</span>。所以可以通过公式<span class="math inline">\(L^+R^-S^-L^-\)</span>到达点<span class="math inline">\(\bigl(x\cos(\psi)+y\sin(\psi),x\sin(\psi)-y\cos(\psi),\psi\bigr)\)</span>，从而获得<span class="math inline">\(L^-S^-R^-L^+\)</span>到达点<span class="math inline">\((x,y,\psi)\)</span>的解。</p>
<p>通过这个变换可以消除上述列表中一些字段，最终保留9个字段讨论如下。</p>
<h2 id="公式计算">公式计算</h2>
<p>通过上述3种变换，还剩9个公式需要求解。这9个表达式都是从点<span class="math inline">\((0,0,0)\)</span>到点<span class="math inline">\((x,y,\psi)\)</span>，为了更加方便表述，定义如下符号：</p>
<ul>
<li>极坐标</li>
</ul>
<p>由笛卡尔坐标系<span class="math inline">\((x,y)\)</span>与极坐标系的转化可以写为<span class="math inline">\((r,\theta) = R(x,y)\)</span>，展开如下：</p>
<p><span class="math display">\[
\begin{array}{cl}
x = r \cdot\cos(\theta)\\
y = r \cdot\sin(\theta)
\end{array}\leftrightharpoons
\begin{array}{cl}
r &amp;= \sqrt{x^2 + y^2}\\
\theta &amp;= \arctan(\dfrac{y}{x})
\end{array}
\]</span></p>
<p>其中，<span class="math inline">\(r \geq 0\)</span>，<span class="math inline">\(-\pi \leq \theta &lt; \pi\)</span>。</p>
<ul>
<li>偏航角标准化</li>
</ul>
<p>通过标准化符号<span class="math inline">\(M\)</span>，即<span class="math inline">\(\psi = M(\theta)\)</span>，将<span class="math inline">\(\psi\)</span>的范围限制在<span class="math inline">\(-\pi \leq \psi&lt; \pi\)</span>。</p>
<h3 id="公式-l_ts_ul_v">公式 <span class="math inline">\(L^+_tS^+_uL^+_v\)</span></h3>
<ul>
<li>推导</li>
</ul>
<p>第一个公式详细推导计算过程，后面的公式由于原理相同，就不详细推导，直接给出结论。</p>
<p>推导过程，主要结合等式(8)种的结论:</p>
<p><span class="math display">\[
\begin{array}{cl}
L_t^+(x,y,\psi) &amp;= \bigl(x + \sin(\psi+t)- \sin(\psi),y - \cos(\psi+t)+\cos(\psi),\psi + t\bigr)\\
R_t^+(x,y,\psi) &amp;= \bigl(x - \sin(\psi-t)+ \sin(\psi),y + \cos(\psi-t)-\cos(\psi),\psi - t\bigr)\\
S_t^+(x,y,\psi) &amp;= (x+t\cos(\psi),y + t\sin(\psi),\psi)
\end{array}
\]</span></p>
<p>起始坐标<span class="math inline">\((0,0,0)\)</span>，目标坐标<span class="math inline">\((x,y,\psi)\)</span></p>
<table>
<thead>
<tr class="header">
<th>操作</th>
<th><span class="math inline">\(x\)</span></th>
<th><span class="math inline">\(y\)</span></th>
<th><span class="math inline">\(\psi\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>起始坐标</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>移动弧长<strong>t</strong></td>
<td><span class="math inline">\(\sin{t}\)</span></td>
<td><span class="math inline">\(1 - \cos{t}\)</span></td>
<td><span class="math inline">\(t\)</span></td>
</tr>
<tr class="odd">
<td>移动弧长<strong>u</strong></td>
<td><span class="math inline">\(\sin{t} + u\cos{t}\)</span></td>
<td><span class="math inline">\(1 - \cos{t} + u\sin{t}\)</span></td>
<td><span class="math inline">\(t\)</span></td>
</tr>
<tr class="even">
<td>移动弧长<strong>v</strong></td>
<td><span class="math inline">\(u\cos{t} + \sin{(t+v)}\)</span></td>
<td><span class="math inline">\(1 + u\sin{t} - \cos{(t + v)}\)</span></td>
<td><span class="math inline">\(t + v\)</span></td>
</tr>
<tr class="odd">
<td>终点坐标</td>
<td><span class="math inline">\(x\)</span></td>
<td><span class="math inline">\(y\)</span></td>
<td><span class="math inline">\(\psi\)</span></td>
</tr>
</tbody>
</table>
<p>从上述表格可知</p>
<p><span class="math display">\[
\begin{array}{cl}
x &amp;=   u\cos{t} + \sin{(t+v)} \\
y &amp;=   1 + u\sin{t} - \cos{(t + v)} \\
\psi &amp;=   t + v
\end{array}
\]</span></p>
<p>将$= t + v $带入得</p>
<p><span class="math display">\[
\begin{array}{cl}
x &amp;=   u\cos{t} + \sin{\psi} \\
y &amp;=   1 + u\sin{t} - \cos{\psi}
\end{array}
\]</span></p>
<p>移项得</p>
<p><span class="math display">\[
\begin{array}{cl}
u\cos{t} &amp;=  x  - \sin{\psi} \\
u\sin{t} &amp;=  y  + \cos{\psi}- 1
\end{array}
\]</span></p>
<p>使用极坐标表示得</p>
<p><span class="math display">\[
(u,t) = R(x  - \sin{\psi},y  + \cos{\psi}- 1)
\]</span></p>
<p>则</p>
<p><span class="math display">\[
v = M(\psi - t)
\]</span></p>
<ul>
<li>结论</li>
</ul>
<p>已知起始坐标<span class="math inline">\((0,0,0)\)</span>和目标坐标<span class="math inline">\((x,y,\psi)\)</span>，则<span class="math inline">\(L^+_tS^+_uL^+_v\)</span>的最优解为</p>
<p><span class="math display">\[
\begin{array}{cl}
(u,t) &amp;= R(x  - \sin{\psi},y  + \cos{\psi}- 1)\\
v &amp;= M(\psi - t)
\end{array}
\]</span></p>
<p>总长度为<span class="math inline">\(L = |t| + |u| + |v|\)</span>。</p>
<h3 id="公式-l_ts_ur_v">公式 <span class="math inline">\(L^+_tS^+_uR^+_v\)</span></h3>
<p>下表描述了计算过程：</p>
<table style="width:100%;">
<colgroup>
<col style="width: 12%" />
<col style="width: 35%" />
<col style="width: 41%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr class="header">
<th>操作</th>
<th><span class="math inline">\(x\)</span></th>
<th><span class="math inline">\(y\)</span></th>
<th><span class="math inline">\(\psi\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>起始坐标</td>
<td><span class="math inline">\(0\)</span></td>
<td><span class="math inline">\(0\)</span></td>
<td><span class="math inline">\(0\)</span></td>
</tr>
<tr class="even">
<td>移动弧长<strong>t</strong></td>
<td><span class="math inline">\(\sin{t}\)</span></td>
<td><span class="math inline">\(1 - \cos{t}\)</span></td>
<td><span class="math inline">\(t\)</span></td>
</tr>
<tr class="odd">
<td>移动弧长<strong>u</strong></td>
<td><span class="math inline">\(\sin{t} + u\cos{t}\)</span></td>
<td><span class="math inline">\(1 - \cos{t} + u\sin{t}\)</span></td>
<td><span class="math inline">\(t\)</span></td>
</tr>
<tr class="even">
<td>移动弧长<strong>v</strong></td>
<td><span class="math inline">\(u\cos{t} - \sin{(t-v)}+2\sin{t}\)</span></td>
<td><span class="math inline">\(1 + u\sin{t} + \cos{(t - v)}-2\cos{t}\)</span></td>
<td><span class="math inline">\(t - v\)</span></td>
</tr>
<tr class="odd">
<td>终点坐标</td>
<td><span class="math inline">\(x\)</span></td>
<td><span class="math inline">\(y\)</span></td>
<td><span class="math inline">\(\psi\)</span></td>
</tr>
</tbody>
</table>
<p>整理得</p>
<p><span class="math display">\[
\begin{array}{cl}
x &amp;= u\cos{t} - \sin{(t-v)}+2\sin{t}   \\
y &amp;= u\sin{t} + \cos{(t - v)}-2\cos{t} +1 \\
\psi &amp;=    t - v
\end{array}
\]</span></p>
<p>将<span class="math inline">\(\psi = t -v\)</span>带入得</p>
<p><span class="math display">\[
\begin{array}{cl}
x &amp;= u\cos{t} - \sin{\psi}+2\sin{t}   \\
y &amp;= u\sin{t} + \cos{\psi}-2\cos{t} +1
\end{array}
\]</span></p>
<p>移项得</p>
<p><span class="math display">\[
\begin{array}{cl}
u\cos{t} &amp;= x + \sin{\psi} - 2\sin{t}   \\
u\sin{t} &amp;= y - \cos{\psi} + 2\cos{t} -1
\end{array}
\]</span></p>
<p>令$ P_1(u_1,t_1) = R(x + ,y - ) <span class="math inline">\(，\)</span>P_2(2,t-)=R(2,-2)<span class="math inline">\(，\)</span>P(u,t)=R(u,u)$。</p>
<p>由等式得</p>
<p><span class="math display">\[
P(u,t) = P_1(u_1,t_1) - P_2(2,t-\frac{\pi}{2})
\]</span></p>
<p>由上式可知，极向量<span class="math inline">\(P\)</span>与<span class="math inline">\(P_2\)</span>必须垂直，由于向量<span class="math inline">\(P_2\)</span>的长度为2，为了满足上述关系，向量<span class="math inline">\(P_1\)</span>的长度不能小于2，否则无解。</p>
<ul>
<li>如果<span class="math inline">\(u_1^2 &lt; 4\)</span></li>
</ul>
<p>无解，<span class="math inline">\(L = \infty\)</span>。</p>
<ul>
<li>如果<span class="math inline">\(u_1^2 \geq 4\)</span></li>
</ul>
<p>已知起始坐标<span class="math inline">\((0,0,0)\)</span>和目标坐标<span class="math inline">\((x,y,\psi)\)</span>，可以求出<span class="math inline">\(P_1(u_1,t_1) = R(x + \sin\psi,y + \cos\psi -1)\)</span>，且<span class="math inline">\(P_2(2,t-\frac{\pi}{2})\)</span>已知。根据上述极向量<span class="math inline">\(P\)</span>、<span class="math inline">\(P_1\)</span>、<span class="math inline">\(P_2\)</span>之间的直角三角形关系，可得<span class="math inline">\(u^2 + 2^2 = u_1^2 \to u = \sqrt{u_1^2 - 4}\)</span>。极向量<span class="math inline">\(P\)</span>与<span class="math inline">\(P_1\)</span>之间的夹角<span class="math inline">\(\beta = \arctan{\dfrac{2}{u}}\)</span>，故<span class="math inline">\(t = M(t_1 + \beta)\)</span>，<span class="math inline">\(v = M(t - \psi)\)</span>。弧长<span class="math inline">\(L = |t| + |u| + |v|\)</span>。</p>
<p><img data-src="https://i.loli.net/2021/08/30/yCQc9YA6UNxbdqH.png" style="zoom:80%;" /></p>
<h3 id="公式-l_tr-_ul_v">公式 <span class="math inline">\(L^+_tR^-_uL^+_v\)</span></h3>
<p>下表是路径的计算过程。</p>
<table>
<thead>
<tr class="header">
<th>操作</th>
<th><span class="math inline">\(x\)</span></th>
<th><span class="math inline">\(y\)</span></th>
<th><span class="math inline">\(\psi\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>起始坐标</td>
<td><span class="math inline">\(0\)</span></td>
<td><span class="math inline">\(0\)</span></td>
<td><span class="math inline">\(0\)</span></td>
</tr>
<tr class="even">
<td>移动弧长<strong>t</strong></td>
<td><span class="math inline">\(\sin{t}\)</span></td>
<td><span class="math inline">\(1 - \cos{t}\)</span></td>
<td><span class="math inline">\(t\)</span></td>
</tr>
<tr class="odd">
<td>移动弧长<strong>u</strong></td>
<td><span class="math inline">\(\sin(t + u)\)</span></td>
<td><span class="math inline">\(1 - \cos{(t + u)}\)</span></td>
<td><span class="math inline">\(t + u\)</span></td>
</tr>
<tr class="even">
<td>移动弧长<strong>v</strong></td>
<td><span class="math inline">\(\sin{(t+u + v)}\)</span></td>
<td><span class="math inline">\(1 - \cos{(t + u + v)}\)</span></td>
<td><span class="math inline">\(t +u+ v\)</span></td>
</tr>
<tr class="odd">
<td>终点坐标</td>
<td><span class="math inline">\(x\)</span></td>
<td><span class="math inline">\(y\)</span></td>
<td><span class="math inline">\(\psi\)</span></td>
</tr>
</tbody>
</table>
<h2 id="参考">参考</h2>
<ol type="1">
<li><span class="exturl" data-url="aHR0cHM6Ly9vbXBsLmthdnJha2lsYWIub3JnL1JlZWRzU2hlcHBTdGF0ZVNwYWNlXzhjcHBfc291cmNlLmh0bWw=">参考源码<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5iYW5iZWljaGFkZXhpYW9qaXViZWkuY29tL2luZGV4LnBocC8yMDIwLzAzLzIzLyVlOCU4NyVhYSVlNSU4YSVhOCVlOSVhOSViZSVlOSVhOSViNiVlOCViZiU5MCVlNSU4YSVhOCVlOCVhNyU4NCVlNSU4OCU5Mi1yZWVkcy1zaGVwcCVlNiU5YiViMiVlNyViYSViZi8=">自动驾驶运动规划-Reeds Shepp曲线<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9wcm9qZWN0ZXVjbGlkLm9yZy9kb3dubG9hZC9wZGZfMS9ldWNsaWQucGptLzExMDI2NDU0NTA=">算法论文<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>路径规划</category>
        <category>几何路径</category>
      </categories>
      <tags>
        <tag>路径规划</tag>
        <tag>ReedsSheep</tag>
        <tag>RS曲线</tag>
        <tag>Dubins曲线</tag>
      </tags>
  </entry>
  <entry>
    <title>车辆术语缩写</title>
    <url>/2020/01/07/%E8%BD%A6%E8%BE%86%E6%9C%AF%E8%AF%AD%E7%BC%A9%E5%86%99/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>本文总结了汽车领域常用汽车术语的缩写，后续会继续补偿完善。</p>
<h2 id="泊车辅助系统">泊车辅助系统</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">缩写</th>
<th>英文名称</th>
<th>中文名称</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>APA</strong></td>
<td>Auto Parking Assistant</td>
<td>自动泊车辅助系统</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>RPA</strong></td>
<td>Remote Parking Assist</td>
<td>遥控泊车辅助</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>HPA</strong></td>
<td>Home zone Parking Assist</td>
<td>家庭区域泊车辅助</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>PIC</strong></td>
<td>Parking In Control</td>
<td>泊入控制</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>POC</strong></td>
<td>Pull Out Control</td>
<td>泊出控制</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>L-ASP</strong></td>
<td>Low Speed Autonomous Searching Parking slot</td>
<td>低速自动寻找车位</td>
</tr>
</tbody>
</table>
<span id="more"></span>
<h2 id="纵向辅助系统">纵向辅助系统</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">缩写</th>
<th>英文名称</th>
<th>中文名称</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>L-AEB</strong></td>
<td>Low speed Automatic Emergency Brake</td>
<td>低速自动紧急制动</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>L-ACC</strong></td>
<td>Low speed Adaptive Cruise Control</td>
<td>低速自适应巡航</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>ACC</strong></td>
<td>Adaptive Cruise Control</td>
<td>自适应巡航控制</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>LSC</strong></td>
<td>Longitudinal speed control</td>
<td>纵向速度控制</td>
</tr>
</tbody>
</table>
<h2 id="感知系统">感知系统</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">缩写</th>
<th>英文名称</th>
<th style="text-align: left;">中文名称</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>RRS</strong></td>
<td>Reversing Radar System</td>
<td style="text-align: left;">倒车雷达系统</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>SDW</strong></td>
<td>Side Distance Warning</td>
<td style="text-align: left;">侧边距离报警</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>SVA</strong></td>
<td>Side View Assist</td>
<td style="text-align: left;">侧视辅助</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>CTA</strong></td>
<td>Cross Traffic Assist</td>
<td style="text-align: left;">倒车横向告警</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>BSD</strong></td>
<td>Blind spot Detection</td>
<td style="text-align: left;">盲区监测系统</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>HD-AVM</strong></td>
<td>High Definition Around view Monitor</td>
<td style="text-align: left;">高画质环视监控</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>LDW</strong></td>
<td>Lane Departure Warning</td>
<td style="text-align: left;">低速车道偏离报警</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>DVR</strong></td>
<td>Driving Video Record</td>
<td style="text-align: left;">行车记录仪</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>RM</strong></td>
<td>Remote Monitoring</td>
<td style="text-align: left;">远程监控</td>
</tr>
</tbody>
</table>
<h2 id="检测系统">检测系统</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">缩写</th>
<th>英文名称</th>
<th>中文名称</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>MOD</strong></td>
<td>Moving Object Detection</td>
<td>移动目标检测</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>PD</strong></td>
<td>Pedestrian Detection</td>
<td>行人检测</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>3-DOD</strong></td>
<td>3D Object Detection</td>
<td>3D 目标检测</td>
</tr>
</tbody>
</table>
<h2 id="执行器">执行器</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">缩写</th>
<th>英文名称</th>
<th>中文名称</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>ACM</strong></td>
<td>Actuator Control Module</td>
<td>执行器控制系统</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>EPS</strong></td>
<td>Electronic Power Steering</td>
<td>电子助力转向系统</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>TCU</strong></td>
<td>Transmission Control Unit</td>
<td>变速器控制单元</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>EMS</strong></td>
<td>Engine Management System</td>
<td>发动机管理系统</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>SAS</strong></td>
<td>Steering Angle Sensor</td>
<td>转角传感器</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>BCM</strong></td>
<td>Body Control Module</td>
<td>车身控制器</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>ESC</strong></td>
<td>Electronic Stability Control</td>
<td>电子稳定控制</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>VCU</strong></td>
<td>Vehicle Control Unit</td>
<td>车辆控制单元</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>EPB</strong></td>
<td>Electronic Parking Brake</td>
<td>电子驻车</td>
</tr>
</tbody>
</table>
<h2 id="其它">其它</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">缩写</th>
<th style="text-align: left;">英文名称</th>
<th style="text-align: left;">中文名称</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>SEA</strong></td>
<td style="text-align: left;">Side Exit Alert</td>
<td style="text-align: left;">开门告警</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>HMI</strong></td>
<td style="text-align: left;">Human-Machine Interface</td>
<td style="text-align: left;">人机交互接口</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>IP</strong></td>
<td style="text-align: left;">Instrument Panel</td>
<td style="text-align: left;">仪表</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>HU</strong></td>
<td style="text-align: left;">Head Unit</td>
<td style="text-align: left;">主机</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>AC</strong></td>
<td style="text-align: left;">Air Condition</td>
<td style="text-align: left;">空调</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>车辆基础</category>
      </categories>
      <tags>
        <tag>车辆术语</tag>
        <tag>名称缩写</tag>
      </tags>
  </entry>
  <entry>
    <title>Perception Ultrasonic(超声波感知)</title>
    <url>/2024/08/08/Perception-Ultrasonic/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>在自动驾驶使用场景中，一般会使用各类传感器(摄像头、激光雷达、毫米波雷达和超声波雷达等)来感知周围环境信息，传感器收集的大量信息，通过各类算法最终融合到一个真实的语义地图上，下游模块通过该语义地图做相应的规划和决策。</p>
<h2 id="超声波">超声波</h2>
<p>超声波雷达是一种利用声波反射原理进行测距的传感器，主要用于短距离测量，一般测量范围在0.1m-5m之间，具有体积小、成本低、安装方便等特点。</p>
<h3 id="测距原理">测距原理</h3>
<figure>
<img data-src="https://s2.loli.net/2024/08/11/Fhpx4VjbDR1MkWd.jpg" alt="测距原理" /><figcaption aria-hidden="true">测距原理</figcaption>
</figure>
<p><span class="math display">\[
D = T_{f} * V_{s} * k
\]</span></p>
<p>其中，<span class="math display">\[T_f\]</span>表示超声波的飞行时间，及超声波走完距离<span class="math display">\[D\]</span>所需的时间，<span class="math display">\[V_s\]</span>表示声音在空气中的速度，<span class="math display">\[k\]</span>表示一个接近0.5的常数，一般由传感器的结构决定(收发压电换能器的位置)。</p>
<h3 id="声速">声速</h3>
<p>声波在空气的速度与温度的关系近似如下： <span class="math display">\[V_s\approx20.055*\sqrt{T}\]</span> 其中，<span class="math display">\[T\]</span>表示绝对温度，单位<span class="math display">\[K\]</span>。 当温度在 <span class="math display">\[0-40℃\]</span>范围变化是，声速在<span class="math display">\[330-360 m/s\]</span>范围内变化，因此温度应作为距离的测量的关键因素考虑，故一般要求安装温度传感器获取环境温度。</p>
<h3 id="声波特性">声波特性</h3>
<figure>
<img data-src="https://s2.loli.net/2024/08/11/MRvDS2jpEZy8q1x.png" alt="声波特性" /><figcaption aria-hidden="true">声波特性</figcaption>
</figure>
<ul>
<li><strong>频率</strong>：声波的频率是指每秒钟内声波完成的全振动次数，单位为赫兹（Hz）。人耳能听到的声音频率范围大约在20 Hz到20,000 Hz之间。超声波传感器通常工作在更高的频率，如几十kHz甚至几百kHz。</li>
<li><strong>周期</strong>：声波的周期是指完成一次全振动所需要的时间，单位为秒（s）。频率和周期的关系是互为倒数，即 <span class="math display">\[f = \frac{1}{T}\]</span>，其中<span class="math display">\[f\]</span>表示频率，<span class="math display">\[T\]</span>表示周期。</li>
<li><strong>波长</strong>：声波的波长是指在空气中传播时，两个相邻的同相位点之间的距离，单位为米（m）。波长和频率、声速的关系是 <span class="math display">\[λ = \frac{v}{f}\]</span>，其中<span class="math display">\[λ\]</span>表示波长，<span class="math display">\[v\]</span>表示声速，<span class="math display">\[f\]</span>表示频率。</li>
<li><strong>声速</strong>：声速是指声波在介质中传播的速度，单位为米每秒（m/s）。不同介质的声速不同，例如在空气中，声速约为340 m/s；在水中，声速约为1,500 m/s；在钢铁中，声速则高达5,000 m/s以上。</li>
<li><strong>振幅</strong>：声波的振幅是指声波的最大位移，单位为帕斯卡（Pa）或牛顿每平方米（N/m²）。振幅越大，声音的响度越高；振幅越小，声音的响度越低。</li>
</ul>
<p>超声波在不同介质下的传播特性如下：</p>
<figure>
<img data-src="https://s2.loli.net/2024/08/11/i9kVoaOK6sARbtl.png" alt="声波的反射与折射" /><figcaption aria-hidden="true">声波的反射与折射</figcaption>
</figure>
<h4 id="反射特性">反射特性</h4>
<p>如下图所示，超声波反射一般会遇到如下场景：</p>
<figure>
<img data-src="https://s2.loli.net/2024/08/11/Fzo6H3rvbSL4wPA.jpg" alt="反射场景" /><figcaption aria-hidden="true">反射场景</figcaption>
</figure>
<h5 id="墙面反射">墙面反射</h5>
<figure>
<img data-src="https://s2.loli.net/2024/08/11/QRHbErZ64dnyAha.png" alt="墙面反射" /><figcaption aria-hidden="true">墙面反射</figcaption>
</figure>
<figure>
<img data-src="https://s2.loli.net/2024/08/11/JW8rVtfmTI7NdX1.jpg" alt="反射原理" /><figcaption aria-hidden="true">反射原理</figcaption>
</figure>
]]></content>
      <categories>
        <category>perception</category>
        <category>ultrasonic</category>
      </categories>
      <tags>
        <tag>perception</tag>
        <tag>ultrasonic</tag>
      </tags>
  </entry>
</search>
