<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>TVM export_lib函数分析</title>
    <url>/2021/10/08/TVM-ExportLibrary/</url>
    <content><![CDATA[<h1 id="概述">1. 概述</h1>
<p>本文分析<strong>executor_lib</strong>函数的处理过程，其中包括<strong>DSO</strong>模块的编译和<strong>imported modules</strong>模块的序列化。</p>
<p><img data-src="https://i.loli.net/2021/10/10/3h8wfXOej514JLH.jpg" /></p>
<span id="more"></span>
<h1 id="分析">2. 分析</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">export_library</span>(<span class="params">self, file_name, fcompile=<span class="literal">None</span>, addons=<span class="literal">None</span>, **kwargs</span>):</span><br><span class="line">    <span class="keyword">return</span> self.module.export_library(file_name, fcompile, addons, **kwargs)</span><br></pre></td></tr></table></figure>
<p>首先调用<strong>relay.build</strong>最终生成<strong>GraphExecutorFactoryModule</strong>对象，位于<code>python/tvm/relay/backend/executor_factory.py</code>文件中。使用<strong>export_library</strong>导出动态库时，实际上调用的是<strong>GraphExecutorFactoryModule</strong>类本身的<strong>module</strong>中的<strong>export_library</strong>函数。该对象指向<strong>tvm.graph_executor_factory.create</strong>函数，是在<strong>C++</strong>端实现的函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fcreate = get_global_func(<span class="string">&quot;tvm.graph_executor_factory.create&quot;</span>)</span><br><span class="line">args = []</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> params.items():</span><br><span class="line">    args.append(k)</span><br><span class="line">    args.append(ndarray.array(v))</span><br><span class="line">self.module = fcreate(graph_json_str, libmod, libmod_name, *args)</span><br></pre></td></tr></table></figure>
<p>接下来进入<code>src/runtime/graph_executor/graph_executor_factory.cc</code>文件，使用<strong>TVM_REGISTER_GLOBAL</strong>宏定义将函数暴露到python端，函数体是lamda表达式。首先进行参数数量检查，然后进行参数重组，将参数按照命名存储进<strong>params</strong>对象中，然后创建<strong>GraphExecutorFactory</strong>对象。其中<strong>module_name</strong>默认值为<strong>default</strong>。然后导入所有<strong>runtime_module</strong>，最后将<strong>GraphExecutorFactory</strong>对象传入<strong>Module</strong>模块并返回。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TVM_REGISTER_GLOBAL</span>(<span class="string">&quot;tvm.graph_executor_factory.create&quot;</span>)</span><br><span class="line">    .<span class="built_in">set_body</span>([](TVMArgs args, TVMRetValue* rv) &#123;</span><br><span class="line">        <span class="built_in">ICHECK_GE</span>(args.num_args, <span class="number">3</span>) &lt;&lt; <span class="string">&quot;The expected number of arguments for &quot;</span></span><br><span class="line">            <span class="string">&quot;graph_executor_factory.create needs at least 3, &quot;</span></span><br><span class="line">            <span class="string">&quot;but it has &quot;</span></span><br><span class="line">            &lt;&lt; args.num_args;</span><br><span class="line">        <span class="comment">// The argument order is graph_json, module, module_name, param0_name, param0_tensor,</span></span><br><span class="line">        <span class="comment">// [param1_name, param1_tensor], ...</span></span><br><span class="line">        <span class="built_in">ICHECK_EQ</span>((args.<span class="built_in">size</span>() - <span class="number">3</span>) % <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        std::unordered_map&lt;std::string, tvm::runtime::NDArray&gt; params;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">3</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(args.<span class="built_in">size</span>()); i += <span class="number">2</span>) &#123;</span><br><span class="line">            std::string name = args[i].<span class="keyword">operator</span> <span class="built_in">String</span>();</span><br><span class="line">            params[name] = args[i + <span class="number">1</span>].<span class="keyword">operator</span> tvm::runtime::<span class="built_in">NDArray</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// graph_json, params, module_name</span></span><br><span class="line">        <span class="keyword">auto</span> exec = <span class="built_in">make_object</span>&lt;GraphExecutorFactory&gt;(args[<span class="number">0</span>], params, args[<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">// module</span></span><br><span class="line">        exec-&gt;<span class="built_in">Import</span>(args[<span class="number">1</span>]);</span><br><span class="line">        *rv = <span class="built_in">Module</span>(exec);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="module">2.1. Module</h2>
<h3 id="export_library">2.1.1. export_library</h3>
<p>关于<strong>Module</strong>类位于<code>python/tvm/runtime/module.py</code>文件中，该类中包含<strong>export_library</strong>函数。该函数的主要作用是将模块和所有被导入模块导出为一个简单的动态库。</p>
<h4 id="collect-dso-module">2.1.1.1. Collect DSO Module</h4>
<p>首先收集所有<strong>DSO</strong>模块(LLVM Module 和 C Module)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">modules = self._collect_dso_modules()</span><br></pre></td></tr></table></figure>
<h4 id="save-file">2.1.1.2. Save File</h4>
<p>一旦收集到所有的<strong>DSO</strong>模块，就可以调用<strong>runtime</strong>模块的<strong>save</strong>函数将其保存为文件格式。通过遍历所有<strong>DSO</strong>模块，根据其类型键设置相应的文件后缀，并通过<strong>save</strong>函数将模块保存为相应的文件类型，并将该文件添加到<strong>files</strong>数组序列中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> index, module <span class="keyword">in</span> <span class="built_in">enumerate</span>(modules):</span><br><span class="line">    <span class="keyword">if</span> fcompile <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="built_in">hasattr</span>(fcompile, <span class="string">&quot;object_format&quot;</span>):</span><br><span class="line">        <span class="keyword">if</span> module.type_key == <span class="string">&quot;c&quot;</span>:</span><br><span class="line">            object_format = <span class="string">&quot;c&quot;</span></span><br><span class="line">            has_c_module = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        	object_format = fcompile.object_format</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> module.type_key == <span class="string">&quot;llvm&quot;</span>:</span><br><span class="line">        	object_format = <span class="string">&quot;o&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">assert</span> module.type_key == <span class="string">&quot;c&quot;</span></span><br><span class="line">            object_format = <span class="string">&quot;c&quot;</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;cc&quot;</span> <span class="keyword">in</span> kwargs:</span><br><span class="line">                <span class="keyword">if</span> kwargs[<span class="string">&quot;cc&quot;</span>] == <span class="string">&quot;nvcc&quot;</span>:</span><br><span class="line">                	object_format = <span class="string">&quot;cu&quot;</span></span><br><span class="line">        	has_c_module = <span class="literal">True</span></span><br><span class="line">    path_obj = os.path.join(workspace_dir, <span class="string">f&quot;lib<span class="subst">&#123;index&#125;</span>.<span class="subst">&#123;object_format&#125;</span>&quot;</span>)</span><br><span class="line">    module.save(path_obj)</span><br><span class="line">    files.append(path_obj)</span><br><span class="line">    is_system_lib = (</span><br><span class="line">    	module.type_key == <span class="string">&quot;llvm&quot;</span> <span class="keyword">and</span> module.get_function(<span class="string">&quot;__tvm_is_system_module&quot;</span>)()</span><br><span class="line">    )</span><br><span class="line">    llvm_target_triple = (</span><br><span class="line">    	module.type_key == <span class="string">&quot;llvm&quot;</span> <span class="keyword">and</span> module.get_function(<span class="string">&quot;_get_target_triple&quot;</span>)()</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<h5 id="save函数">2.1.1.2.1 save函数</h5>
<p>关于<strong>save</strong>函数，其调用C++端的函数<strong>ModuleSaveToFile</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">save</span>(<span class="params">self, file_name, fmt=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Save the module to file.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This do not save the dependent device modules.</span></span><br><span class="line"><span class="string">    See also export_shared</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    file_name : str</span></span><br><span class="line"><span class="string">    The name of the file.</span></span><br><span class="line"><span class="string">    fmt : str</span></span><br><span class="line"><span class="string">    The format of the file.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    See Also</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    runtime.Module.export_library : export the module to shared library.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    _ffi_api.ModuleSaveToFile(self, file_name, fmt)</span><br></pre></td></tr></table></figure>
<p>该函数使用各个模块的<strong>SaveToFile</strong>函数将模块保存为文件形式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TVM_REGISTER_GLOBAL</span>(<span class="string">&quot;runtime.ModuleSaveToFile&quot;</span>)</span><br><span class="line">    .<span class="built_in">set_body_typed</span>([](Module mod, tvm::String name, tvm::String fmt) &#123;</span><br><span class="line">        mod-&gt;<span class="built_in">SaveToFile</span>(name, fmt);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="impoerted-modules">2.1.1.3. Impoerted Modules</h4>
<p>检查是否存在<strong>imported modules</strong>(像<strong>CUDA</strong>、<strong>OpenCL</strong>等)。这里不限制模块类型，一旦存在<strong>imports modules</strong>，将创建命名为<code>devc.o</code>或<code>devc.c</code>的文件。这就可以将<strong>imports modules</strong>的二进制<strong>blob</strong>数据嵌入进动态库中。然后调用<strong>ModulePackImportsToLLVM</strong>或<strong>ModulePackImportsToC</strong>进行模块序列化(<strong>module serialization</strong>)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> self.imported_modules:</span><br><span class="line">    <span class="keyword">if</span> enabled(<span class="string">&quot;llvm&quot;</span>) <span class="keyword">and</span> llvm_target_triple:</span><br><span class="line">        path_obj = os.path.join(workspace_dir, <span class="string">f&quot;devc.<span class="subst">&#123;object_format&#125;</span>&quot;</span>)</span><br><span class="line">        m = _ffi_api.ModulePackImportsToLLVM(self, is_system_lib, llvm_target_triple)</span><br><span class="line">        m.save(path_obj)</span><br><span class="line">        files.append(path_obj)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        path_cc = os.path.join(workspace_dir, <span class="string">&quot;devc.c&quot;</span>)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(path_cc, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(_ffi_api.ModulePackImportsToC(self, is_system_lib))</span><br><span class="line">        files.append(path_cc)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：使用<strong>PackImportsToLLVM</strong>或<strong>PackImportsToC</strong>取决于是否在TVM中使能LLVM，事实上它们的目标相同。</p>
</blockquote>
<h4 id="function-compile">2.1.1.4. Function Compile</h4>
<p>最后调用<strong>fcompile</strong>去编译生成动态共享库(so)。如果用户没有指定编译器类型，默认采用<strong>cc</strong>编译器，如果文件是<strong>tar</strong>压缩文件，则进行文件解压。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> fcompile:</span><br><span class="line">	<span class="keyword">if</span> file_name.endswith(<span class="string">&quot;.tar&quot;</span>):</span><br><span class="line">		fcompile = _tar.tar</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		fcompile = _cc.create_shared</span><br></pre></td></tr></table></figure>
<p>如果用户指定了编译器，一般在部署到设备端时会指定交叉编译工具，则使用用户指定的编译器进行编译。编译输入参数包括编译生成的文件名，待编译的文件组和编译参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fcompile(file_name, files, **kwargs)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于C 源码模块，将编译他们并一起与DSO模块进行链接。</p>
</blockquote>
<h3 id="module-serialization">2.1.2. Module Serialization</h3>
<p>在文件<code>src/target/codegen.cc</code>中，注册了全局函数<strong>runtime.ModulePackImportsToC</strong>和<strong>runtime.ModulePackImportsToLLVM</strong>，用于将其暴露到<strong>python</strong>端调用。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Export two auxiliary function to the runtime namespace.</span></span><br><span class="line"><span class="built_in">TVM_REGISTER_GLOBAL</span>(<span class="string">&quot;runtime.ModulePackImportsToC&quot;</span>).<span class="built_in">set_body_typed</span>(PackImportsToC);</span><br><span class="line"><span class="built_in">TVM_REGISTER_GLOBAL</span>(<span class="string">&quot;runtime.ModulePackImportsToLLVM&quot;</span>).<span class="built_in">set_body_typed</span>(PackImportsToLLVM);</span><br></pre></td></tr></table></figure></p>
<h4 id="serializemodule">2.1.2.1 SerializeModule</h4>
<p>其中，<strong>PackImportsToC</strong>和<strong>PackImportsToLLVM</strong>函数都调用<strong>SerializeModule</strong>函数序列化<strong>runtime module</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">PackImportsToC</span><span class="params">(<span class="type">const</span> runtime::Module&amp; mod, <span class="type">bool</span> system_lib)</span> </span>&#123;</span><br><span class="line">	std::string bin = <span class="built_in">SerializeModule</span>(mod);</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">runtime::Module <span class="title">PackImportsToLLVM</span><span class="params">(<span class="type">const</span> runtime::Module&amp; mod, <span class="type">bool</span> system_lib,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">const</span> std::string&amp; target_triple)</span> </span>&#123;</span><br><span class="line">	std::string bin = <span class="built_in">SerializeModule</span>(mod);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="moduleserializer">2.1.2.2. ModuleSerializer</h4>
<p>首先在<strong>SerializeModule</strong>函数中创建一个帮手类<strong>ModuleSerializer</strong>，其传入<strong>module</strong>做一些初始化工作，像标注模块的索引号等，然后调用该类的<strong>SerializeModule</strong>函数序列化模块。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">SerializeModule</span><span class="params">(<span class="type">const</span> runtime::Module&amp; mod)</span> </span>&#123;</span><br><span class="line">    std::string bin;</span><br><span class="line">    <span class="function">dmlc::MemoryStringStream <span class="title">ms</span><span class="params">(&amp;bin)</span></span>;</span><br><span class="line">    dmlc::Stream* stream = &amp;ms;</span><br><span class="line"></span><br><span class="line">    <span class="function">ModuleSerializer <span class="title">module_serializer</span><span class="params">(mod)</span></span>;</span><br><span class="line">    module_serializer.<span class="built_in">SerializeModule</span>(stream);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建<strong>module_serializer</strong>对象时，其构造函数调用<strong>Init</strong>函数进行初始化操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">ModuleSerializer</span><span class="params">(runtime::Module mod)</span> : mod_(mod) &#123;</span> <span class="built_in">Init</span>(); &#125;</span><br></pre></td></tr></table></figure>
<h5 id="init">2.1.2.2.1. Init</h5>
<p>而在<code>Init</code>函数中，分别调用<strong>CreateModuleIndex</strong>和<strong>CreateImportTree</strong>函数，用于创建<strong>模块索引号</strong>和<strong>导入树</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">CreateModuleIndex</span>();</span><br><span class="line">    <span class="built_in">CreateImportTree</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="createmoduleindex">2.1.2.2.1.1. CreateModuleIndex</h6>
<p>在函数<strong>CreateModuleIndex</strong>中将使用<strong>DFS</strong>(深度优先)算法检查模块导入关系并为其创建索引，注意根模块固定为位置0。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">llvm_mod<span class="punctuation">:</span>imported_modules</span><br><span class="line">  - cuda_mod</span><br><span class="line">  - opencl_mod</span><br></pre></td></tr></table></figure>
<p>因此，<strong>LLVM</strong>模块将会拥有索引值0，<strong>CUDA</strong>模块将拥有索引值1，<strong>OpenCL</strong>模块将拥有索引值为2。</p>
<h6 id="createimporttree">2.1.2.2.1.2. CreateImportTree</h6>
<p>在构建模块索引号后，<strong>CreateImportTree</strong>函数将尝试构建导入树，用于将导出的库加载回来时，恢复模块的导入关系。使用<strong>CSR</strong>(Compressed Sparse Row)格式存储导入树。每一行都是父索引，子索引对应其子索引。</p>
<p>使用<code>import_tree_row_ptr_</code>表示行偏移，即某一行的第一个元素在values里面的起始偏移位置。<code>import_tree_child_indices_</code>表示子索引值。</p>
<h5 id="serializemodule-1">2.1.2.2.2. SerializeModule</h5>
<p>通过上述两个函数初始化后，可以使用<strong>SerializeModule</strong>函数序列化模块。在其功能逻辑中，假定序列化格式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">binary_blob_size</span><br><span class="line">binary_blob_type_key</span><br><span class="line">binary_blob_logic</span><br><span class="line">binary_blob_type_key</span><br><span class="line">binary_blob_logic</span><br><span class="line">...</span><br><span class="line">_import_tree</span><br><span class="line">_import_tree_logic</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>binary_blob_size</strong></li>
</ul>
<p>表示序列化步骤中将拥有的<strong>blob</strong>数量。如果只有一个<strong>DSO</strong>模块并且是根模块，将不产生<code>import_tree_</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Only have one DSO module and it is in the root, then</span></span><br><span class="line"><span class="comment">// we will not produce import_tree_.</span></span><br><span class="line"><span class="type">bool</span> has_import_tree = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">DSOExportable</span>(mod_.<span class="keyword">operator</span>-&gt;()) &amp;&amp; mod_-&gt;<span class="built_in">imports</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">	has_import_tree = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据是否存在<code>import_tree_</code>，如果不存在，<strong>binary_blob_size</strong>字段直接写入模块数量，否则写入所有模块数量并追加1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> sz = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (has_import_tree) &#123;</span><br><span class="line">    <span class="comment">// we will append one key for _import_tree</span></span><br><span class="line">    <span class="comment">// The layout is the same as before: binary_size, key, logic, key, logic...</span></span><br><span class="line">    sz = mod_group_vec_.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Keep the old behaviour</span></span><br><span class="line">    sz = mod_-&gt;<span class="built_in">imports</span>().<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line">stream-&gt;<span class="built_in">Write</span>(sz);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>binary_blob_type_key</strong></li>
</ul>
<p>表示模块的<strong>blob</strong>类型键，对于LLVM或C模块，其<strong>blob</strong>类型键是<code>_lib</code>。而其它模块，像<strong>CUDA</strong>模块，其类型键为<strong>cuda</strong>；<strong>OpenCL</strong>模块，其类型键为<strong>opencl</strong>等。关于类型键的可以通过<strong>module-&gt;type_key()</strong>获取。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; group : mod_group_vec_) &#123;</span><br><span class="line">    <span class="built_in">ICHECK_NE</span>(group.<span class="built_in">size</span>(), <span class="number">0</span>) &lt;&lt; <span class="string">&quot;Every allocated group must have at least one module&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">DSOExportable</span>(group[<span class="number">0</span>])) &#123;</span><br><span class="line">        <span class="built_in">ICHECK_EQ</span>(group.<span class="built_in">size</span>(), <span class="number">1U</span>) &lt;&lt; <span class="string">&quot;Non DSO module is never merged&quot;</span>;</span><br><span class="line">        std::string mod_type_key = group[<span class="number">0</span>]-&gt;<span class="built_in">type_key</span>();</span><br><span class="line">        stream-&gt;<span class="built_in">Write</span>(mod_type_key);</span><br><span class="line">        group[<span class="number">0</span>]-&gt;<span class="built_in">SaveToBinary</span>(stream);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// DSOExportable: do not need binary</span></span><br><span class="line">        <span class="keyword">if</span> (has_import_tree) &#123;</span><br><span class="line">            std::string mod_type_key = <span class="string">&quot;_lib&quot;</span>;</span><br><span class="line">            stream-&gt;<span class="built_in">Write</span>(mod_type_key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>binary_blob_logic</strong></li>
</ul>
<p>表示<strong>blob</strong>的逻辑处理，对于大多数的<strong>blob</strong>(像<strong>CUDA</strong>、<strong>OpenCL</strong>)，将会调用其模块的<strong>SaveToBinary</strong>函数序列化为二进制形式。但是像<strong>LLVM</strong>或<strong>C</strong>模块，只要写入<code>_lib</code>字符，表明该模块是<code>DSO</code>模块。</p>
<ul>
<li><strong>import_tree</strong></li>
</ul>
<p>除非模块只有一个<strong>DSO</strong>模块且为根模块，不需要写入<code>_import_tree</code>字段，其它情况都需要写入。当将导出的库需要加载回来时，可以用其重构模块的导入关系。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Write _import_tree key if we have</span></span><br><span class="line"><span class="keyword">if</span> (has_import_tree) &#123;</span><br><span class="line">    std::string import_key = <span class="string">&quot;_import_tree&quot;</span>;</span><br><span class="line">    stream-&gt;<span class="built_in">Write</span>(import_key);</span><br><span class="line">    stream-&gt;<span class="built_in">Write</span>(import_tree_row_ptr_);</span><br><span class="line">    stream-&gt;<span class="built_in">Write</span>(import_tree_child_indices_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>import_tree_logic</strong></li>
</ul>
<p>将<code>import_tree_row_ptr_</code>和<code>import_tree_child_indices_</code>数组内容写入数据流。</p>
<h4 id="pack">2.1.2.3. Pack</h4>
<p>经过上述序列化步骤后，将数据流打包成一个符号(<strong>runtime::symbol::tvm_dev_mblob</strong>)，这样就可以在需要时从动态库中恢复模块内容。写入动态库中的符号为<code>__tvm_dev_mblob</code>，根据序列化后的数据流大小创建以<code>__tvm_dev_mblob</code>为符号的数组<code>const unsigned char __tvm_dev_mblob[bin.length() + sizeof(nbytes)]&#123;&#125;</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> nbytes = bin.<span class="built_in">length</span>();</span><br><span class="line">os &lt;&lt; <span class="string">&quot;const unsigned char &quot;</span> &lt;&lt; runtime::symbol::tvm_dev_mblob &lt;&lt; <span class="string">&quot;[&quot;</span></span><br><span class="line">	&lt;&lt; bin.<span class="built_in">length</span>() + <span class="built_in">sizeof</span>(nbytes) &lt;&lt; <span class="string">&quot;] = &#123;\n  &quot;</span>;</span><br></pre></td></tr></table></figure>
<p>前八个字节存储序列化数据流的字节数大小，按照16进制形式保存。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(nbytes); ++i) &#123;</span><br><span class="line">    <span class="comment">// sperators</span></span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">    	os &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;0x&quot;</span> &lt;&lt; ((nbytes &gt;&gt; (i * <span class="number">8</span>)) &amp; <span class="number">0xff</span>UL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>20个字节为一行，保存序列化数据。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; bin.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">    <span class="comment">// sperators</span></span><br><span class="line">    <span class="keyword">if</span> ((i + <span class="built_in">sizeof</span>(nbytes)) % nunit == <span class="number">0</span>) &#123;</span><br><span class="line">    	os &lt;&lt; <span class="string">&quot;,\n  &quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	os &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> c = bin[i];</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;0x&quot;</span> &lt;&lt; (c &amp; <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考">3. 参考</h1>
<ol type="1">
<li><p><a href="https://www.cnblogs.com/xbinworld/p/4273506.html">稀疏矩阵存储格式总结+存储效率对比:COO,CSR,DIA,ELL,HYB</a></p></li>
<li><p><a href="https://blog.csdn.net/alai04/article/details/733230">用STL实现DFS/BFS算法——检查重复状态</a></p></li>
</ol>
]]></content>
      <categories>
        <category>TVM</category>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>TVM</tag>
        <tag>runtime</tag>
        <tag>Module</tag>
        <tag>export_library</tag>
      </tags>
  </entry>
  <entry>
    <title>TVM LoadFromFile函数分析</title>
    <url>/2021/09/29/TVM-LoadFromFile/</url>
    <content><![CDATA[<h1 id="概述">1. 概述</h1>
<p>本文主要分析动态库(.so)文件的加载过程，其中包括模块的<strong>反序列化</strong>和<strong>GraphExecuter</strong> 的创建流程。</p>
<figure>
<img data-src="https://i.loli.net/2021/10/07/pxhqTXVPRGmSMv5.jpg" alt="东台条子泥" /><figcaption aria-hidden="true">东台条子泥</figcaption>
</figure>
<span id="more"></span>
<h1 id="动态库加载">2. 动态库加载</h1>
<p>当使用函数<strong>relay.build</strong>将模型转换为<strong>GraphExecutorFactoryModule</strong>类型的<strong>lib</strong>对象后，就可以在<strong>python</strong>端和<strong>C++</strong>端调用库文件去执行模型推理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lib = relay.build(model, target, params)</span><br></pre></td></tr></table></figure>
<h2 id="直接构建">2.1. 直接构建</h2>
<p>由于<strong>lib</strong>的类型为<strong>GraphExecutorFactory</strong>，且在编译阶段，如果用户不特别指定模型名，默认模型名为<strong>default</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">ir_mod, target=<span class="literal">None</span>, target_host=<span class="literal">None</span>, params=<span class="literal">None</span>, mod_name=<span class="string">&quot;default&quot;</span></span>):</span><br></pre></td></tr></table></figure>
<p>可以基于<strong>lib</strong>对象直接构建运行模块，其中<code>lib["default"](dev)</code>操作相当于调用<strong>GetFunction</strong>函数传入参数<strong>dev</strong>并返回模块名为<strong>default</strong>的<strong>runtime Module</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">PackedFunc <span class="title">GraphExecutorFactory::GetFunction</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; name, <span class="type">const</span> tvm::runtime::ObjectPtr&lt;tvm::runtime::Object&gt;&amp; sptr_to_self)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == module_name_) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">PackedFunc</span>([sptr_to_self, <span class="keyword">this</span>](TVMArgs args, TVMRetValue* rv) &#123;</span><br><span class="line">            std::vector&lt;Device&gt; devices;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; args.num_args; ++i) &#123;</span><br><span class="line">                devices.<span class="built_in">emplace_back</span>(args[i].<span class="keyword">operator</span> <span class="built_in">Device</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            *rv = <span class="keyword">this</span>-&gt;<span class="built_in">ExecutorCreate</span>(devices);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后使用<code>python/tvm/contrib/graph_executor.py</code>文件中的<strong>GraphModule</strong>类型对返回的<strong>runtime Module</strong>进行封装。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">graph_mod = tvm.contrib.GraphModule(lib[<span class="string">&quot;default&quot;</span>](dev))</span><br></pre></td></tr></table></figure>
<p>上述封装方便使用统一接口进行模型输入设定、运行和获取输出结果等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph_mod.set_input(&quot;x&quot;, data)</span><br><span class="line">graph_mod.run()</span><br><span class="line">graph_mod.get_output(0, out_data)</span><br></pre></td></tr></table></figure>
<h2 id="基于动态库文件构建">2.2. 基于动态库文件构建</h2>
<p>基于动态库文件的构建方式，首先需要调用<strong>GraphExecutorFactoryModule</strong>类中的<strong>export_library</strong>函数，将<strong>lib</strong>对象导出为<code>xxx.so</code>动态库的形式。然后在需要构建时调用<strong>load_module</strong>或<strong>LoadFromFile</strong>函数加载动态库并生成相应的<strong>runtime::Module</strong>对象。</p>
<ul>
<li><strong>python</strong>端</li>
</ul>
<p>在<code>python/tvm/runtime/module.py</code>文件中，使用<strong>tvm.runtime.load_module</strong>函数加载动态库。</p>
<ul>
<li><strong>C++</strong>端</li>
</ul>
<p>在<code>src/runtime/module.cc</code>文件中，使用<strong>tvm::runtime::Module::LoadFromFile</strong>函数加载动态库。</p>
<h3 id="load_module">2.2.1. load_module</h3>
<p>首先判定待加载文件是否存在，然后根据文件后缀类型是否为<code>.o</code>或<code>.tar</code>，自动调用<strong>cc.create_shared</strong>编译器进行文件编译并生成<code>.so</code>库文件并追加到<strong>path</strong>中。支持该操作是为了与<strong>RPC</strong>加载保持一致。最后调用全局函数<strong>ModuleLoadFromFile</strong>，通过<strong>TVM_REGISTER_GLOBAL</strong>宏将<strong>Module::LoadFromFile</strong>函数注册为全局函数<strong>runtime.ModuleLoadFromFile</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_module</span>(<span class="params">path, fmt=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(path):</span><br><span class="line">        path = os.path.realpath(path)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;cannot find file %s&quot;</span> % path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># c++ compiler/linker</span></span><br><span class="line">    cc = os.environ.get(<span class="string">&quot;CXX&quot;</span>, <span class="string">&quot;g++&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># High level handling for .o and .tar file.</span></span><br><span class="line">    <span class="comment"># We support this to be consistent with RPC module load.</span></span><br><span class="line">    <span class="keyword">if</span> path.endswith(<span class="string">&quot;.o&quot;</span>):</span><br><span class="line">        <span class="comment"># Extra dependencies during runtime.</span></span><br><span class="line">        <span class="keyword">from</span> tvm.contrib <span class="keyword">import</span> cc <span class="keyword">as</span> _cc</span><br><span class="line"></span><br><span class="line">        _cc.create_shared(path + <span class="string">&quot;.so&quot;</span>, path, cc=cc)</span><br><span class="line">        path += <span class="string">&quot;.so&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> path.endswith(<span class="string">&quot;.tar&quot;</span>):</span><br><span class="line">        <span class="comment"># Extra dependencies during runtime.</span></span><br><span class="line">        <span class="keyword">from</span> tvm.contrib <span class="keyword">import</span> cc <span class="keyword">as</span> _cc, utils <span class="keyword">as</span> _utils, tar <span class="keyword">as</span> _tar</span><br><span class="line"></span><br><span class="line">        tar_temp = _utils.tempdir(custom_path=path.replace(<span class="string">&quot;.tar&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">        _tar.untar(path, tar_temp.temp_dir)</span><br><span class="line">        files = [tar_temp.relpath(x) <span class="keyword">for</span> x <span class="keyword">in</span> tar_temp.listdir()]</span><br><span class="line">        _cc.create_shared(path + <span class="string">&quot;.so&quot;</span>, files, cc=cc)</span><br><span class="line">        path += <span class="string">&quot;.so&quot;</span></span><br><span class="line">    <span class="comment"># Redirect to the load API</span></span><br><span class="line">    <span class="keyword">return</span> _ffi_api.ModuleLoadFromFile(path, fmt)</span><br></pre></td></tr></table></figure>
<h3 id="loadfromfile">2.2.2. LoadFromFile</h3>
<p>首先进行文件的类型判断，如果类型为<strong>dll</strong>、<strong>dylib</strong>或<strong>dso</strong>，统一调用<strong>runtime.module.loadfile_so</strong>函数进行文件处理。然后根据文件后缀类型，调用不同的加载函数<code>std::string load_f_name = "runtime.module.loadfile_" + fmt</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Module <span class="title">Module::LoadFromFile</span><span class="params">(<span class="type">const</span> std::string&amp; file_name, <span class="type">const</span> std::string&amp; format)</span> </span>&#123;</span><br><span class="line">  std::string fmt = <span class="built_in">GetFileFormat</span>(file_name, format);</span><br><span class="line">  <span class="built_in">ICHECK</span>(fmt.<span class="built_in">length</span>() != <span class="number">0</span>) &lt;&lt; <span class="string">&quot;Cannot deduce format of file &quot;</span> &lt;&lt; file_name;</span><br><span class="line">  <span class="keyword">if</span> (fmt == <span class="string">&quot;dll&quot;</span> || fmt == <span class="string">&quot;dylib&quot;</span> || fmt == <span class="string">&quot;dso&quot;</span>) &#123;</span><br><span class="line">    fmt = <span class="string">&quot;so&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::string load_f_name = <span class="string">&quot;runtime.module.loadfile_&quot;</span> + fmt;</span><br><span class="line">  <span class="type">const</span> PackedFunc* f = Registry::<span class="built_in">Get</span>(load_f_name);</span><br><span class="line">  Module m = (*f)(file_name, format);</span><br><span class="line">  <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="runtime.module.loadfile_so">2.2.2.1. runtime.module.loadfile_so</h4>
<p>在<code>src/runtime/dso_library.cc</code>文件中注册了<strong>runtime.module.loadfile_so</strong>全局函数。首先创建<strong>DSOLibrary</strong>对象，并将待加载的文件名参数传入到<strong>init</strong>函数中，用于初始化<strong>DSOLibrary</strong>对象<strong>n</strong>。然后调用<strong>CreateModuleFromLibrary</strong>函数，将创建的<strong>DSOLibrary</strong>对象<strong>n</strong>传入该函数中，该函数位于文件<code>src/runtime/library_module.cc</code>中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TVM_REGISTER_GLOBAL</span>(<span class="string">&quot;runtime.module.loadfile_so&quot;</span>).<span class="built_in">set_body</span>([](TVMArgs args, TVMRetValue* rv) &#123;</span><br><span class="line">  <span class="keyword">auto</span> n = <span class="built_in">make_object</span>&lt;DSOLibrary&gt;();</span><br><span class="line">  n-&gt;<span class="built_in">Init</span>(args[<span class="number">0</span>]);</span><br><span class="line">  *rv = <span class="built_in">CreateModuleFromLibrary</span>(n);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="dsolibrary">2.2.2.1.1. DSOLibrary</h5>
<p>根据系统平台不同，<strong>DSOLibrary</strong>对象会调用不同的<strong>Load</strong>函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> </span>&#123; <span class="built_in">Load</span>(name); &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Windows</strong></li>
</ul>
<p>使用<code>#include &lt;windows.h&gt;</code>函数库加载动态库。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Load the library</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Load</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// use wstring version that is needed by LLVM.</span></span><br><span class="line">    <span class="function">std::wstring <span class="title">wname</span><span class="params">(name.begin(), name.end())</span></span>;</span><br><span class="line">    lib_handle_ = <span class="built_in">LoadLibraryW</span>(wname.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">ICHECK</span>(lib_handle_ != <span class="literal">nullptr</span>) &lt;&lt; <span class="string">&quot;Failed to load dynamic shared library &quot;</span> &lt;&lt; name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Linux</strong></li>
</ul>
<p>使用<code>#include &lt;dlfcn.h&gt;</code>函数库来加载动态库。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Library handle</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* lib_handle_&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// load the library</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Load</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">lib_handle_ = <span class="built_in">dlopen</span>(name.<span class="built_in">c_str</span>(), RTLD_LAZY | RTLD_LOCAL);</span><br><span class="line"></span><br><span class="line"><span class="built_in">ICHECK</span>(lib_handle_ != <span class="literal">nullptr</span>) &lt;&lt; <span class="string">&quot;Failed to load dynamic shared library &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">dlerror</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="createmodulefromlibrary">2.2.2.1.2. CreateModuleFromLibrary</h5>
<p>该函数主要实现从动态库中恢复<strong>runtime::Module</strong>对象的过程，包括反序列化和重新构建模块间导入的关系。</p>
<ul>
<li><strong>InitContextFunctions</strong></li>
</ul>
<p>调用<strong>InitContextFunctions</strong>函数从动态库中获取上下文相关函数的函数句柄。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">InitContextFunctions</span>([lib](<span class="type">const</span> <span class="type">char</span>* fname) &#123; <span class="keyword">return</span> lib-&gt;<span class="built_in">GetSymbol</span>(fname); &#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Load the imported modules</strong></li>
</ul>
<p>从动态库中获取<code>__tvm_dev_mblob</code>符号，将符号地址返回到<strong>dev_mblob</strong>对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* dev_mblob = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(lib-&gt;<span class="built_in">GetSymbol</span>(runtime::symbol::tvm_dev_mblob));</span><br></pre></td></tr></table></figure>
<p>如果<code>dev_mblob != nullptr</code>，即动态库中存在<code>__tvm_dev_mblob</code>符号，说明动态库中存在序列化的<strong>imported modules</strong>，则调用<strong>ProcessModuleBlob</strong>函数对其进行处理。否则表明动态库中只有一个简单的<strong>DSO Module</strong>，直接将动态库转为<strong>LibraryModuleNode</strong>对象<strong>n</strong>，并基于<strong>n</strong>构造<strong>runtime::Module</strong>对象<strong>root_mod</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (dev_mblob != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">ProcessModuleBlob</span>(dev_mblob, lib, &amp;root_mod, &amp;dso_ctx_addr);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Only have one single DSO Module</span></span><br><span class="line">    root_mod = <span class="built_in">Module</span>(n);</span><br><span class="line">    dso_ctx_addr = root_mod.<span class="keyword">operator</span>-&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="initcontextfunctions">2.2.2.1.2.1 InitContextFunctions</h6>
<p>函数<strong>InitContextFunctions</strong>用于初始化上下文函数，将动态库对应的函数的地址映射到相应函数名，即从动态库中获取相关功能函数的函数句柄。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Initialize the functions</span></span><br><span class="line"><span class="built_in">TVM_INIT_CONTEXT_FUNC</span>(TVMFuncCall);</span><br><span class="line"><span class="built_in">TVM_INIT_CONTEXT_FUNC</span>(TVMAPISetLastError);</span><br><span class="line"><span class="built_in">TVM_INIT_CONTEXT_FUNC</span>(TVMBackendGetFuncFromEnv);</span><br><span class="line"><span class="built_in">TVM_INIT_CONTEXT_FUNC</span>(TVMBackendAllocWorkspace);</span><br><span class="line"><span class="built_in">TVM_INIT_CONTEXT_FUNC</span>(TVMBackendFreeWorkspace);</span><br><span class="line"><span class="built_in">TVM_INIT_CONTEXT_FUNC</span>(TVMBackendParallelLaunch);</span><br><span class="line"><span class="built_in">TVM_INIT_CONTEXT_FUNC</span>(TVMBackendParallelBarrier);</span><br></pre></td></tr></table></figure>
<h6 id="processmoduleblob">2.2.2.1.2.2. ProcessModuleBlob</h6>
<p>该函数主要实现对序列化的<strong>module</strong>进行反序列化处理，恢复导入模块的关系。</p>
<ol type="1">
<li>获取字段大小</li>
</ol>
<p>首先根据<strong>dev_mblob</strong>字段的前<span style="color:red">8</span>个字节，获取<strong>blob</strong>字段的大小。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> nbytes = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(nbytes); ++i) &#123;</span><br><span class="line">    <span class="type">uint64_t</span> c = mblob[i];</span><br><span class="line">    nbytes |= (c &amp; <span class="number">0xff</span>UL) &lt;&lt; (i * <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>构建数据流</li>
</ol>
<p>根据<strong>blob</strong>字段的大小和地址，创建<strong>dmlc::MemoryFixedSizeStream fs</strong>对象，然后将<strong>fs</strong>对象转化为数据流。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">dmlc::MemoryFixedSizeStream <span class="title">fs</span><span class="params">(<span class="keyword">const_cast</span>&lt;<span class="type">char</span>*&gt;(mblob + <span class="keyword">sizeof</span>(nbytes)),</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">static_cast</span>&lt;<span class="type">size_t</span>&gt;(nbytes))</span></span>;</span><br><span class="line">dmlc::Stream* stream = &amp;fs;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>读取<strong>blob</strong>数量</li>
</ol>
<p>首先读取blob数量，然后根据数量大小，循环处理每个blob的对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> size;</span><br><span class="line"><span class="built_in">ICHECK</span>(stream-&gt;<span class="built_in">Read</span>(&amp;size));</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>处理<strong>blob</strong>对象</li>
</ol>
<p>在处理blob对象时，根据<strong>type_key</strong>类型不同，分别进行不同方式的处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;Module&gt; modules;</span><br><span class="line">std::vector&lt;<span class="type">uint64_t</span>&gt; import_tree_row_ptr;</span><br><span class="line">std::vector&lt;<span class="type">uint64_t</span>&gt; import_tree_child_indices;</span><br><span class="line"><span class="type">int</span> num_dso_module = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">uint64_t</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">    std::string tkey;</span><br><span class="line">    <span class="built_in">ICHECK</span>(stream-&gt;<span class="built_in">Read</span>(&amp;tkey));</span><br><span class="line">    <span class="keyword">if</span> (tkey == <span class="string">&quot;_lib&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// construct dso module using lib</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tkey == <span class="string">&quot;_import_tree&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// READ(_import_tree_row_ptr)</span></span><br><span class="line">        <span class="comment">// READ(_import_tree_child_indices)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// call module.loadbinary_blob_type_key, such as module.loadbinary_cuda to restore.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>type_key == "_lib"</code></li>
</ul>
<p>如果类型键为<code>_lib</code>，直接将动态库转化为<strong>LibraryModuleNode</strong>对象，然后调用<strong>runtime::Module</strong>构造函数，进一步转化为<strong>dso_module</strong>对象，并且<strong>DSO</strong>的上下文地址也指向<strong>dso_module</strong>对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> dso_module = <span class="built_in">Module</span>(<span class="built_in">make_object</span>&lt;LibraryModuleNode&gt;(lib));</span><br><span class="line">*dso_ctx_addr = dso_module.<span class="keyword">operator</span>-&gt;();</span><br><span class="line">++num_dso_module;</span><br><span class="line">modules.<span class="built_in">emplace_back</span>(dso_module);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>type_key == "_import_tree"</code></li>
</ul>
<p>如果类型键为<code>_import_tree</code>，则依次读取<strong>import_tree_row_ptr</strong>和<strong>import_tree_child_indices</strong>数组的内容，用于后续构建导入模块的关系。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ICHECK</span>(stream-&gt;<span class="built_in">Read</span>(&amp;import_tree_row_ptr));</span><br><span class="line"><span class="built_in">ICHECK</span>(stream-&gt;<span class="built_in">Read</span>(&amp;import_tree_child_indices));</span><br></pre></td></tr></table></figure>
<ul>
<li><code>other type_key</code></li>
</ul>
<p>如果类型键非<code>_lib</code>或<code>_import_tree</code>类型，则调用<strong>LoadModuleFromBinary</strong>函数从二进制流中根据<strong>type_key</strong>加载相应的<strong>runtime::Module</strong>，并将模型推送进<strong>modules</strong>对象中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> m = <span class="built_in">LoadModuleFromBinary</span>(tkey, stream);</span><br><span class="line">modules.<span class="built_in">emplace_back</span>(m);</span><br></pre></td></tr></table></figure>
<p>在函数<strong>LoadModuleFromBinary</strong>中，调用注册的全局函数<code>runtime.module.loadbinary_ + type_key</code>，实现二进制数据流到相应<strong>runtime::Module</strong>的转换。目前<strong>TVM</strong>框架中已经存在的<code>type_key</code>包括如下：</p>
<table>
<thead>
<tr class="header">
<th>arm_compute_lib</th>
<th>bnns_json</th>
<th>coreml</th>
<th>dnnl_json</th>
<th>ethos-n</th>
<th>tensorrt</th>
<th>cuda</th>
<th>opencl</th>
<th>vulkan</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Module <span class="title">LoadModuleFromBinary</span><span class="params">(<span class="type">const</span> std::string&amp; type_key, dmlc::Stream* stream)</span> </span>&#123;</span><br><span class="line">    std::string loadkey = <span class="string">&quot;runtime.module.loadbinary_&quot;</span>;</span><br><span class="line">    std::string fkey = loadkey + type_key;</span><br><span class="line">    <span class="type">const</span> PackedFunc* f = Registry::<span class="built_in">Get</span>(fkey);</span><br><span class="line">    <span class="keyword">return</span> (*f)(<span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(stream));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5" type="1">
<li>重新构建模块关系</li>
</ol>
<p>如果读取的<strong>import_tree_row_ptr</strong>为空，说明动态库中无导入树，可能使用的是老版本的动态库格式。直接使用动态库<strong>lib</strong>构建<strong>LibraryModuleNode</strong>类型对象<strong>n</strong>，然后获取实例对象<strong>n</strong>的<code>imports_</code>成员的地址并赋给<strong>module_import_addr</strong>变量。将从二进制数据流中恢复的所有<strong>modules</strong>都追加到<strong>module_import_addr</strong>中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> n = <span class="built_in">make_object</span>&lt;LibraryModuleNode&gt;(lib);</span><br><span class="line"><span class="keyword">auto</span> module_import_addr = ModuleInternal::<span class="built_in">GetImportsAddr</span>(n.<span class="keyword">operator</span>-&gt;());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; m : modules) &#123;</span><br><span class="line">    module_import_addr-&gt;<span class="built_in">emplace_back</span>(m);</span><br><span class="line">&#125;</span><br><span class="line">*dso_ctx_addr = n.<span class="built_in">get</span>();</span><br><span class="line">*root_module = <span class="built_in">Module</span>(n);</span><br></pre></td></tr></table></figure>
<p>如果存在<strong>import_tree_row_ptr</strong>对象，则按照<strong>CSR</strong>格式恢复模块间的关系。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; modules.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> j = import_tree_row_ptr[i]; j &lt; import_tree_row_ptr[i + <span class="number">1</span>]; ++j) &#123;</span><br><span class="line">        <span class="keyword">auto</span> module_import_addr = ModuleInternal::<span class="built_in">GetImportsAddr</span>(modules[i].<span class="keyword">operator</span>-&gt;());</span><br><span class="line">        <span class="keyword">auto</span> child_index = import_tree_child_indices[j];</span><br><span class="line">        <span class="built_in">ICHECK</span>(child_index &lt; modules.<span class="built_in">size</span>());</span><br><span class="line">        module_import_addr-&gt;<span class="built_in">emplace_back</span>(modules[child_index]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ICHECK</span>(!modules.<span class="built_in">empty</span>()) &lt;&lt; <span class="string">&quot;modules cannot be empty when import tree is present&quot;</span>;</span><br><span class="line"><span class="comment">// invariance: root module is always at location 0.</span></span><br><span class="line"><span class="comment">// The module order is collected via DFS</span></span><br><span class="line">*root_module = modules[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<h6 id="lookup-symbol-from-boot">2.2.2.1.2.3. lookup symbol from boot</h6>
<p>如果动态库中存在<code>__tvm_module_ctx</code>符号，则将该根地址指向<strong>DSO</strong>模块地址<strong>dso_ctx_addr</strong>。从而允许从根模块查找符号，实现所有符号都可见。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// allow lookup of symbol from root (so all symbols are visible).</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span>* ctx_addr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>**&gt;(lib-&gt;<span class="built_in">GetSymbol</span>(runtime::symbol::tvm_module_ctx))) &#123;</span><br><span class="line">    *ctx_addr = dso_ctx_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TVM</category>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>TVM</tag>
        <tag>Runtime</tag>
        <tag>LoadFromFile</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>crazyflie-CRTP解析</title>
    <url>/2020/01/29/crazyflie-CRTP%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>本文主要分析CRTP协议的结构，对该协议结构的理解，有助于后续的数据扩展和对软件架构的理解。为了和Crazyflie通信，<strong>Crazyflie</strong> 飞控中提出一种高层次的协议叫做 <strong>CRTP</strong> (<code>Crazy RealTime Protocol</code>)。这种简单的协议使用一些可以收发数据的双向目标端口，但是大都时候通信由主机发起。</p>
<p><img data-src="https://i.loli.net/2021/08/30/1kaHc4AvGdPVZ3t.jpg" /></p>
<span id="more"></span>
<h2 id="物理载体">物理载体</h2>
<p>当前CRTP同时支持 Crazyradio 和 USB(只针对Crazyflie 2.0)模式。</p>
<table>
<thead>
<tr class="header">
<th>物理载体</th>
<th>支持的飞控</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Crazyradio (PA)</td>
<td>Crazyflie 1.0/2.0</td>
</tr>
<tr class="even">
<td>USB</td>
<td>Crazyflie 2.0</td>
</tr>
</tbody>
</table>
<h2 id="协议头">协议头</h2>
<p>每个数据包拥有1字节的数据头和31字节有效数据载荷，数据头布局如下： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   7    6    5    4    3    2    1    0</span><br><span class="line">+----+----+----+----+----+----+----+----+</span><br><span class="line">|       Port        |  Link   |  Chan.  |</span><br><span class="line">+----+----+----+----+----+----+----+----+</span><br></pre></td></tr></table></figure></p>
<p>其中：</p>
<ul>
<li><strong>Port</strong>: 用来区别与消息相关的功能和任务</li>
<li><strong>Link</strong>: 为以后使用预留</li>
<li><strong>Channel</strong>: 用来识别子任务和子功能</li>
</ul>
<h2 id="端口分配">端口分配</h2>
<p>当前端口分配如下：</p>
<table>
<thead>
<tr class="header">
<th>端口</th>
<th>目标</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>Console</td>
<td>读取使用consoleprintf打印到Crazyflie控制台上的控制台信息</td>
</tr>
<tr class="even">
<td>2</td>
<td>Parameters</td>
<td>获取或设置Crazyflie参数.Crazyflie源码中宏定义参数</td>
</tr>
<tr class="odd">
<td>3</td>
<td>Commander</td>
<td>发送控制 滚转/俯仰/偏航/油门调节的设置点</td>
</tr>
<tr class="even">
<td>4</td>
<td>Memory access</td>
<td>访问类似于单线或I2C总线的非易失性存储器 (只支持Crazyflie 2.0)</td>
</tr>
<tr class="odd">
<td>5</td>
<td>Data logging</td>
<td>设置包含需要在特殊周期发回Crazyflie的变量的日记块.</td>
</tr>
<tr class="even">
<td>6</td>
<td>Localization</td>
<td>与定位相关的数据包</td>
</tr>
<tr class="odd">
<td>7</td>
<td>Generic Setpoint</td>
<td>允许发送设置点和控制模式</td>
</tr>
<tr class="even">
<td>13</td>
<td>Platform</td>
<td>用于其它平台控制，例如调试和关机</td>
</tr>
<tr class="odd">
<td>14</td>
<td>Client-side debugging</td>
<td>调试界面并只存在于Crazyflie Python API，Crazyflie飞控本身不具备</td>
</tr>
<tr class="even">
<td>15</td>
<td>Link layer</td>
<td>用于控制和询问通信连接</td>
</tr>
</tbody>
</table>
<h3 id="console端口说明">Console端口说明</h3>
<p>该端口作为一种文本控制台方式，可以使用<strong>consoleprintf</strong> 函数从<em>Crazyflie</em>飞控端到主机端打印文本信息。</p>
<h4 id="通信协议">通信协议</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Answer (Crazyflie to host):</span><br><span class="line">        +---------//-----------+</span><br><span class="line">        | PRINTED CONSOLE TEXT |</span><br><span class="line">        +---------//-----------+</span><br><span class="line">Length          0-31</span><br></pre></td></tr></table></figure>
<p>如果任何如下条件满足，飞行器端的缓存区的内容将被发送：</p>
<ul>
<li>输出缓存区满(31字节)</li>
<li>一个"新行"字符已经被发送(或 </li>
<li>已发出刷新命令</li>
</ul>
<h4 id="代码分析">代码分析</h4>
<p>参考源文件 <strong>console.c</strong>，函数调用关系如下：</p>
<p><img data-src="https://i.loli.net/2021/08/30/co8R6P7NvJUEbd2.png" style="zoom:67%;" /></p>
<h5 id="consoleinit函数说明">consoleInit函数说明</h5>
<p>该函数用于初始化相关变量，并创建二值型信号量<strong>synch</strong>用于任务间，任务和中断间同步。</p>
<h6 id="流程图">流程图</h6>
<p><img data-src="https://i.loli.net/2021/08/30/UpS7EqtLHMgZTb4.png" /></p>
<h5 id="consoletest函数说明">consoleTest函数说明</h5>
<p>该函数返回初始化结果，初始化成功即测试通过。</p>
<h5 id="consoleputs函数说明">consolePuts函数说明</h5>
<p>该函数用于发送字符串。</p>
<h6 id="流程图-1">流程图</h6>
<p><img data-src="https://i.loli.net/2021/08/30/zfXnJgUK2LDhoqk.png" /></p>
<p>该函数主要通过调用<strong>consolePutchar</strong>函数，实现字符串的发送。</p>
<h5 id="consoleputchar函数说明">consolePutchar函数说明</h5>
<p>该函数用于发送单字节字符。</p>
<p>参考module/interface/console.h文件,通过utils/src/eprintf.c文件中的<strong>eprintf</strong>函数，将<strong>consolePutchar</strong>函数映射到通用打印函数，使用宏定义<strong>consolePrintf</strong>表示。其中<strong>VA_ARGS</strong>是可变参数宏。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> consolePrintf(FMT, ...) eprintf(consolePutchar, FMT, ## __VA_ARGS__)</span></span><br></pre></td></tr></table></figure>
<p>在utils/interface/debug.h文件中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_PRINT(fmt, ...) consolePrintf(DEBUG_FMT(fmt), ##__VA_ARGS__)</span></span><br></pre></td></tr></table></figure>
<p>使用<strong>DEBUG_PRINT</strong>宏定义映射<strong>consolePrintf</strong>函数，通过无线模块或者USB接口发送，并在控制台显示。</p>
<h6 id="流程图-2">流程图</h6>
<p><img data-src="https://i.loli.net/2021/08/30/8NzcIVtgue7W49x.png" style="zoom: 50%;" /></p>
<h5 id="consoleputcharfromisr函数说明">consolePutcharFromISR函数说明</h5>
<p>该函数用于在中断中运行，进行字符的发送工作。</p>
<h6 id="流程图-3">流程图</h6>
<p><img data-src="https://i.loli.net/2021/08/30/7n8b19MoajglFEZ.png" style="zoom:50%;" /></p>
<h5 id="consolesendmessage函数说明">consoleSendMessage函数说明</h5>
<p>该函数用于将消息缓存区的的数据<strong>messageToPrint</strong>，通过<strong>CRTP</strong>函数发送出去。</p>
<h5 id="addbufferfullmarker">addBufferFullMarker</h5>
<p>该函数用于当发送队列快满时，在队列缓存区最后加上缓存区满的标志(<F>)。</p>
<h5 id="findmarkerstart函数说明">findMarkerStart函数说明</h5>
<p>该函数用于查找标志的起始位置。</p>
<h5 id="consoleflush函数说明">consoleFlush函数说明</h5>
<p>该函数用于发送清空缓存区的内容。</p>
<h3 id="parameters端口说明">Parameters端口说明</h3>
<p>参数系统使得飞行器的所有可获得和可设置参数可访问。飞行器拥有一个可修改得参数表，在这个表中，每个参数都和一个ID和一个组名相关联。三个ID用于访问TOC，参数如下：</p>
<table>
<thead>
<tr class="header">
<th>Port</th>
<th>Channel</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td>0</td>
<td><a href="####TOC访问">TOC 访问</a></td>
</tr>
<tr class="even">
<td>2</td>
<td>1</td>
<td><a href="#parameter-read">参数读取</a></td>
</tr>
<tr class="odd">
<td>2</td>
<td>2</td>
<td><a href="#parameter-write">参数写入</a></td>
</tr>
<tr class="even">
<td>2</td>
<td>3</td>
<td><a href="#misc-commands">其它命令</a></td>
</tr>
</tbody>
</table>
<h4 id="toc访问">TOC访问</h4>
<p>这些信息允许访问参数表的内容。信息的第一个字节是信息ID，信息ID定义如下：</p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>数值</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CMD_GET_ITEM</td>
<td>0</td>
<td>原始版本，获取TOC元素</td>
</tr>
<tr class="even">
<td>CMD_GET_INFO</td>
<td>1</td>
<td>原始版本，获取CRC信息</td>
</tr>
<tr class="odd">
<td>CMD_GET_ITEM_V2</td>
<td>2</td>
<td>V2版本，获取TOC元素</td>
</tr>
<tr class="even">
<td>CMD_GET_INFO_V2</td>
<td>3</td>
<td>V2版本，获取CRC信息</td>
</tr>
</tbody>
</table>
<p>上游数据ID和命令单独发送，下游数据包拥有如下形式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Bytes     1       1          1        空终止字符串</span><br><span class="line">        +---+------------+------+----------+--------------+</span><br><span class="line">        | 0 |  Param ID  | Type |  Group   |     Name     |</span><br><span class="line">        +---+------------+------+---+------+--------------+</span><br><span class="line">        | 1 | Num. Param |  CRC32   |</span><br><span class="line">        +---+------------+----------+</span><br><span class="line">Bytes     1       1           4</span><br></pre></td></tr></table></figure>
<p>参数被PC端有序请求直到最后。当达到最后参数时,ID为0'最后的TOC元素'，复位命令允许复位TOC指针，因此下一个发送TOC元素将会是第一个。“获取 TOC CRC”命令也会返回参数数量。</p>
<p>CRC32是飞行器TOC的哈希值。旨在PC应用程序中实现TOC的缓存以避免每次飞行器连接后获取完整的TOC。</p>
<p><strong>参数类型</strong>用一个字节描述如下：</p>
<table>
<thead>
<tr class="header">
<th>类型码</th>
<th>c语言类型</th>
<th>Python解包</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0x08</td>
<td>uint8_t</td>
<td>'&lt;B '</td>
</tr>
<tr class="even">
<td>0x09</td>
<td>uint16_t</td>
<td>'&lt;H'</td>
</tr>
<tr class="odd">
<td>0x0A</td>
<td>uint32_t</td>
<td>'&lt;L'</td>
</tr>
<tr class="even">
<td>0x0B</td>
<td>uint64_t</td>
<td>'&lt;Q'</td>
</tr>
<tr class="odd">
<td>0x00</td>
<td>int8_t</td>
<td>'&lt;b'</td>
</tr>
<tr class="even">
<td>0x01</td>
<td>int16_t</td>
<td>'&lt;h'</td>
</tr>
<tr class="odd">
<td>0x02</td>
<td>int32_t</td>
<td>'&lt;i'</td>
</tr>
<tr class="even">
<td>0x03</td>
<td>int64_t</td>
<td>'&lt;q'</td>
</tr>
<tr class="odd">
<td>0x05</td>
<td>FP16</td>
<td>''</td>
</tr>
<tr class="even">
<td>0x06</td>
<td>float</td>
<td>'&lt;f'</td>
</tr>
<tr class="odd">
<td>0x07</td>
<td>double</td>
<td>'&lt;d'</td>
</tr>
</tbody>
</table>
<h4 id="参数读取">参数读取</h4>
<p>PC客户端请求内容如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">字节</th>
<th style="text-align: center;">请求字段</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">ID</td>
<td>需要读取参数的ID</td>
</tr>
</tbody>
</table>
<p>Crazyflie飞控端应答内容如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">字节</th>
<th style="text-align: center;">应答字段</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">ID</td>
<td>参数ID值</td>
</tr>
<tr class="even">
<td style="text-align: center;">1- ...</td>
<td style="text-align: center;">数值</td>
<td>参数值。TOC中描述了大小和形式</td>
</tr>
</tbody>
</table>
<p>参数读取请求是在通道1上的一个简单包，Crazyflie飞控应答相应的参数值。</p>
<h4 id="参数写入">参数写入</h4>
<p>PC客户端请求写入内容如下：</p>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>请求字段</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>ID</td>
<td>需要写入的参数ID值</td>
</tr>
<tr class="even">
<td>1- ...</td>
<td>value</td>
<td>写入值，大小和形式在TOC中有描述</td>
</tr>
</tbody>
</table>
<p>Crazyflie飞控端应答内容如下：</p>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>应答字段</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>ID</td>
<td>参数ID</td>
</tr>
<tr class="even">
<td>1- ...</td>
<td>数值</td>
<td>参数值，大小和形式在TOC中有描述</td>
</tr>
</tbody>
</table>
<p>写入请求是一个通道2上的简单包。Crazyflie飞控发回参数值作为应答。</p>
<h4 id="其它命令">其它命令</h4>
<p>如下其它命令被使用：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>命令内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0x00</td>
<td>按名称设置</td>
</tr>
</tbody>
</table>
<h5 id="按名称设置">按名称设置</h5>
<p>请求内容</p>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>请求字段</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>按名称设置</td>
<td>0x00</td>
</tr>
<tr class="even">
<td>1~ n</td>
<td>组</td>
<td>组名</td>
</tr>
<tr class="odd">
<td>n ~ (n+1)</td>
<td>NULL</td>
<td>0</td>
</tr>
<tr class="even">
<td>(n+1) ~ (n+m+1)</td>
<td>名称</td>
<td>参数名称</td>
</tr>
<tr class="odd">
<td>(n+m+1)~(n+m+2)</td>
<td>NULL</td>
<td>0</td>
</tr>
<tr class="even">
<td>(n+m+2)~(n+m+3)</td>
<td>类型</td>
<td>参数类型</td>
</tr>
<tr class="odd">
<td>(n+m+3) ~ ...</td>
<td>数值</td>
<td>参数数值，大小和形式由类型描述</td>
</tr>
</tbody>
</table>
<p>应答内容</p>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>应答字段</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>按名称设置</td>
<td>0x00</td>
</tr>
<tr class="even">
<td>1~ n</td>
<td>组</td>
<td>组名</td>
</tr>
<tr class="odd">
<td>n ~ (n+1)</td>
<td>NULL</td>
<td>0</td>
</tr>
<tr class="even">
<td>(n+1) ~ (n+m+1)</td>
<td>名称</td>
<td>参数名称</td>
</tr>
<tr class="odd">
<td>(n+m+2)</td>
<td>NULL</td>
<td>0</td>
</tr>
<tr class="even">
<td>(n+m+3)</td>
<td>错误</td>
<td>如果参数被成功写入返回0.其它编码</td>
</tr>
</tbody>
</table>
<p>组名和参数名称是ASCII字符串的形式，对应的大小分别为n和m。</p>
<h3 id="commander端口说明">Commander端口说明</h3>
<p>命令端口被用来发送从PC客户端到Crazyflie飞控的控制指令，用来调节滚转、俯仰、偏航和油门等控制信号。随着通信链的建立这些数据包能被发送出去，并且直到下一包数据接收到之前该数值都是有效的。</p>
<h4 id="通信协议-1">通信协议</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">        +-------+-------+-------+-------+</span><br><span class="line">        | ROLL  | PITCH |  YAW  |THRUST |</span><br><span class="line">        +-------+-------+-------+-------+</span><br><span class="line">Length      4       4       4       2      bytes</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th>名称</th>
<th>字节</th>
<th>大小</th>
<th>类型</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>滚转角</td>
<td>0-3</td>
<td>4</td>
<td>float</td>
<td>滚转设置点</td>
</tr>
<tr class="even">
<td>俯仰角</td>
<td>4-7</td>
<td>4</td>
<td>float</td>
<td>俯仰设置点</td>
</tr>
<tr class="odd">
<td>偏航角</td>
<td>8-11</td>
<td>4</td>
<td>float</td>
<td>偏航设置点</td>
</tr>
<tr class="even">
<td>油门</td>
<td>12-13</td>
<td>2</td>
<td>uint16_t</td>
<td>油门设置点</td>
</tr>
</tbody>
</table>
<h3 id="memory-access端口说明">Memory access端口说明</h3>
<p>存储器访问对<a href="https://wiki.bitcraze.io/projects:crazyflie:index">Crazyflie Nano Quadcopter</a>无用，当前只在Crazyflie 2.0中应用。使用存储器访问给出如下可能性：</p>
<ul>
<li><p>获得哪些存储单元可用的信息；</p></li>
<li><p>读取/写入/擦除 存储器；</p></li>
</ul>
<p>当前如下存储器被支持：</p>
<ul>
<li><p>Crazyflie 2.0的板载EEPROM；</p></li>
<li><p>Crazyflie 2.0扩展板上的单线存储器；</p>
<p>有更多的信息关于EEPROM如何构建和单总线存储器如何工作和构建可用。</p></li>
</ul>
<h4 id="逻辑流程图">逻辑流程图</h4>
<p>对于客户端获取信息和读写存储器是可选择的，但是Crazyflie Python 客户端总是在连接状态下载关于存储器的信息。</p>
<p><img data-src="https://i.loli.net/2021/08/30/YCcEy3ufIKjP7gW.png" style="zoom:67%;" /></p>
<h4 id="通信协议-2">通信协议</h4>
<p>存储器端口使用3个不同的通道：</p>
<table>
<thead>
<tr class="header">
<th>端口</th>
<th>通道</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4</td>
<td>0</td>
<td>获取关于存储器数量和类型的信息并同时擦除</td>
</tr>
<tr class="even">
<td>4</td>
<td>1</td>
<td>读取存储器</td>
</tr>
<tr class="odd">
<td>4</td>
<td>2</td>
<td>写入存储器</td>
</tr>
</tbody>
</table>
<h5 id="通道0信息设置">通道0：信息/设置</h5>
<p>这个通道被用来获取存在的存储器数量、关于存储器的信息和大规模擦除内存的可能性。每个包的第一个字节是命令类型：</p>
<table>
<thead>
<tr class="header">
<th>命令内容</th>
<th>命令</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>GET_NBR_OF_MEMS</td>
<td>获取存储器的数量</td>
</tr>
<tr class="even">
<td>2</td>
<td>GET_MEM_INFO</td>
<td>获取关于存储器的信息</td>
</tr>
<tr class="odd">
<td>3</td>
<td>SET_MEM_ERASE</td>
<td>块擦除存储器</td>
</tr>
</tbody>
</table>
<h6 id="get_nbr_of_mems">GET_NBR_OF_MEMS</h6>
<p>这个被用来获取存在的存储器数量。</p>
<ul>
<li>请求从PC主机到Crazyflie飞控：</li>
</ul>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>字段</th>
<th>数值</th>
<th>长度</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>获取存储器数量</td>
<td>0x01</td>
<td>1</td>
<td>命令字节</td>
</tr>
</tbody>
</table>
<ul>
<li>响应从Crazyflie飞控到PC主机：</li>
</ul>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>字段</th>
<th>数值</th>
<th>长度</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>获取存储器数量</td>
<td>0x01</td>
<td>1</td>
<td>命令字节</td>
</tr>
<tr class="even">
<td>1</td>
<td>存储器数量</td>
<td></td>
<td>1</td>
<td>(所有类型)存在存储器数量</td>
</tr>
</tbody>
</table>
<p>例如当Crazyflie飞控上存在三个存储器时：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host-to-Crazyflie: &lt;port/chan&gt; 0x01</span><br><span class="line">Crazyflie-to-Host: &lt;port/chan&gt; 0x01 0x03</span><br></pre></td></tr></table></figure>
<h6 id="get_mem_info">GET_MEM_INFO</h6>
<p>该命令被用来获取存储器的ID信息。存储器的ID是顺序的，并且从0到1，其数值小于从GET_NUMBER_OF_MEMS返回的存储器数量。</p>
<ul>
<li>请求从PC主机到Crazyflie飞控：</li>
</ul>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>字段</th>
<th>数值</th>
<th>长度</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>获取存储器信息</td>
<td>0x02</td>
<td>1</td>
<td>命令字节</td>
</tr>
<tr class="even">
<td>1</td>
<td>存储器ID</td>
<td></td>
<td>1</td>
<td>存储器ID(0 &lt;= id &lt; 存储器数量)</td>
</tr>
</tbody>
</table>
<ul>
<li>如果id<strong>有效</strong>，应答从Crazyflie飞控到PC主机如下：</li>
</ul>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>字段</th>
<th>数值</th>
<th>长度</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>GET_MEM_INFO</td>
<td>0x02</td>
<td>1</td>
<td>命令字节</td>
</tr>
<tr class="even">
<td>1</td>
<td>MEM_ID</td>
<td></td>
<td>1</td>
<td>存储器ID</td>
</tr>
<tr class="odd">
<td>2</td>
<td>MEM_TYPE</td>
<td></td>
<td>1</td>
<td>存储器类型(详见如下)</td>
</tr>
<tr class="even">
<td>3</td>
<td>MEM_SIZE</td>
<td></td>
<td>4</td>
<td>存储器的字节数</td>
</tr>
<tr class="odd">
<td>7</td>
<td>MEM_ADDR</td>
<td></td>
<td>8</td>
<td>存储器地址(只对单总线存储器有效)</td>
</tr>
</tbody>
</table>
<p>关于<strong>MEM_ID</strong>字段如下：</p>
<table>
<thead>
<tr class="header">
<th>ID</th>
<th>数值</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>EEPROM_ID</td>
<td>0x00</td>
<td>关于</td>
</tr>
<tr class="even">
<td>LEDMEM_ID</td>
<td>0x01</td>
<td>LED环存储器ID</td>
</tr>
<tr class="odd">
<td>LOCO_ID</td>
<td>0x02</td>
<td>本地位置节点ID</td>
</tr>
<tr class="even">
<td>TRAJ_ID</td>
<td>0x03</td>
<td>轨迹ID</td>
</tr>
<tr class="odd">
<td>LOCO2_ID</td>
<td>0x04</td>
<td>本地位置节点2的ID</td>
</tr>
<tr class="even">
<td>LH_ID</td>
<td>0x05</td>
<td>灯塔基站的ID</td>
</tr>
<tr class="odd">
<td>TESTER_ID</td>
<td>0x06</td>
<td>存储器测试ID</td>
</tr>
<tr class="even">
<td>USD_ID</td>
<td>0x07</td>
<td><em>待确认</em></td>
</tr>
<tr class="odd">
<td>OW_FIRST_ID</td>
<td>0x08</td>
<td>第一个单总线存储器ID</td>
</tr>
</tbody>
</table>
<p>关于<strong>MEM_TYPE</strong>字段如下：</p>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>数值</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MEM_TYPE_EEPROM</td>
<td>0x00</td>
<td>电可擦除存储器</td>
</tr>
<tr class="even">
<td>MEM_TYPE_OW</td>
<td>0x01</td>
<td>单总线存储器</td>
</tr>
<tr class="odd">
<td>MEM_TYPE_LED12</td>
<td>0x10</td>
<td>LED环</td>
</tr>
<tr class="even">
<td>MEM_TYPE_LOCO</td>
<td>0x11</td>
<td>本地位置节点</td>
</tr>
<tr class="odd">
<td>MEM_TYPE_TRAJ</td>
<td>0x12</td>
<td>轨迹</td>
</tr>
<tr class="even">
<td>MEM_TYPE_LOCO2</td>
<td>0x13</td>
<td>本地位置节点2</td>
</tr>
<tr class="odd">
<td>MEM_TYPE_LH</td>
<td>0x14</td>
<td>灯塔基站</td>
</tr>
<tr class="even">
<td>MEM_TYPE_TESTER</td>
<td>0x15</td>
<td>存储器测试</td>
</tr>
<tr class="odd">
<td>MEM_TYPE_USD</td>
<td>0x16</td>
<td><em>待确认</em></td>
</tr>
</tbody>
</table>
<ul>
<li>如果id<strong>无效</strong>，应答从Crazyflie飞控到PC主机如下：</li>
</ul>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>字段</th>
<th>数值</th>
<th>长度</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>GET_MEM_INFO</td>
<td>0x02</td>
<td>1</td>
<td>字节命令</td>
</tr>
<tr class="even">
<td>1</td>
<td>MEM_ID</td>
<td></td>
<td>1</td>
<td>存储器id</td>
</tr>
</tbody>
</table>
<p>例如对于单总线存储器的请求内容如下：</p>
<p>MEM_ID=1, MEM_SIZE=112bytes, MEM_ADDR=0x1234567890ABCDEF</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host-to-Crazyflie: &lt;port/chan&gt; 0x02 0x01</span><br><span class="line">Crazyflie-to-Host: &lt;port/chan&gt; 0x02 0x01 0x01 0x70 0x00 0x00 0x00 0xEF 0xCD 0xAB 0x90 0x78 0x56 0x34 0x12</span><br></pre></td></tr></table></figure>
<p>例如请求的存储器索引信息无效时：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host-to-Crazyflie: &lt;port/chan&gt; 0x01 0x10</span><br><span class="line">Crazyflie-to-Host: &lt;port/chan&gt; 0x01 0x10</span><br></pre></td></tr></table></figure>
<h6 id="set_mem_erase代码中无描述">SET_MEM_ERASE(代码中无描述)</h6>
<p>该命令被用来块擦除给定的id存储器。存储器的id是顺序的，并且从0到1，其数值小于从GET_NUMBER_OF_MEMS返回的存储器数量。</p>
<ul>
<li>请求从PC主机到Crazyflie飞控：</li>
</ul>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>字段</th>
<th>数值</th>
<th>长度</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>SET_MEM_ERASE</td>
<td>0x03</td>
<td>1</td>
<td>命令字节</td>
</tr>
<tr class="even">
<td>1</td>
<td>MEM_ID</td>
<td></td>
<td>1</td>
<td>存储器ID(0 &lt;= id &lt; 存储器数量)</td>
</tr>
</tbody>
</table>
<ul>
<li>应答从Crazyflie飞控到PC主机：</li>
</ul>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>字段</th>
<th>数值</th>
<th>长度</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>SET_MEM_ERASE</td>
<td>0x03</td>
<td>1</td>
<td>命令字节</td>
</tr>
<tr class="even">
<td>1</td>
<td>MEM_ID</td>
<td></td>
<td>1</td>
<td>存储器id</td>
</tr>
<tr class="odd">
<td>2</td>
<td>STATUS</td>
<td></td>
<td>1</td>
<td>命令状态(详见如下)</td>
</tr>
</tbody>
</table>
<p>例如请求块擦除MEM_ID=2的存储器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host-to-Crazyflie: &lt;port/chan&gt; 0x03 0x02</span><br><span class="line">Crazyflie-to-Host: &lt;port/chan&gt; 0x03 0x02 0x00</span><br></pre></td></tr></table></figure>
<h5 id="通道1存储器读取">通道1：存储器读取</h5>
<p>这个通道只被用来读取存储器，因此信息不包含任何命令字节。</p>
<ul>
<li>请求从PC主机到Crazyflie飞控：</li>
</ul>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>字段</th>
<th>数值</th>
<th>长度</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>MEM_ID</td>
<td></td>
<td>1</td>
<td>存储器id(0 &lt;= id &lt; 存储器数量)</td>
</tr>
<tr class="even">
<td>1</td>
<td>MEM_ADDR</td>
<td></td>
<td>4</td>
<td>要读取的首字节地址</td>
</tr>
<tr class="odd">
<td>5</td>
<td>LEN</td>
<td></td>
<td>1</td>
<td>要被读取的字节数量</td>
</tr>
</tbody>
</table>
<ul>
<li>如果存储器的ID有效且地址和长度读取有效，则应答从Crazyflie飞控到PC主机如下：</li>
</ul>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>字段</th>
<th>数值</th>
<th>长度</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>MEM_ID</td>
<td></td>
<td>1</td>
<td>存储器id(0 &lt;= id &lt; 存储器数量)</td>
</tr>
<tr class="even">
<td>1</td>
<td>MEM_ADDR</td>
<td></td>
<td>4</td>
<td>要读取的首字节地址</td>
</tr>
<tr class="odd">
<td>5</td>
<td>STATUS</td>
<td></td>
<td>1</td>
<td>请求状态(详见如下)</td>
</tr>
<tr class="even">
<td>6</td>
<td>DATA</td>
<td></td>
<td>1 .. 24?</td>
<td>要读取的数据(只有MEM_ID/MEM_ADDR/LEN有效时)</td>
</tr>
</tbody>
</table>
<p>例如从MEM_ID=0x01 MEM_ADDR=0x0A读取LEN=0x0F字节数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host-to-Crazyflie: &lt;port/chan&gt; 0x01 0x0A 0x00 0x00 0x00 0x0F</span><br><span class="line">Crazyflie-to-Host: &lt;port/chan&gt; 0x01 0x0A 0x00 0x00 0x00 0x00 0x01 0x09 0x62 0x63 0x4C 0x65 0x64 0x52 0x69 0x6E 0x67 0x02 0x01 0x62 0x55 </span><br></pre></td></tr></table></figure>
<h5 id="通道2存储器写入">通道2：存储器写入</h5>
<p>该通道只被用来写入存储器，因此消息中不好含任何命令字节。</p>
<ul>
<li>请求从PC主机到Crazyflie飞控：</li>
</ul>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>字段</th>
<th>数值</th>
<th>长度</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>MEM_ID</td>
<td></td>
<td>1</td>
<td>存储器id(0 &lt;= id &lt; 存储器数量)</td>
</tr>
<tr class="even">
<td>1</td>
<td>MEM_ADDR</td>
<td></td>
<td>4</td>
<td>要写入的首字节地址</td>
</tr>
<tr class="odd">
<td>5</td>
<td>DATA</td>
<td></td>
<td>1 .. 24?</td>
<td>要写入的数据</td>
</tr>
</tbody>
</table>
<ul>
<li>如果存储器的ID有效并且地址和长度被写入有效，应答从Crazyflie飞控到PC主机：</li>
</ul>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>字段</th>
<th>数值</th>
<th>长度</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>MEM_ID</td>
<td></td>
<td>1</td>
<td>存储器id(0 &lt;= id &lt; 存储器数量)</td>
</tr>
<tr class="even">
<td>1</td>
<td>MEM_ADDR</td>
<td></td>
<td>4</td>
<td>要写入的首字节地址</td>
</tr>
<tr class="odd">
<td>5</td>
<td>STATUS</td>
<td></td>
<td>1</td>
<td>请求状态</td>
</tr>
</tbody>
</table>
<h3 id="datalog端口说明">DataLog端口说明</h3>
<p>log端口分为三个通道：</p>
<table>
<thead>
<tr class="header">
<th>端口</th>
<th>通道</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>5</td>
<td>0</td>
<td>访问内容表：用于读取出TOC</td>
</tr>
<tr class="even">
<td>5</td>
<td>1</td>
<td>日志控制操作：用于添加/删除/开始/暂停log块</td>
</tr>
<tr class="odd">
<td>5</td>
<td>2</td>
<td>日志数据操作：用于从Crazyflie飞控端到PC客户端发送log数据</td>
</tr>
</tbody>
</table>
<h4 id="访问内容表table-of-content-access">访问内容表(Table of content access)</h4>
<p>这个通道用来下载包含所有可记录变量和变量类型的内容表。每组信息的第一个字节对应于命令，所有这个通道的通信都被客户端初始化，并且所有来自飞行器的应答都包含同样的命令字节。</p>
<table>
<thead>
<tr class="header">
<th>TOC命令字</th>
<th>命令</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>CMD_GET_ITEM</td>
<td>原始版本：从TOC中获取元素</td>
</tr>
<tr class="even">
<td>1</td>
<td>CMD_GET_INFO</td>
<td>原始版本：获取TOC和LOG子系统的信息</td>
</tr>
<tr class="odd">
<td>2</td>
<td>CMD_GET_ITEM_V2</td>
<td>V2版本：从TOC中获取元素</td>
</tr>
<tr class="even">
<td>3</td>
<td>CMD_GET_INFO_V2</td>
<td>V2版本：获取TOC和LOG子系统的信息</td>
</tr>
</tbody>
</table>
<h5 id="get-toc-item">Get TOC item</h5>
<p>CMD_GET_ITEM命令允许从飞行器上检索日志变量名、组名和变量类型。该命令旨在从0到LOG_LEN 的所有ID中被请求。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Request (PC to Copter):</span><br><span class="line">        +--------------+----+</span><br><span class="line">        | GET_ITEM (0) | ID |</span><br><span class="line">        +--------------+----+</span><br><span class="line">Length         1         1</span><br><span class="line"></span><br><span class="line">Answer (Copter to PC):</span><br><span class="line">        +--------------+----+</span><br><span class="line">        | GET_ITEM (0) | ID |                                        If index out of range</span><br><span class="line">        +--------------+----+------+------------+--------------+</span><br><span class="line">        | GET_ITEM (0) | ID | Type |   Group    |     Name     |     If returning Item</span><br><span class="line">        +--------------+----+------+------------+--------------+</span><br><span class="line">Length        1          1     1    &lt; Null terminated strings &gt;</span><br></pre></td></tr></table></figure>
<p>下表说明PC端请求内容如下：</p>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>请求字段</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>GET_ITEM</td>
<td>数值0作为GET_ITEM操作</td>
</tr>
<tr class="even">
<td>1</td>
<td>ID</td>
<td>被检索元素的ID，变量数量从0到LOG_LEN</td>
</tr>
</tbody>
</table>
<p>下表说明Crazyflie飞控端的应答响应内容：</p>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>应答字段</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>GET_ITEM</td>
<td>数值0用于GET_ITEM操作</td>
</tr>
<tr class="even">
<td>1</td>
<td>ID</td>
<td>返回元素的ID</td>
</tr>
<tr class="odd">
<td>2</td>
<td>Type</td>
<td>元素的变量类型，详见变量类型列表</td>
</tr>
<tr class="even">
<td>3-...</td>
<td>Group</td>
<td>包含元素组名可变的空终止字符串</td>
</tr>
<tr class="odd">
<td>...</td>
<td>Name</td>
<td>包含元素变量名可变的空终止字符串</td>
</tr>
</tbody>
</table>
<p>如果请求的<strong>ID</strong>高于(TOC_LEN-1)，则元素类型、元素组名和元素变量名不被发送。</p>
<h5 id="get-info">Get Info</h5>
<p>当连接到飞行器时，首先要请求<strong>Get Info</strong>命令。该操作能够知道变量数量、日志实施的限制和日志变量的指纹。</p>
<p>原始版本的请求和应答流程如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Request (PC to Copter):</span><br><span class="line">        +--------------+</span><br><span class="line">        | GET_INFO (1) |</span><br><span class="line">        +--------------+</span><br><span class="line">Length         1</span><br><span class="line"></span><br><span class="line">Answer (Copter to PC):</span><br><span class="line">        +--------------+---------+---------+-----------------+-------------+</span><br><span class="line">        | GET_INFO (1) | LOG_LEN | LOG_CRC |  LOG_MAX_PACKET | LOG_MAX_OPS |</span><br><span class="line">        +--------------+---------+---------+-----------------+-------------+</span><br><span class="line">Length        1             1         4             1               1</span><br></pre></td></tr></table></figure>
<p>下表详述PC端的请求内容：</p>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>请求字段</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>GET_INFO</td>
<td>数值1用于<strong>GET_INFO</strong>操作</td>
</tr>
</tbody>
</table>
<p>下表详述crazyflie飞控应答内容：</p>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>应答字段</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>GET_INFO</td>
<td>数值1用于GET_INFO操作</td>
</tr>
<tr class="even">
<td>1</td>
<td>LOG_LEN</td>
<td>包含在日志表中的元素的数量</td>
</tr>
<tr class="odd">
<td>2</td>
<td>LOG_CRC</td>
<td>在日志TOC存储区内容数值的CRC值，这是飞行器版本的指纹</td>
</tr>
<tr class="even">
<td>6</td>
<td>LOG_MAX_PACKET</td>
<td>飞行器的最大日志包数量，可以在飞行器中编程</td>
</tr>
<tr class="odd">
<td>7</td>
<td>LOG_MAX_OPS</td>
<td>飞行器中的可编程操作的最大数量，该操作是一种日志变量检索程序</td>
</tr>
</tbody>
</table>
<h4 id="log-control">Log control</h4>
<p>日志控制通道允许安装、激活、失效和移除日志包。就像访问TOC通道第一个字节代表的命令，日志控制同样有如下命令：</p>
<table>
<thead>
<tr class="header">
<th>控制命令字节</th>
<th>命令</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>CREATE_BLOCK</td>
<td>创建一个新的日志块</td>
</tr>
<tr class="even">
<td>1</td>
<td>APPEND_BLOCK</td>
<td>在存在的日志块上追加变量</td>
</tr>
<tr class="odd">
<td>2</td>
<td>DELETE_BLOCK</td>
<td>删除一个日志块</td>
</tr>
<tr class="even">
<td>3</td>
<td>START_BLOCK</td>
<td>启用日志块传输</td>
</tr>
<tr class="odd">
<td>4</td>
<td>STOP_BLOCK</td>
<td>停止日志块传输</td>
</tr>
<tr class="even">
<td>5</td>
<td>RESET</td>
<td>删除所有的日志块</td>
</tr>
<tr class="odd">
<td>6</td>
<td>CREATE_BLOCK_V2</td>
<td>V2版本:创建一个新的日志块</td>
</tr>
<tr class="even">
<td>7</td>
<td>APPEND_BLOCK_V2</td>
<td>V2版本:在存在的日志块上追加变量</td>
</tr>
</tbody>
</table>
<h5 id="create-block">Create block</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Request (PC to Copter):</span><br><span class="line">										  &lt; 更多设置参数按如下结构扩展      &gt;</span><br><span class="line">        +------------------+--------------+--------------+-------------+</span><br><span class="line">        | CREATE_BLOCK (0) | LOG_BLOCK_ID | SET_LOG_TYPE |  SET_LOG_ID |</span><br><span class="line">        +------------------+--------------+--------------+-------------+</span><br><span class="line">Length         1				   1			  1				1</span><br><span class="line"></span><br><span class="line">Answer (Copter to PC):</span><br><span class="line">        +------------------+--------------+------------+</span><br><span class="line">        | CREATE_BLOCK (0) | LOG_BLOCK_ID | CREATE_STS |</span><br><span class="line">        +------------------+--------------+------------+</span><br><span class="line">Length            1               1               1</span><br></pre></td></tr></table></figure>
<p>返回状态参考<strong>&lt;errno.h&gt;</strong>文件内容。</p>
<h5 id="append-variable-to-block">Append variable to block</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Request (PC to Copter):</span><br><span class="line">										  &lt; 更多设置参数按如下结构扩展      &gt;</span><br><span class="line">        +------------------+--------------+--------------+-------------+</span><br><span class="line">        | APPEND_BLOCK (1) | LOG_BLOCK_ID | SET_LOG_TYPE |  SET_LOG_ID |</span><br><span class="line">        +------------------+--------------+--------------+-------------+</span><br><span class="line">Length         1				   1			  1				1</span><br><span class="line"></span><br><span class="line">Answer (Copter to PC):</span><br><span class="line">        +------------------+--------------+------------+</span><br><span class="line">        | APPEND_BLOCK (1) | LOG_BLOCK_ID | CREATE_STS |</span><br><span class="line">        +------------------+--------------+------------+</span><br><span class="line">Length            1               1               1</span><br></pre></td></tr></table></figure>
<p>返回状态参考<strong>&lt;errno.h&gt;</strong>文件内容。</p>
<h5 id="delelte-block">Delelte block</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Request (PC to Copter):</span><br><span class="line">        +------------------+--------------+</span><br><span class="line">        | DELETE_BLOCK (2) | LOG_BLOCK_ID |</span><br><span class="line">        +------------------+--------------+</span><br><span class="line">Length         1				   1		</span><br><span class="line"></span><br><span class="line">Answer (Copter to PC):</span><br><span class="line">        +------------------+--------------+------------+</span><br><span class="line">        | DELETE_BLOCK (2) | LOG_BLOCK_ID | CREATE_STS |</span><br><span class="line">        +------------------+--------------+------------+</span><br><span class="line">Length            1               1               1</span><br></pre></td></tr></table></figure>
<p>通过请求的LOG_BLOCK_ID，查找相关节点，并删除链表中的该节点。</p>
<h5 id="start-block">Start block</h5>
<p>通过启动相应的定时器实现日志的发送，并设置相应的周期时间。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Request (PC to Copter):</span><br><span class="line">        +-----------------+--------------+------------+</span><br><span class="line">        | START_BLOCK (3) | LOG_BLOCK_ID | LOG_PERIOD |</span><br><span class="line">        +-----------------+--------------+------------+</span><br><span class="line">Length         1				   1		     1</span><br><span class="line"></span><br><span class="line">Answer (Copter to PC):</span><br><span class="line">        +-----------------+--------------+------------+</span><br><span class="line">        | START_BLOCK (3) | LOG_BLOCK_ID | CREATE_STS |</span><br><span class="line">        +-----------------+--------------+------------+</span><br><span class="line">Length            1               1               1</span><br></pre></td></tr></table></figure>
<h5 id="stop-block">Stop block</h5>
<p>通过停止相应的定时器来停止日志数据的发送。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Request (PC to Copter):</span><br><span class="line">        +----------------+--------------+</span><br><span class="line">        | STOP_BLOCK (4) | LOG_BLOCK_ID |</span><br><span class="line">        +----------------+--------------+</span><br><span class="line">Length         1				   1		</span><br><span class="line"></span><br><span class="line">Answer (Copter to PC):</span><br><span class="line">        +----------------+--------------+------------+</span><br><span class="line">        | STOP_BLOCK (4) | LOG_BLOCK_ID | CREATE_STS |</span><br><span class="line">        +----------------+--------------+------------+</span><br><span class="line">Length          1               1               1</span><br></pre></td></tr></table></figure>
<h5 id="reset">Reset</h5>
<p>停止所有日志块的发送、删除所有日志块的内容，释放所有日志块的空间。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Request (PC to Copter):</span><br><span class="line">        +-----------+</span><br><span class="line">        | RESET (5) |</span><br><span class="line">        +-----------+</span><br><span class="line">Length       1					</span><br><span class="line"></span><br><span class="line">Answer (Copter to PC):</span><br><span class="line">        +-----------+--------------+------------+</span><br><span class="line">        | RESET (5) | LOG_BLOCK_ID | CREATE_STS |</span><br><span class="line">        +-----------+--------------+------------+</span><br><span class="line">Length        1             1             1</span><br></pre></td></tr></table></figure>
<h5 id="create-block-v2">CREATE BLOCK V2</h5>
<p>V2版本的日志块创建。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Request (PC to Copter):</span><br><span class="line">										  &lt; 更多设置参数按如下结构扩展      &gt;</span><br><span class="line">        +---------------------+--------------+--------------+-------------+</span><br><span class="line">        | CREATE_BLOCK_V2 (6) | LOG_BLOCK_ID | SET_LOG_TYPE |  SET_LOG_ID |</span><br><span class="line">        +---------------------+--------------+--------------+-------------+</span><br><span class="line">Length         1				   1			  1				2</span><br><span class="line"></span><br><span class="line">Answer (Copter to PC):</span><br><span class="line">        +---------------------+--------------+------------+</span><br><span class="line">        | CREATE_BLOCK_V2 (6) | LOG_BLOCK_ID | CREATE_STS |</span><br><span class="line">        +---------------------+--------------+------------+</span><br><span class="line">Length            1               1               1</span><br></pre></td></tr></table></figure>
<h5 id="append-block-v2">APPEND BLOCK V2</h5>
<p>V2版本的追加日志内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Request (PC to Copter):</span><br><span class="line">										  &lt; 更多设置参数按如下结构扩展      &gt;</span><br><span class="line">        +---------------------+--------------+--------------+-------------+</span><br><span class="line">        | APPEND_BLOCK_V2 (7) | LOG_BLOCK_ID | SET_LOG_TYPE |  SET_LOG_ID |</span><br><span class="line">        +---------------------+--------------+--------------+-------------+</span><br><span class="line">Length         1				   1			  1				2</span><br><span class="line"></span><br><span class="line">Answer (Copter to PC):</span><br><span class="line">        +---------------------+--------------+------------+</span><br><span class="line">        | APPEND_BLOCK_V2 (7) | LOG_BLOCK_ID | CREATE_STS |</span><br><span class="line">        +---------------------+--------------+------------+</span><br><span class="line">Length            1               1               1</span><br></pre></td></tr></table></figure>
<h4 id="log-data">Log data</h4>
<p>日志数据通道用于飞行器在可编程速率下发送日志块数据。</p>
<p>详细的请求内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Answer (Copter to PC):</span><br><span class="line">        +----------+------------+---------//----------+</span><br><span class="line">        | BLOCK_ID | TIME_STAMP | LOG VARIABLE VALUES |</span><br><span class="line">        +----------+------------+---------//----------+</span><br><span class="line">Length        1          3           0 to 28</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>应答字段</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>BLOCK_ID</td>
<td>日志块的ID</td>
</tr>
<tr class="even">
<td>1</td>
<td>TIME_STAMP</td>
<td>时标以ms形式，从飞行器启动起算起，并以3字节的小端整形表示</td>
</tr>
<tr class="odd">
<td>4-...</td>
<td>Log variable values</td>
<td>日志包的数据值以小端形式表述</td>
</tr>
</tbody>
</table>
<h3 id="localization端口说明">Localization端口说明</h3>
<p>该端口组有一系列定位相关的数据包，主要如下几个通道：</p>
<table>
<thead>
<tr class="header">
<th>端口</th>
<th>通道</th>
<th>命名</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>6</td>
<td>0</td>
<td>External Position</td>
<td>外部位置</td>
</tr>
<tr class="even">
<td>6</td>
<td>1</td>
<td>Generic localization</td>
<td>通用定位</td>
</tr>
<tr class="odd">
<td>6</td>
<td>2</td>
<td>External Position Packet</td>
<td>外部位置数据包</td>
</tr>
</tbody>
</table>
<h4 id="external-position">External Position</h4>
<p>该数据包被用来发送由外部系统获取的Crazyflie位置信息。主要用该数据包发送由运动捕获系统获取的位置信息，并通过扩展卡尔曼滤波，允许Crazyflie计算位置估计并控制其状态。</p>
<p>数据包形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CrtpExtPosition</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">float</span> x; <span class="comment">// in m</span></span><br><span class="line">  <span class="type">float</span> y; <span class="comment">// in m</span></span><br><span class="line">  <span class="type">float</span> z; <span class="comment">// in m</span></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<h4 id="generic-localization">Generic Localization</h4>
<p>该通道用于定位子系统有用的主机数据包，该数据包被创建用来服务于自身位置系统数据包，但可以被用作对更多通用系统像GPS NMEA编码或二进制数据流。数据包格式如下：</p>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>数值</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>PACKET_TYPE</td>
<td></td>
</tr>
<tr class="even">
<td>1-...</td>
<td>Payload</td>
<td>数据包的有效载荷，数据形式由包类型确定</td>
</tr>
</tbody>
</table>
<p>关于<strong>PACKET_TYPE</strong>定义：</p>
<table>
<thead>
<tr class="header">
<th>包类型</th>
<th>数值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>RANGE_STREAM_FLOAT</td>
<td>0</td>
<td>待确认</td>
</tr>
<tr class="even">
<td>RANGE_STREAM_FP16</td>
<td>1</td>
<td>待确认</td>
</tr>
<tr class="odd">
<td>LPS_SHORT_LPP_PACKET</td>
<td>2</td>
<td>LPS 发送 LPP数据包</td>
</tr>
<tr class="even">
<td>EMERGENCY_STOP</td>
<td>3</td>
<td>紧急停止</td>
</tr>
<tr class="odd">
<td>EMERGENCY_STOP_WATCHDOG</td>
<td>4</td>
<td>接收超时触发紧急停止</td>
</tr>
<tr class="even">
<td>COMM_GNSS_NMEA</td>
<td>6</td>
<td>待确认</td>
</tr>
<tr class="odd">
<td>COMM_GNSS_PROPRIETARY</td>
<td>7</td>
<td>待确认</td>
</tr>
<tr class="even">
<td>EXT_POSE</td>
<td>8</td>
<td>外部位置信息包</td>
</tr>
<tr class="odd">
<td>EXT_POSE_PACKED</td>
<td>9</td>
<td>外部位置信息压缩包</td>
</tr>
</tbody>
</table>
<blockquote>
<p>LPS:Loco Positioning System</p>
<p>LPP:Loco Positioning Protocol</p>
</blockquote>
<h5 id="lpp-short-packet-tunnel">LPP Short packet tunnel</h5>
<p>该数据用于发送LPP短包到本地位置系统，有效数据以<a href="https://www.bitcraze.io/docs/lps-node-firmware/master/lpp/">LPP Short Packet</a>的形式发送给系统。</p>
<h5 id="emergency-stop">Emergency stop</h5>
<p>当收到时，稳定循环系统被设置到紧急停止模式，该模式下停止所有电机。直到飞控状态复位，否则稳定循环模式一直保持在紧急停止状态。</p>
<h5 id="emergency_stop_watchdog">EMERGENCY_STOP_WATCHDOG</h5>
<p>飞控启动时<strong>超时紧急停止</strong>处于失效状态，当第一个数据包接收开始，超时1s就会使能<strong>超时紧急停止</strong>。该数据包至少每秒被<strong>Crazyflie</strong>发送和接收一次，否则稳定循环系统就会被设置进入紧急停止状态且所有电机停转。</p>
<h5 id="ext_pose">EXT_POSE</h5>
<p>外部系统的位置信息，详细结构如下：</p>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>字段</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>EXT_POSE</td>
<td>byte</td>
<td>外部位置 信息包</td>
</tr>
<tr class="even">
<td>1 - 4</td>
<td>x</td>
<td>float</td>
<td>x轴坐标信息</td>
</tr>
<tr class="odd">
<td>5 - 8</td>
<td>y</td>
<td>float</td>
<td>y轴坐标信息</td>
</tr>
<tr class="even">
<td>9 - 12</td>
<td>z</td>
<td>float</td>
<td>z轴坐标信息</td>
</tr>
<tr class="odd">
<td>13 - 16</td>
<td>qx</td>
<td>float</td>
<td>四元素姿态信息：方位信息的x轴分量</td>
</tr>
<tr class="even">
<td>17 - 20</td>
<td>qy</td>
<td>float</td>
<td>四元素姿态信息：方位信息的y轴分量</td>
</tr>
<tr class="odd">
<td>21 - 24</td>
<td>qz</td>
<td>float</td>
<td>四元素姿态信息：方位信息的z轴分量</td>
</tr>
<tr class="even">
<td>25 - 28</td>
<td>qw</td>
<td>float</td>
<td>四元素姿态信息：矢量大小系数</td>
</tr>
</tbody>
</table>
<h5 id="ext_pose_packed">EXT_POSE_PACKED</h5>
<p>外部位置系统的数据通过该数据包形式进行压缩发送，节省通道带宽，详细包形式如下：</p>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>字段</th>
<th>类型</th>
<th>系数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>EXT_POSE_PACKED</td>
<td>byte</td>
<td></td>
<td>外部位置信息压缩包</td>
</tr>
<tr class="even">
<td>1</td>
<td>id</td>
<td>uint8</td>
<td></td>
<td>Crazyflie飞控地址的最后8bit</td>
</tr>
<tr class="odd">
<td>2 - 3</td>
<td>x</td>
<td>int16</td>
<td>0.001</td>
<td>x轴坐标信息</td>
</tr>
<tr class="even">
<td>4 - 5</td>
<td>y</td>
<td>int16</td>
<td>0.001</td>
<td>y轴坐标信息</td>
</tr>
<tr class="odd">
<td>6 - 7</td>
<td>z</td>
<td>int16</td>
<td>0.001</td>
<td>z轴坐标信息</td>
</tr>
<tr class="even">
<td>8 - 11</td>
<td>quaternion</td>
<td>uint32_t</td>
<td></td>
<td>压缩格式的四元素(压缩算法详见<strong>quatcompress.h</strong>)</td>
</tr>
<tr class="odd">
<td>...</td>
<td></td>
<td></td>
<td></td>
<td>另一同样包形式的元素</td>
</tr>
</tbody>
</table>
<p>每个CRTP数据包可以达到两个外部位置信息元素。</p>
<h3 id="generic-setpoint端口说明">Generic Setpoint端口说明</h3>
<p>该端口允许发送设定点到飞行器平台。其理念在于能够为每个不同的用例定义设定点数据的包格式。因此这是一个拥有一个通道和一个主要包形式的通用端口。</p>
<table>
<thead>
<tr class="header">
<th>端口</th>
<th>通道</th>
<th>命名</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>7</td>
<td>0</td>
<td>通用设定点</td>
</tr>
</tbody>
</table>
<p>通用设定点包的形式如下：</p>
<table>
<thead>
<tr class="header">
<th>字节</th>
<th>数值</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>ID</td>
<td>设定点数据包类型的ID值</td>
</tr>
<tr class="even">
<td>1 - ...</td>
<td>Payload</td>
<td>数据形式由数据包类型确定</td>
</tr>
</tbody>
</table>
<p>详细的包类型如下：</p>
<table>
<thead>
<tr class="header">
<th>ID</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td><a href="#stop">stop</a></td>
</tr>
<tr class="even">
<td>1</td>
<td><a href="#velocity-world">Velocity World</a></td>
</tr>
<tr class="odd">
<td>2</td>
<td><a href="#z-distance">Z Distance</a></td>
</tr>
<tr class="even">
<td>3</td>
<td><a href="#cppm-emulation">CPPM Emulation</a></td>
</tr>
<tr class="odd">
<td>4</td>
<td><a href="#altitude-hold">Altitude Hold</a></td>
</tr>
<tr class="even">
<td>5</td>
<td><a href="#hover">Hover</a></td>
</tr>
<tr class="odd">
<td>6</td>
<td><a href="#full-state">Full State</a></td>
</tr>
<tr class="even">
<td>7</td>
<td><a href="#position">Position</a></td>
</tr>
</tbody>
</table>
<h4 id="stop">Stop</h4>
<p>这个设定点无有效负载，用于停止电机和失效控制循环。需要在Crazyflie飞控着陆的情况下发送。</p>
<h4 id="velocity-world">Velocity World</h4>
<p>世界坐标系中的速度设定点伴随着偏航角速度。适用于在本地位置系统的遥控模式。</p>
<p>有效载荷数据的形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">velocityPacket_s</span> &#123;</span></span><br><span class="line">  <span class="type">float</span> vx;        <span class="comment">// m in the world frame of reference</span></span><br><span class="line">  <span class="type">float</span> vy;        <span class="comment">// ...</span></span><br><span class="line">  <span class="type">float</span> vz;        <span class="comment">// ...</span></span><br><span class="line">  <span class="type">float</span> yawrate;  <span class="comment">// deg/s</span></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<h4 id="z-distance">Z Distance</h4>
<p>设置Crazyflie飞控绝对高度和俯仰/滚转角度，数据有效载荷形似如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zDistancePacket_s</span> &#123;</span></span><br><span class="line">  <span class="type">float</span> roll;            <span class="comment">// deg</span></span><br><span class="line">  <span class="type">float</span> pitch;           <span class="comment">// ...</span></span><br><span class="line">  <span class="type">float</span> yawrate;         <span class="comment">// deg/s</span></span><br><span class="line">  <span class="type">float</span> zDistance;        <span class="comment">// m in the world frame of reference</span></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<h4 id="cppm-emulation">CPPM Emulation</h4>
<p>CRTP数据包拥有一个<strong>CPPM</strong>(<code>Crazyflie Pulse Position Modulation</code>)仿真通道，该通道数据范围1000-2000，其中间值为1500，支持原始的<strong>RPYT</strong>(<code>Roll Pitch Yaw Thrust</code>)通道，再加上高达<strong>MAX_AUX_RC_CHANNELS</strong> 数量的辅组通道。辅组通道是可选的，并且除非给定通道被实际使用，发射器没必要传输所有的数据(<strong>numAuxChannels</strong>是设定依据)。</p>
<p>有效数据载荷形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_AUX_RC_CHANNELS 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> s_CppmEmuRollMaxRateDps = <span class="number">720.0f</span>; <span class="comment">// For rate mode</span></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> s_CppmEmuPitchMaxRateDps = <span class="number">720.0f</span>; <span class="comment">// For rate mode</span></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> s_CppmEmuRollMaxAngleDeg = <span class="number">50.0f</span>; <span class="comment">// For level mode</span></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> s_CppmEmuPitchMaxAngleDeg = <span class="number">50.0f</span>; <span class="comment">// For level mode</span></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> s_CppmEmuYawMaxRateDps = <span class="number">400.0f</span>; <span class="comment">// Used regardless of flight mode</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cppmEmuPacket_s</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="type">uint8_t</span> numAuxChannels : <span class="number">4</span>;   <span class="comment">// Set to 0 through MAX_AUX_RC_CHANNELS</span></span><br><span class="line">      <span class="type">uint8_t</span> reserved : <span class="number">4</span>;</span><br><span class="line">  &#125; hdr;</span><br><span class="line">  <span class="type">uint16_t</span> channelRoll;</span><br><span class="line">  <span class="type">uint16_t</span> channelPitch;</span><br><span class="line">  <span class="type">uint16_t</span> channelYaw;</span><br><span class="line">  <span class="type">uint16_t</span> channelThrust;</span><br><span class="line">  <span class="type">uint16_t</span> channelAux[MAX_AUX_RC_CHANNELS];</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<h4 id="altitude-hold">Altitude Hold</h4>
<p>设置Crazyflie飞控的垂直速度和滚转/俯仰角度。</p>
<p>数据有效载荷形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">altHoldPacket_s</span> &#123;</span></span><br><span class="line">  <span class="type">float</span> roll;            <span class="comment">// rad</span></span><br><span class="line">  <span class="type">float</span> pitch;           <span class="comment">// ...</span></span><br><span class="line">  <span class="type">float</span> yawrate;         <span class="comment">// deg/s</span></span><br><span class="line">  <span class="type">float</span> zVelocity;       <span class="comment">// m/s in the world frame of reference</span></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<h4 id="hover">Hover</h4>
<p>设置Crazyflie飞控绝对高度和在刚体坐标系下的速度。</p>
<p>数据有效载荷形似如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hoverPacket_s</span> &#123;</span></span><br><span class="line">  <span class="type">float</span> vx;           <span class="comment">// m/s in the body frame of reference</span></span><br><span class="line">  <span class="type">float</span> vy;           <span class="comment">// ...</span></span><br><span class="line">  <span class="type">float</span> yawrate;      <span class="comment">// deg/s</span></span><br><span class="line">  <span class="type">float</span> zDistance;    <span class="comment">// m in the world frame of reference</span></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<h4 id="full-state">Full State</h4>
<p>设置所有的控制状态。其数据有效载荷形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fullStatePacket_s</span> &#123;</span></span><br><span class="line">  <span class="type">int16_t</span> x;         <span class="comment">// position - mm</span></span><br><span class="line">  <span class="type">int16_t</span> y;</span><br><span class="line">  <span class="type">int16_t</span> z;</span><br><span class="line">  <span class="type">int16_t</span> vx;        <span class="comment">// velocity - mm / sec</span></span><br><span class="line">  <span class="type">int16_t</span> vy;</span><br><span class="line">  <span class="type">int16_t</span> vz;</span><br><span class="line">  <span class="type">int16_t</span> ax;        <span class="comment">// acceleration - mm / sec^2</span></span><br><span class="line">  <span class="type">int16_t</span> ay;</span><br><span class="line">  <span class="type">int16_t</span> az;</span><br><span class="line">  <span class="type">int32_t</span> quat;      <span class="comment">// compressed quaternion, see quatcompress.h</span></span><br><span class="line">  <span class="type">int16_t</span> rateRoll;  <span class="comment">// angular velocity - milliradians / sec</span></span><br><span class="line">  <span class="type">int16_t</span> ratePitch; <span class="comment">//  (<span class="doctag">NOTE:</span> limits to about 5 full circles per sec.</span></span><br><span class="line">  <span class="type">int16_t</span> rateYaw;   <span class="comment">//   may not be enough for extremely aggressive flight.)</span></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<h4 id="position">Position</h4>
<p>设置绝对位置和方向，其数据有效载荷形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">positionPacket_s</span> &#123;</span></span><br><span class="line">  <span class="type">float</span> x;     <span class="comment">// Position in m</span></span><br><span class="line">  <span class="type">float</span> y;</span><br><span class="line">  <span class="type">float</span> z;</span><br><span class="line">  <span class="type">float</span> yaw;   <span class="comment">// Orientation in degree</span></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<h2 id="连接步骤">连接步骤</h2>
<p><strong>CRTP</strong>被设计为无状态模式，所以不需要握手过程。任何命令可以在任何时候被发送，但是对于一些日记/参数/存储 命令，为了主机客户端能够发送正确的信息，内容表(<strong>TOC</strong>)需要被下载。为了能够使用所有的功能，在连接的情况下，执行Python API 将会下载 参数/日记/存储 TOC 。</p>
]]></content>
      <categories>
        <category>crazyflie</category>
      </categories>
      <tags>
        <tag>CRTP</tag>
        <tag>Crazy RealTime Protocol</tag>
      </tags>
  </entry>
  <entry>
    <title>crazyflie-开发说明</title>
    <url>/2020/01/22/crazyflie-%E5%BC%80%E5%8F%91%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>嵌入式软件开发主要包括编译(build)、调试(debug)和烧录(flash)三个步骤。本文结合crazefie项目，说明开发流程。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/hpJQSXx9corO15W.jpg" alt="上海科技馆-静物" /><figcaption aria-hidden="true">上海科技馆-静物</figcaption>
</figure>
<span id="more"></span>
<h2 id="准备源码">准备源码</h2>
<p>由于官方仓库中使用了<code>git submodule</code>，所以在克隆源码时需使用<code>--recursive</code>标志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recursive https://github.com/bitcraze/crazyflie-firmware.git</span><br></pre></td></tr></table></figure>
<p>如果已经克隆了仓库，但是没有添加<code>--recursive</code>选项，需要手动添加子模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> crazyflie-firmware</span><br><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br></pre></td></tr></table></figure>
<p>具体更新哪些子项目模块可以查看<code>.gitmodules</code>文件。 &gt; 注意： &gt; - 问题：如果编译时出现如下错误：<code>make[1]: *** No rule to make target 'libdw1000.o', needed by 'cf2.elf'.  Stop. &gt; Makefile:350: recipe for target 'build' failed</code> &gt; - 解决办法：上述错误原因是因为缺少<code>libdw1000</code>文件，输入<code>git submodule deinit</code>，并删除<code>libdw1000</code>目录里面的<code>.git</code>文件，重新拉取该项目源码。</p>
<h2 id="环境搭建">环境搭建</h2>
<p>官方提供三种环境搭建方式，分别使用虚拟机镜像<a href="https://github.com/bitcraze/bitcraze-vm">Crazyflie VM</a>、Docker镜像<a href="https://github.com/bitcraze/toolbelt">toolbelt</a>和本机安装相应的ARM工具链来搭建开发环境。</p>
<h3 id="虚拟机镜像">虚拟机镜像</h3>
<h4 id="概述-1">概述</h4>
<p>本文采用 VirtualBox 虚拟机软件，该软件属于自由软件，方便安装。</p>
<h4 id="virtualbox">VirtualBox</h4>
<ul>
<li>下载<a href="https://www.virtualbox.org/wiki/Downloads">VirtualBox</a></li>
<li>安装软件</li>
</ul>
<h4 id="下载bitcraze镜像">下载bitcraze镜像</h4>
<ul>
<li><a href="https://wiki.bitcraze.io/projects:virtualmachine:index">Bitcraze Virtual Machine Image</a></li>
</ul>
<h4 id="导入镜像">导入镜像</h4>
<figure>
<img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3pnaDU1MS9GaWd1cmVCZWQvbWFzdGVyL2ltZy8yMDIwMDExNzE1NTQyNC5wbmc?x-oss-process=image/format,png" alt="镜像导入过程" /><figcaption aria-hidden="true">镜像导入过程</figcaption>
</figure>
<h4 id="启动镜像">启动镜像</h4>
<figure>
<img data-src="https://i.loli.net/2021/08/30/BxSWetJvMy7R1uG.png" alt="启动镜像" /><figcaption aria-hidden="true">启动镜像</figcaption>
</figure>
<blockquote>
<p>注意：运行镜像时可能会出现如下问题 错误1：<code>Implementation of the USB 2.0 controller not found!</code> 安装<a href="https://www.virtualbox.org/wiki/Downloads">VirtualBox Extension Pack</a>即可解决 错误2：<code>VT-x is not available</code> 对于Win10电脑如果已经开启了Hyper-V，需将其服务关闭； 1、控制面板 --&gt; 程序和功能 --&gt; 启用或关闭windows功能 2、失效 <strong>H-yper-v</strong>、<strong>Windows 沙盒(Sandbox)</strong> 选项，使能 <strong>虚拟机平台</strong>、<strong>Windows虚拟机监控程序平台</strong>选项。 3、管理员打开 PowerShell客户端 4、输入<code>bcdedit /set hypervisorlaunchtype off</code> 5、重启电脑</p>
</blockquote>
<h3 id="docker镜像方式">Docker镜像方式</h3>
<h4 id="安装docker">安装Docker</h4>
<ol type="1">
<li><a href="https://docs.docker.com/docker-for-windows/install/">Docker Hub下载</a></li>
<li>双击安装文件，一直Next。</li>
<li>注册Docker账号</li>
</ol>
<h4 id="下载docker镜像">下载Docker镜像</h4>
<ul>
<li>关于<a href="https://hub.docker.com/r/bitcraze/builder">bitcraze/builder镜像</a></li>
<li>打开PowerShell客户端</li>
<li>拉取远程镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull bitcraze/builder</span><br></pre></td></tr></table></figure>
<p>下载过程如下所示，由于文件较大可能需要一段时间。</p>
<p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3pnaDU1MS9GaWd1cmVCZWQvbWFzdGVyL2ltZy8yMDIwMDExNzE2NTYzMC5naWY" /></p>
<h4 id="进入交互模式">进入交互模式</h4>
<ul>
<li>查看镜像是否下载成功</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<ul>
<li>进入项目目录</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ./crazyflie-firmware</span><br></pre></td></tr></table></figure>
<ul>
<li>进入交互式环境</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> -it -v <span class="variable">$&#123;PWD&#125;</span>:/module bitcraze/builder bash</span><br></pre></td></tr></table></figure>
<p>该命令用法参考<a href="https://blog.csdn.net/zghforever/article/details/100087437">Docker 常用命令</a></p>
<h3 id="本地工具链配置">本地工具链配置</h3>
<p>待补充</p>
<h2 id="编译">编译</h2>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">命令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>all</strong></td>
<td>快捷编译方式，所有文件都编译</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>compile</strong></td>
<td>编译生成 cflie.hex文件，但不更新version.c文件</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>build</strong></td>
<td>更新 version.c 文件并编译生成 cflie.elf/hex文件</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>clean_o</strong></td>
<td>只清除目标文件，保留执行文件(.elf,.hex)</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>clean</strong></td>
<td>清除所有的编译文件</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>mrproper</strong></td>
<td>清除每一个编译文件和典型的编辑器备份文件</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>cload</strong></td>
<td>如果crazyflie-clients-python与项目文件在同级目录并且Crazyradio/Crazyradio PA被插入电脑，该命令将会尝试通过无线bootloader烧写固件</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>flash</strong></td>
<td>使用 OpenOCD烧录.elf 文件</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>halt</strong></td>
<td>使用 OpenOCD 暂停目标芯片</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>reset</strong></td>
<td>使用 OpenOCD 复位目标芯片</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>openocd</strong></td>
<td>启动 OpenOCD</td>
</tr>
</tbody>
</table>
<h2 id="调试">调试</h2>
<p>关于芯片功能的调试，使用开源工具OpenOCD。</p>
<h3 id="ubuntu">Ubuntu</h3>
<blockquote>
<p><strong><em>Versions:</em></strong></p>
<ul>
<li>Ubuntu 18.04.2 LTS (64 bit)</li>
<li>Eclipse 2019-03 (Eclipse IDE for C/C++ Developers)</li>
</ul>
</blockquote>
<h4 id="安装依赖">安装依赖</h4>
<ul>
<li>安装<strong>GDB</strong>和<strong>openocd</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install gdb</span><br><span class="line">sudo apt-get install openocd</span><br></pre></td></tr></table></figure>
<ul>
<li>安装java运行环境</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install default-jre</span><br></pre></td></tr></table></figure>
<ul>
<li>安装eclipse</li>
</ul>
<p>进入<a href="https://www.eclipse.org/downloads/download.php?file=/oomph/epp/2019-12/R/eclipse-inst-win64.exe">eclipse 下载页</a>下载文件目录，并解压文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf <span class="string">&quot;your-downloaded-file&quot;</span>.tar.gz</span><br></pre></td></tr></table></figure>
<ul>
<li>开始eclipse安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;your-unzip-folder&quot;</span>/.eclipse_inst</span><br></pre></td></tr></table></figure>
<h2 id="下载">下载</h2>
]]></content>
      <categories>
        <category>crazyflie</category>
      </categories>
      <tags>
        <tag>crazyflie</tag>
        <tag>开发说明</tag>
      </tags>
  </entry>
  <entry>
    <title>crazyflie-目录分析</title>
    <url>/2020/01/22/crazyflie-%E7%9B%AE%E5%BD%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>本文主要分析<strong>crazyflie</strong>项目的目录结构，并对主要目录作了简要说明。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/5WUADE8QVGmFRcT.jpg" alt="重庆" /><figcaption aria-hidden="true">重庆</figcaption>
</figure>
<span id="more"></span>
<h2 id="目录结构">目录结构</h2>
<p>下图所示是飞控项目的目录结构，项目中的包含文档说明、代码测试、项目所需的开源项目、飞控源码、编译工具和输出文件等。</p>
<p><img data-src="https://i.loli.net/2021/08/30/Ndk897wgDTzBcJR.png" /></p>
<h3 id="doc">[doc]</h3>
<p>该目录包含项目相关的说明文档，主要说明项目编译方式、CRTP包说明、扩展板开发说明等。</p>
<h3 id="blobs">[blobs]</h3>
<p>该目录包含灯塔固件。</p>
<h3 id="generated-test">[generated-test]</h3>
<p>该目录包含产生测试文件的脚本，但是从仓库拉取下来是空的。</p>
<h3 id="test">[test]</h3>
<p>该目录包含各个模块的测试用例文件。</p>
<h3 id="vender">[vender]</h3>
<p>该目录包含项目所依赖的其它项目文件，包括测试工具、实时操作系统和开源定位库等； - <strong>cmock</strong>：用于项目的mock测试； - <strong>unity</strong>：用于项目的单元测试； - <strong>CMSIS</strong>：用于实现Cortex-M 系列处理器与供应商无关的硬件抽象层； - <strong>FreeRTOS</strong>：用于实现系统的任务调度和消息管理； - <strong>libdw1000</strong>：用于驱动dw1000芯片，实现室内定位功能。</p>
<h3 id="src">[src]</h3>
<p>该目录包含飞控相关的源文件，具体说明如下： - <strong>drivers</strong>：目录包含实现硬件底层驱动的文件，实现主控芯片外设驱动和外部芯片驱动的开发； - <strong>hal</strong>：目录包含对硬件抽象的功能文件，将系统的某些硬件抽象成功能模块； - <strong>modules</strong>：目录包含所有的功能模块，包括CRTP通信模块、姿态估计模块、位置控制模块、姿态稳定控制模块和传感器融合模块等； - <strong>lib</strong>：目录包含供应商相关标准开发库、文件系统库等； - <strong>utils</strong>：目录包含可以公用的实用程序，如CRC校验、滤波等； - <strong>platform</strong>：目录包含平台配置的相关文件； - <strong>deck</strong>：目录包含扩展板接口文件； - <strong>config</strong>：目录包含系统配置相关文件； - <strong>init</strong>：目录包含主函数文件；</p>
<h3 id="tool">[tool]</h3>
<p>该目录包含编译源文件相关的脚本；</p>
<h3 id="bin">[bin]</h3>
<p>该目录包含编译生成的输出文件；</p>
]]></content>
      <categories>
        <category>crazyflie</category>
      </categories>
      <tags>
        <tag>crazyflie</tag>
        <tag>目录分析</tag>
      </tags>
  </entry>
  <entry>
    <title>crazyflie-硬件分析</title>
    <url>/2020/02/29/crazyflie-%E7%A1%AC%E4%BB%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>本文主要对crazyflie飞控硬件原理图设计进行简单的分析，包括电路原理、参数选型和PCB设计等。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/7zyoK5FNvTxCY8I.jpg" alt="青岛啤酒" /><figcaption aria-hidden="true">青岛啤酒</figcaption>
</figure>
<span id="more"></span>
<h2 id="原理图分析">原理图分析</h2>
<h3 id="微处理器单元">微处理器单元</h3>
<h4 id="选型">选型</h4>
<p>关于主控芯片的选型采用<a href="https://www.st.com/content/st_com/en/products/microcontrollers-microprocessors/stm32-32-bit-arm-cortex-mcus/stm32-high-performance-mcus/stm32f4-series.html"><strong>ST</strong></a>公司F4系列处理器,该系列处理器主要有三个产线，分别为进阶产线、基础产线和入门产线。基于性能和成本考虑，飞控设计选用基础产线系类，该系类主控拥有210 <strong>DMIPS</strong>，与进阶产线的225 <strong>DMIPS</strong>差距不大。由于摄像头接口外设并不需要，所以选择最基本的<strong>STM32F405</strong>系列主控就可以满足性能要求。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/mco3YEdsp4qAfJ5.jpg" alt="产品对比图" /><figcaption aria-hidden="true">产品对比图</figcaption>
</figure>
<p>由于迷你四轴对引脚需求较少，可以选择下图64引脚的RG系列封装。</p>
<p><img data-src="https://i.loli.net/2021/08/30/7ztr64V1gkHPG9B.jpg" /></p>
<p>芯片外设如下：</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/N6ZWCRBPi7JhQ92.jpg" alt="外设" /><figcaption aria-hidden="true">外设</figcaption>
</figure>
<p>飞控中主要用到的通信外设包括IIC、SPI、USART和USB，控制相关外设包括PWM。</p>
<h4 id="芯片供电分析">芯片供电分析</h4>
<h4 id="复位电路">复位电路</h4>
<h4 id="晶振">晶振</h4>
<h4 id="boot模式">Boot模式</h4>
<h3 id="传感器单元">传感器单元</h3>
<h4 id="惯性测量单元imu">惯性测量单元(IMU)</h4>
<ul>
<li><strong>Gyroscope</strong>(陀螺仪)</li>
</ul>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>BMI088</th>
<th>ICM20602</th>
<th>单位</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>TCO</strong>(零速率偏移随温度的变化)</td>
<td>15</td>
<td>10</td>
<td>mdps/K</td>
</tr>
<tr class="even">
<td><strong>TCS</strong>(零敏度随温度的变化)</td>
<td>0.03</td>
<td>2</td>
<td>%/K</td>
</tr>
<tr class="odd">
<td>零速率偏置</td>
<td>1</td>
<td>1</td>
<td>dps</td>
</tr>
<tr class="even">
<td>输出噪声</td>
<td>0.1</td>
<td>0.04</td>
<td>dps</td>
</tr>
<tr class="odd">
<td>偏差稳定性</td>
<td>&lt; 2</td>
<td></td>
<td>°/h</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>Accelerometer</strong>(加速度计)</li>
</ul>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>BMI088</th>
<th>ICM20602</th>
<th>单位</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>TCO</strong>(零速率偏移随温度的变化)</td>
<td>0.2</td>
<td>xy:0.5 z:1</td>
<td>mg/k</td>
</tr>
<tr class="even">
<td><strong>TCS</strong>(零敏度随温度的变化)</td>
<td>0.002</td>
<td>1.5</td>
<td>%/K</td>
</tr>
<tr class="odd">
<td>零重力偏置</td>
<td>20</td>
<td>25-40</td>
<td>mg</td>
</tr>
<tr class="even">
<td>噪声频谱密度</td>
<td>z:190;x,y:160</td>
<td>100</td>
<td>ug/Hz</td>
</tr>
<tr class="odd">
<td>输出噪声</td>
<td>2.4</td>
<td>1.0</td>
<td>mg</td>
</tr>
<tr class="even">
<td>非线性度</td>
<td>0.5</td>
<td>0.3</td>
<td>%FS</td>
</tr>
<tr class="odd">
<td>跨轴灵敏度(<strong>Cross-Axis Sensitivity</strong>)</td>
<td>0.5</td>
<td>1</td>
<td>%</td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li>非线性度：理想情况下，电压与加速度之间是线性关系，用器件的灵敏度来描述。 非线性度衡量实际灵敏度与理想的恒定灵敏度之间的偏差，用相对于满量程范围(%FSR)或正负满量程(%FS)的百分比来表示。 通常，FSR = FS+FS。 ADI加速度计的非线性度非常低，绝大多数情况下可忽略不计。</li>
<li>跨轴灵敏度:衡量对某一轴施加一个加速度时，在另一轴上产生多大的输出，通常表示为百分比。 两个轴之间的耦合是由对齐误差、蚀刻不精确性和电路串扰共同造成。</li>
</ul>
</blockquote>
<h4 id="高度测量单元">高度测量单元</h4>
<ul>
<li>气压计</li>
</ul>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>BMP388</th>
<th>ICP101</th>
<th>单位</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Relative Accuracy</strong>(相对精度)</td>
<td>8</td>
<td>3</td>
<td>Pa</td>
</tr>
<tr class="even">
<td><strong>Absolute Accuracy</strong>(绝对精度)</td>
<td>50</td>
<td>100</td>
<td>Pa</td>
</tr>
<tr class="odd">
<td><strong>TCO</strong>(温度偏移系数)</td>
<td>0.75</td>
<td>0.5</td>
<td>Pa/k</td>
</tr>
<tr class="even">
<td><strong>Resolution</strong>(解析度)</td>
<td>0.016</td>
<td>0.01</td>
<td>Pa</td>
</tr>
</tbody>
</table>
<h3 id="电机驱动单元">电机驱动单元</h3>
<p>由于mini四轴一般采用空心杯电机，驱动电路相对简单。方案设计中选用简单的<strong>MOS</strong>电路驱动，具体形式如下：</p>
<p><img data-src="https://i.loli.net/2021/08/30/njYsXcdS4FPWaGN.png" /></p>
<p>由上图可知，选用<strong>NMOS</strong>搭建驱动电路，参考<code>CJ2302</code>数据手册知，<span class="math inline">\(V_{gs}\)</span>阀值为<span class="math inline">\(0.95V\)</span>，<span class="math inline">\(GS\)</span>驱动电流<span class="math inline">\(I_{gss}=\pm100nA\)</span>。所以选取电阻<span class="math inline">\(R1\)</span>和<span class="math inline">\(R2\)</span>参数时，为了减小<span class="math inline">\(DS\)</span>端的导通电阻，需要保证<span class="math inline">\(V_{gs}\)</span>尽可能大。</p>
<p>为了满足驱动电流<span class="math inline">\(I_{gss}\)</span>的需求，电阻<span class="math inline">\(R1\)</span>需要足够小，几欧姆的数量级即可。电阻<span class="math inline">\(R1\)</span> 如果选取太小数值，又会增大导通过程产生的振铃，太大可能会不满足瞬间驱动电流，无法导通。</p>
<p>图中二极管<span class="math inline">\(D1\)</span>用于续流二极管，当<strong>NMOS</strong>管关闭时，电机内部可以等效为一个电感，与二极管<span class="math inline">\(D1\)</span>组成一个放电回路，释放电机停止过程中的电流，避免对MOS管的损坏。</p>
<h3 id="无线通信单元">无线通信单元</h3>
<p><img data-src="https://i.loli.net/2021/08/30/TPBn7pdRXvlcO5f.png" /></p>
<p>如上图所示，51与52系列的主要功能对比，对于mini飞控来说，51系列芯片性能已经足够使用。目前由于对车规级认证无要求，且无需ANT协议，所以选取<strong>nRF51</strong>系列无线芯片中的<strong>nRF51822</strong> SoC。</p>
<p>设计中采用<strong>RFX2411N</strong>收发一体的驱动器。</p>
<h3 id="电源管理单元">电源管理单元</h3>
<h4 id="电池管理芯片">电池管理芯片</h4>
<p>设计中选用电池管理芯片<strong>BQ24075</strong>，充电电流1.5A，支持一个电池。</p>
<h4 id="线性电源">线性电源</h4>
<p>无线通信模块采用<strong>NCP702SN30</strong>线性电源芯片单独供电，传感器模块采用<strong>LP2985</strong>线性电源芯片单独供电。</p>
]]></content>
      <categories>
        <category>crazyflie</category>
        <category>硬件设计</category>
      </categories>
      <tags>
        <tag>crazyflie</tag>
        <tag>硬件设计</tag>
        <tag>Hardware</tag>
      </tags>
  </entry>
  <entry>
    <title>路径规划-AStar</title>
    <url>/2020/04/15/%E5%9F%BA%E4%BA%8E%E5%9B%BE%E6%90%9C%E7%B4%A2-AStar/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>A*算法是一种基于图搜索的路径搜索算法,通过结合移动代价和启发代价,优化路径的搜索性能. <img data-src="https://i.loli.net/2021/08/30/kMIZKgcV7PnNQEC.jpg" alt="青岛" /> <span id="more"></span></p>
<h2 id="算法描述">算法描述</h2>
<h3 id="确定规划的起点和终点">确定规划的起点和终点</h3>
<p>下图所示,红色方块代表规划<strong>起始点</strong>,绿色方块代表<strong>终点</strong>,深灰色方块代表<strong>障碍物</strong>区域,其余白色方块代表可行驶区域(free space).首先将起始点节点推送到open集合中.</p>
<p><img data-src="https://i.loli.net/2021/08/30/3agpvPEB89XTLK4.png" alt="原始地图给定起始点和终点" style="zoom:50%;" /></p>
<h3 id="产生临近节点">产生临近节点</h3>
<p>每次从open集合中取出<strong>总代价值</strong>最小的节点,由于当前open集合中只有起始节点,所以此时从open集合中取出的就是起始节点,并将该节点推入close集合.</p>
<p>如下图所示,基于起始节点生成相邻节点,并计算每个节点的代价值.其中<strong>A</strong>*节点的代价值由<strong>移动代价</strong>和<strong>启发代价</strong>组成,即<span class="math inline">\(F = G + H\)</span>.</p>
<p>本例中,采用如下距离计算代价值:</p>
<ul>
<li><strong>移动代价</strong> 采用欧拉距离计算移动代价值</li>
<li><strong>启动代价</strong> 采用曼哈顿距离计算启发代价值</li>
</ul>
<p><img data-src="https://i.loli.net/2021/08/30/6sE9MRizIfejx4H.png" alt="临近节点产生" style="zoom:50%;" /></p>
<h4 id="图例说明">图例说明</h4>
<p>下图是对上图中每个节点中小方格的说明:</p>
<ul>
<li><strong>左下角</strong>的方格代表移动代价</li>
<li><strong>右下角</strong>的方格代表启发代价</li>
<li><strong>最上方</strong>的矩形方格代表总的代价值</li>
<li><strong>中间</strong>的紫色方格代表父节点的方向</li>
</ul>
<p><img data-src="https://i.loli.net/2021/08/30/dk7cMlj1O5ACWNZ.png" style="zoom: 80%;" /></p>
<h3 id="节点选择">节点选择</h3>
<p>A*算法下一节点的选择,是从open集合中选取总代价值最小的节点.如下图所示,位于起始点右侧的节点代价值最小,图中使用浅绿色蒙板覆盖该节点表示选中.</p>
<p><img data-src="https://i.loli.net/2021/08/30/yaH7igL1RWFxMEI.png" alt="选择价值最低节点" style="zoom:80%;" /></p>
<h3 id="节点扩展">节点扩展</h3>
<p>基于选中的节点,根据扩展规则,生成新的临近节点,计算临近节点时只需要计算<strong>移动代价</strong>.</p>
<p>如下图中的右侧所示,对于新生成的8个节点需要做如下条件判断:</p>
<ul>
<li><p>是否在<strong>close</strong>集合中:</p>
<p>如果该节点在close集合中,直接跳过该节点,进行下一节点的判断</p></li>
<li><p>是否<strong>碰撞</strong>:</p>
<p>若该节点与障碍物存在碰撞可能,则跳过该节点,进行下一节点的判断;</p></li>
<li><p>是否在<strong>open</strong>集合中:</p>
<ol type="1">
<li><p>如果该节点==在==open集合中,需要判断该节点的移动代价是否小于原先位置节点的移动代价:</p>
<p>如果小于,则替换原先节点,并将节点的父节点方向指向当前节点,否则跳过该节点,进行下一节点的判断.</p></li>
<li><p>如果该节点==不在==open集合,则直接将其加入open集合.</p></li>
</ol></li>
</ul>
<p>如下图所示,当前节点的左侧的节点已经在close集合中,直接跳过该节点;当前节点左上角,左下角,上方和下方的节点已经在open集合中,所以需要比较新节点与open集合中节点的移动代价.通过比较,这四个新节点的移动代价大于相应open集合中节点的移动代价,所以跳过这些节点;当前节点右侧三个新节点都不在open集合中,所以直接将它们推入open集合.</p>
<p><img data-src="https://i.loli.net/2021/08/30/zdJIXQBpYuF7OAZ.png" style="zoom: 67%;" /></p>
<p>基于扩展规则,不断推出总代价值最小的节点,并扩展这些节点.下图中,当前节点右侧三个新节点与障碍存在碰撞,所以直接跳过.</p>
<p><img data-src="https://i.loli.net/2021/08/30/pqgZ2vl5XixR4mU.png" style="zoom: 67%;" /></p>
<p>如下图所示,如果存在总代价相等的情况,则先推出最新推入的节点.下图中,假设右下方总代价值为64的节点是新推进open集合的节点.</p>
<p><img data-src="https://i.loli.net/2021/08/30/JENcBzb1UmMZYLX.png" style="zoom:67%;" /></p>
<p>如下图所示,继续推出新的节点,并迭代更新.</p>
<p><img data-src="https://i.loli.net/2021/08/30/v4cL526HZYWtbXh.png" style="zoom:67%;" /></p>
<p>如下图所示,新的节点有的与障碍物存在碰撞,有的已经在close集合中,有的移动代价大于原先的节点;但当前节点下方的节点,其移动代价小于open集中对应节点的代价,所以需替换open集合中该节点的移动代价,并将其父节点指向当前节点.</p>
<p><img data-src="https://i.loli.net/2021/08/30/pBPmRbjvfouhLzq.png" style="zoom:67%;" /></p>
<h3 id="迭代">迭代</h3>
<p>如下图所示,直到从open集合中推出的节点是终点,表明搜索结束.浅绿色蒙板包含的区域属于close集合,其它搜索过的节点属于open集合.如果遍历所有open集合的节点都无法到达终点,则搜索失败.</p>
<p><img data-src="https://i.loli.net/2020/10/31/w3grmTFfHltY24U.png" alt="搜索完成" style="zoom: 67%;" /></p>
<h3 id="获取路径">获取路径</h3>
<p>如下图所示,搜索结束后,以终点为起始节点,根据节点所指向的父节点,反向更新搜索路径,直到节点的父节点指向为空,即到达起始点.</p>
<p><img data-src="https://i.loli.net/2020/10/31/Eqa4sbG6jgUnXVI.png" alt="搜索结果" style="zoom: 67%;" /></p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html">Introduction to the A* Algorithm</a></li>
<li><a href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#algorithm">Implementation of A*</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/161660932">路径规划中的Hybrid A*算法</a></li>
</ul>
]]></content>
      <categories>
        <category>规划算法</category>
        <category>图搜索算法</category>
      </categories>
      <tags>
        <tag>路径规划</tag>
        <tag>A Star</tag>
        <tag>A*</tag>
      </tags>
  </entry>
  <entry>
    <title>传感器融合-路面坡度计算</title>
    <url>/2020/09/17/%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88-%E8%B7%AF%E9%9D%A2%E5%9D%A1%E5%BA%A6%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>本文主要介绍一种计算车辆坡度角的方法，利用有限的两轴加速度传感器并结合车辆动力学特性，实时估算车辆的坡度角。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/wI6rcvWo2CzU9Fe.jpg" alt="青岛" /><figcaption aria-hidden="true">青岛</figcaption>
</figure>
<span id="more"></span>
<h2 id="融合框架">融合框架</h2>
<p><img data-src="https://i.loli.net/2021/08/30/Y6Z5RjPhEUwvuDQ.png" style="zoom: 80%;" /></p>
<h2 id="基于加速度偏差坡度估计">基于加速度偏差坡度估计</h2>
<h3 id="车辆坐标系定义">车辆坐标系定义</h3>
<p>车辆坐标下定义如下：</p>
<p><img data-src="https://i.loli.net/2021/08/30/otAnhJlSK4IDqbG.png" alt="车辆坐标系" style="zoom:80%;" /></p>
<p>沿车辆中轴线确定<span class="math inline">\(x\)</span>轴，车头方向为正方向; <span class="math inline">\(x\)</span>轴与后轴的交点为原点<span class="math inline">\(o\)</span>，过点<span class="math inline">\(o\)</span>作一条直线与<span class="math inline">\(x\)</span>轴垂直，将该直线定义为<span class="math inline">\(y\)</span>轴，沿<span class="math inline">\(x\)</span>轴逆时针方向为正。</p>
<h3 id="加速度计定义">加速度计定义</h3>
<p><img data-src="https://i.loli.net/2021/08/30/4mD37ckXrAefagQ.png" alt="加速度计" style="zoom:80%;" /></p>
<p>一般车辆加速度计的安装与车辆坐标系一致，车辆前进时，加速前进，传感测量值为<strong>正</strong>；减速前进，传感器测量值为<strong>负</strong>。车辆后退时，加速后退，传感器输出值为<strong>负</strong>；减速后退，传感器输出值为<strong>正</strong>。</p>
<p>同理，如果车辆前进上坡，静止在坡道上，传感器输出信号为<strong>正</strong>值；车辆前进下坡，静止在坡道上，传感器输出信号为<strong>负</strong>值。</p>
<h3 id="计算坡度值">计算坡度值</h3>
<h4 id="上坡静止状态">上坡静止状态</h4>
<p><img data-src="https://i.loli.net/2021/08/30/WVomupz7c63rIOh.png" style="zoom: 80%;" /></p>
<p>如上图所示，车辆上坡阶段，静止于坡道上时，加速度传感器在<span class="math inline">\(x\)</span>轴上存在重力分量，可以表示为 <span class="math display">\[
a_x = g\sin(\theta) \tag{1}
\]</span></p>
<h4 id="下坡静止状态">下坡静止状态</h4>
<p><img data-src="https://i.loli.net/2021/08/30/hSejlLFqodQRECI.png" style="zoom: 80%;" /></p>
<p>如上图所示，车辆下坡阶段，静止于坡道上时，加速度传感器在<span class="math inline">\(x\)</span>轴上存在重力分量，可以表示为 <span class="math display">\[
a_x=g\sin(\pi -\theta)=g\sin(-\theta) \tag{2}
\]</span></p>
<h4 id="车辆加速度">车辆加速度</h4>
<p><img data-src="https://i.loli.net/2021/08/30/afgl2rYhUwP5964.png" style="zoom: 80%;" /></p>
<p>如上图所示，通过采集相邻时刻<span class="math inline">\(k-1\)</span>和<span class="math inline">\(k\)</span>的纵向速度，计算车辆<span class="math inline">\(k-1\)</span>时刻的加速度为 <span class="math display">\[
\dot{v}_x(k-1) = \frac{v(k) - v(k-1)}{\Delta T} \tag{3}
\]</span> 其中，<span class="math inline">\(\Delta T\)</span>为采样步长，<span class="math inline">\(v(k)\)</span>定义前进为正，后退为负。</p>
<h4 id="坡度角计算">坡度角计算</h4>
<p>基于车辆在坡道上的受力分析，可以推算出当车辆运动时，加速度传感器输出信号<span class="math inline">\(a_x\)</span>与坡度角<span class="math inline">\(\theta\)</span>的关系如下： <span class="math display">\[
a_x = \dot{v}_x + g\sin(\theta) \tag{4}
\]</span> 所以坡度角可以表示如下： <span class="math display">\[
\theta = \arcsin(\frac{a_x - \dot{v}_x}{g}) \tag{5}
\]</span></p>
<h2 id="基于纵向动力学坡度计算">基于纵向动力学坡度计算</h2>
<h3 id="车辆纵向动力学模型">车辆纵向动力学模型</h3>
<p><img data-src="https://i.loli.net/2021/08/30/U8Ae7RSxg6OhcYv.png" style="zoom:80%;" /></p>
<p>如上图所示，车辆纵向方向主要受到发动机产生的牵引力<span class="math inline">\(F_x\)</span>的影响，同时也受到重力分量、迎风阻力和地面摩擦力的影响。通过对车辆对上述力的分析，车辆的动力学模型可以表示如下：</p>
<p><span class="math display">\[
F_x - mg\sin(\theta) - fmg\cos(\theta) - \frac{1}{2}\rho C_dAv_x^2 = m\dot{v}_x\tag{6}
\]</span></p>
<p>其中，<span class="math inline">\(m\)</span>为车辆质量，<span class="math inline">\(\rho\)</span>为空气密度，<span class="math inline">\(C_d\)</span>为风阻系数，<span class="math inline">\(A\)</span>为迎风面积，<span class="math inline">\(g\)</span>为重力加速度，<span class="math inline">\(\theta\)</span>为路面坡度，<span class="math inline">\(f\)</span>为路面滚阻系数。上述等式(6)中，路面坡度<span class="math inline">\(\theta\)</span>为待求参数，其它参数对于某一车辆来说均可以认为是已知的或者通过测量能够得到。</p>
<p>令 <span class="math inline">\(y = F_x\)</span>，<span class="math inline">\(u = m\dot{v}_x + \frac{1}{2}\rho C_dAv_x^2\)</span>，<span class="math inline">\(b = mg(\sin(\theta) + f\cos(\theta))\)</span>，将公式(6)简化为：</p>
<p><span class="math display">\[
y = u + b \tag{7}
\]</span></p>
<p>上式中，<span class="math inline">\(y\)</span>、<span class="math inline">\(u\)</span>为已知量，<span class="math inline">\(b\)</span>为未知量，由于<span class="math inline">\(b\)</span>是参数<span class="math inline">\(\theta\)</span>的函数，因此对路面坡度的估计可以通过估算<span class="math inline">\(\hat{b}\)</span>的值求得。</p>
<h3 id="参数估计">参数估计</h3>
<p>采用带有遗忘因子的最小二乘法估计<span class="math inline">\(b\)</span>的值，假设代价函数为<span class="math inline">\(V(\hat{b},k)\)</span>，那么采用最小二乘法估计<span class="math inline">\(b\)</span>的值，相当于求解参数<span class="math inline">\(\hat{b}\)</span>，使得函数<span class="math inline">\(V(\hat{b},k)\)</span>在某一时刻<span class="math inline">\(k\)</span>取得最小值。</p>
<p><span class="math display">\[
V(\hat{b},k) = \frac{1}{2}\sum_{i=1}^{k} \lambda^{k-i}(y_i - u_i - \hat{b}_k)^2 \tag{8}
\]</span></p>
<p>其中，<span class="math inline">\(\lambda\)</span>为遗忘因子，<span class="math inline">\(k\)</span>为采样时刻。</p>
<p>函数极小值的计算可以通过求解函数导数为0的参数，及</p>
<p><span class="math display">\[
\frac{\partial V}{\partial \hat{b}_k} = 0 \tag{9}
\]</span></p>
<p>结合等式(8)、(9)得</p>
<p><span class="math display">\[
\sum_{i=1}^{k}\lambda^{k-i}(y_i - u_i - \hat{b}_k)=0\tag{10}
\]</span></p>
<p>对等式(10)化简得</p>
<p><span class="math display">\[
\sum_{i=1}^{k}\lambda^{k-i}(y_i-u_i) - \sum_{i=1}^{k}\lambda^{k-i}\hat{b}_k=0 \tag{11}
\]</span></p>
<p>移项得</p>
<p><span class="math display">\[
\hat{b}_k \sum_{i=1}^{k}\lambda^{k-i} =\sum_{i=1}^{k}\lambda^{k-i}(y_i-u_i) \tag{12}
\]</span></p>
<p>基于等式(12)，提取<span class="math inline">\(\hat{b}_k\)</span>得</p>
<p><span class="math display">\[
\hat{b}_k = (\sum_{i=1}^{k}\lambda^{k-i})^{-1}\bigl(\sum_{i=1}^{k}\lambda^{k-i}(y_i-u_i)\bigr) \tag{13}
\]</span></p>
<p>从等式(13)可以看出，随着采样时刻<span class="math inline">\(k\)</span>不断增加，估计值<span class="math inline">\(\hat{b}\)</span>的计算量也不断增加。由于车辆行驶过程中的路面坡度估计需要实时计算，因此在实际应用中一般采用递推最小二乘估计来实时估计每一采样时刻<span class="math inline">\(b\)</span>的估计值<span class="math inline">\(\hat{b}\)</span>。</p>
<p><span class="math display">\[
\hat{b}_k = \hat{b}_{k-1} + L_k(y_k -u_k)\tag{14}
\]</span></p>
<p>增益系数<span class="math inline">\(L_k\)</span>为</p>
<p><span class="math display">\[
L_k = \frac{P_{k-1}}{\lambda + P_{k-1}} \tag{15}
\]</span></p>
<p>误差协方差<span class="math inline">\(P_k\)</span>为</p>
<p><span class="math display">\[
P_k = \frac{1}{\lambda}(1 - L_k)P_{k-1} \tag{16}
\]</span></p>
<p>根据公式(14)、(15)、(16)的更新过程</p>
<p><span class="math display">\[
D = \frac{\hat{b}}{mg} \tag{17}
\]</span></p>
<p>坡度角为</p>
<p><span class="math display">\[
\theta = \arcsin(\frac{D-f\sqrt{1-D^2 + f^2}}{1 + f^2}) \tag{18}
\]</span></p>
<h2 id="坡度角融合">坡度角融合</h2>
<p>车辆行驶过程中路面坡度<span class="math inline">\(\theta\)</span>可以认为是高频信号和低频信号两部分组成，在对路面坡度进行估计时，基于纵向动力学估计方法依赖于车辆的多个参数，车辆的各个参数受高频噪声影响大；基于加速度偏差坡度估计的缺点是受惯性传感器的静态偏差影响较大，惯性传感器的静态偏差属于低频噪声，为了保证路面坡度估算结果的准确性，对<span class="math inline">\(\theta_1\)</span>采用低通滤波器除去其高频部分，对<span class="math inline">\(\theta_2\)</span>采用高通滤波器滤除其低频部分，最终得到更加准确的实时估计值<span class="math inline">\(\hat{\theta}\)</span>为：</p>
<p><span class="math display">\[
\hat{\theta} = \frac{1}{\tau s + 1}\theta_1 + \frac{\tau s}{\tau s + 1}\theta_2 \tag{19}
\]</span></p>
<p>其中，<span class="math inline">\(\tau\)</span>为时间常数，<span class="math inline">\(s\)</span>为拉普拉斯算子，<span class="math inline">\(\frac{1}{\tau s + 1}\)</span>为低通滤波器，<span class="math inline">\(\frac{\tau s}{\tau s + 1}\)</span>为高通滤波器。</p>
]]></content>
      <categories>
        <category>传感器融合算法</category>
      </categories>
      <tags>
        <tag>sensor fusion</tag>
        <tag>传感器融合</tag>
        <tag>车辆坡度计算</tag>
        <tag>加速度计</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法-LQR-离散时间有限边界</title>
    <url>/2020/02/20/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-LQR-%E7%A6%BB%E6%95%A3%E6%97%B6%E9%97%B4%E6%9C%89%E9%99%90%E8%BE%B9%E7%95%8C/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>本文介绍离散时间有限范围内的<strong>LQR(Linear Quadratic Regulator)</strong>算法求解过程. <img data-src="https://i.loli.net/2021/08/30/erFAJgdV85LWOvI.jpg" alt="蝴蝶花" /></p>
<span id="more"></span>
<h2 id="lqr问题背景">LQR问题背景</h2>
<p>对于一个离散时间系统：</p>
<p><span class="math display">\[
x_{t+1}=Ax_t + Bu_t,x_0=x_{init}\tag{1}
\]</span></p>
<p>其中，<span class="math inline">\(A\in R^{n\times n}\)</span>，<span class="math inline">\(B\in R^{n\times m}\)</span></p>
<p>关于最优问题，就在于如何选择合适的<span class="math inline">\(u_0,u_1,...\)</span>，使得状态量<span class="math inline">\(x_0,x_1,...\)</span>足够小，因此得到好的调节和控制；或者使得<span class="math inline">\(u_0,u_1,...\)</span>足够小，以使用更少的能量。这两个量通常相互制约，如果采用更大的输入<span class="math inline">\(u\)</span>，就会驱使状态量<span class="math inline">\(x\)</span>更快达到0。采用线性二次调节原理可以解决这个问题。</p>
<h2 id="lqr代价函数">LQR代价函数</h2>
<p>为了表示控制系统达到稳定控制所付出的代价，定义如下二次型代价函数：</p>
<p><span class="math display">\[
J(U)=\sum^{N-1}_{\tau=0}(x^{T}_{\tau}Qx_{\tau} + u^{T}_{\tau}Ru_{\tau})+ x^{T}_{N}Q_{f}x_{N}\tag{2}
\]</span></p>
<p>其中函数参数<span class="math inline">\(U = (u_0,u_1,..,u_N)\)</span>，并且矩阵<span class="math inline">\(Q,Q_f,R\)</span>为正定矩阵，及</p>
<p><span class="math display">\[
\begin{array}{cl}
Q=Q^{T}\geq0,&amp;Q_f=Q_{f}^{T}\geq0,&amp;R=R^{T}&gt;0
\end{array}
\]</span></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(Q\)</span></th>
<th style="text-align: center;"><span class="math inline">\(Q_f\)</span></th>
<th style="text-align: center;"><span class="math inline">\(R\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">给定状态代价矩阵</td>
<td style="text-align: center;">最终状态代价矩阵</td>
<td style="text-align: center;">输入代价矩阵</td>
</tr>
</tbody>
</table>
<ul>
<li><span class="math inline">\(N\)</span>：时间范围(考虑<span class="math inline">\(N = \infty\)</span>)</li>
<li><span class="math inline">\(Q\)</span>，<span class="math inline">\(R\)</span>：分别设定状态偏差和输入的相对权重</li>
<li><span class="math inline">\(R&gt;0\)</span>：意味着任何非零输入都增加<span class="math inline">\(J\)</span>的代价</li>
<li><span class="math inline">\(x_{\tau}^{T} {Q} x_{\tau}\)</span>：衡量状态偏差</li>
<li><span class="math inline">\(u^{T}_{\tau} R u_{\tau}\)</span>：衡量输入大小</li>
<li><span class="math inline">\(x^{T}_{N} Q_{f} x_{N}\)</span>：衡量最终状态偏差</li>
</ul>
<p>因此，关于<strong>LQR</strong>问题就是找出使得代价函数<span class="math inline">\(J(U)\)</span>最小的一组控制输入<span class="math inline">\((u_0,u_1,...,u_{N-1})_{lqr}\)</span>。</p>
<h2 id="求解lqr方法">求解LQR方法</h2>
<p>本文主要介绍两种求解LQR的方法，分别为最小二乘法和动态规划算法。</p>
<h3 id="最小二乘法">最小二乘法</h3>
<p>根据公式(1)可知，<span class="math inline">\(x_0\)</span>是<span class="math inline">\(X = (x_0,...,x_N)\)</span>的线性函数，并且<span class="math inline">\(U = (u_0,...,u_{N-1})\)</span>，可以得出如下关系：</p>
<p><span class="math display">\[
\begin{array}{cl}
x_1 &amp;= Ax_0 + Bu_0\\
x_2 &amp;= Ax_1 + Bu_1\\
\vdots\\
x_n &amp;= Ax_{N-1} + Bu_{N-1}
\end{array}\tag{3}
\]</span></p>
<p>将上述公式(3)逐个带入得</p>
<p><span class="math display">\[
\begin{array}{cl}
x_1 &amp;= Ax_0 + Bu_0\\
x_2 &amp;= A^{2}x_0 + ABu_0 + Bu_1\\
\vdots\\
x_n &amp;= A^{N}x_0 + A^{N-1}Bu_0 + A^{N-2}Bu_1 + \dots+ Bu_{N-1}
\end{array} \tag{4}
\]</span></p>
<p>整理得</p>
<p><span class="math display">\[
\left[\begin{array}{cl}
x_0\\
x_1\\
\vdots\\
x_N
\end{array}\right]=
\left[ \begin{array}{cl}
0 &amp; \dots \\
B &amp; 0 &amp; \dots \\
AB &amp; B &amp; 0 &amp; \dots \\
\vdots &amp; \vdots \\
A^{N-1}B &amp; A^{N-2}B &amp; \dots &amp; B
\end{array}\right]
\left[
\begin{array}{cl}
u_0\\
u_1\\
\vdots\\
u_{N-1}
\end{array}
\right]+
\left[
\begin{array}{cl}
I\\
A\\
\vdots\\
A^{N}
\end{array}
\right]x_0 \tag{5}
\]</span></p>
<p>其中</p>
<p><span class="math display">\[
G=\left[ \begin{array}{cl}
0 &amp; \dots \\
B &amp; 0 &amp; \dots \\
AB &amp; B &amp; 0 &amp; \dots \\
\vdots &amp; \vdots \\
A^{N-1}B &amp; A^{N-2}B &amp; \dots &amp; B
\end{array}\right]，H=\left[
\begin{array}{cl}
I\\
A\\
\vdots\\
A^{N}
\end{array}
\right]
\]</span></p>
<p>等式(5)可以进一步表示为</p>
<p><span class="math display">\[
X= GU + Hx_0 \tag{6}
\]</span></p>
<p>其中，<span class="math inline">\(G\in R^{Nn\times Nm}\)</span>，<span class="math inline">\(H\in R^{Nn\times n}\)</span>。</p>
<p>从而等式(2)所表示得代价函数可以表示为</p>
<p><span class="math display">\[
J(U)=\parallel diag(Q^{1/2},\dots,Q^{1/2},Q^{1/2}_{f})(GU+Hx_0)\parallel^2+
\parallel diag(R^{1/2},\dots,R^{1/2})U\parallel^2 \tag{7}
\]</span></p>
<p>这就转化成一个求解最小二乘法的问题，其问题大小为<span class="math inline">\(N(n + m)\times Nm\)</span>。</p>
<h3 id="动态规划法dynamic-programming">动态规划法(Dynamic Programming)</h3>
<p>动态规划算法是解决多阶段决策过程最优化的一种有效的数学方法。</p>
<h4 id="值函数">值函数</h4>
<p>首先定义一个值函数<span class="math inline">\(V_t:R^n \to R\)</span>,其中<span class="math inline">\(t=(0,\dots,N)\)</span>：</p>
<p><span class="math display">\[
V_t(z)=\min_{u_t,\dots,u_{N-1}}\Bigl(\sum_{\tau=t}^{N-1}(x^T_\tau Qx_\tau + u^t_\tau Ru_\tau) + x_N^TQ_fx_N\Bigr) \tag{8}
\]</span></p>
<p>如果设置<span class="math inline">\(x_t = z\)</span>，根据公式(1)的关系，<span class="math inline">\(x_{\tau+1} = Ax_{\tau} + Bu_{\tau}\)</span>,并且<span class="math inline">\(\tau=t,\dots,N\)</span>。</p>
<ul>
<li><span class="math inline">\(V_t(z)\)</span>可以表示在<span class="math inline">\(t\)</span>时刻，从状态<span class="math inline">\(z\)</span>开始的LQR最小代价值</li>
<li><span class="math inline">\(V_0(x_0)\)</span>表示在0时刻，从状态<span class="math inline">\(x_0\)</span>开始的LQR最小代价值</li>
</ul>
<p><span class="math inline">\(V_t\)</span>可以表示为二次型的形式，即<span class="math inline">\(V_T(z)=z^TP_tz\)</span>, 其中<span class="math inline">\(P_t=P_t^T \geq 0\)</span>。当<span class="math inline">\(t=N\)</span>时，代价值函数为：</p>
<p><span class="math display">\[
V_N(z) = z^TQ_f z \tag{9}
\]</span></p>
<p>因此<span class="math inline">\(P_N = Q_f\)</span>。</p>
<p>根据动态规划原理，等式(8)可以写成如下递归关系式：</p>
<p><span class="math display">\[
V_t(z)=\min_w\bigl(z^TQz + w^TRw + V_{t+1}(Az+Bw)\bigr)\tag{10}
\]</span></p>
<p>其中，</p>
<ul>
<li><span class="math inline">\(z^TQz + w^TRw\)</span>：如果<span class="math inline">\(u_t = w\)</span>,则代表<span class="math inline">\(t\)</span>时刻产生的代价值；</li>
<li><span class="math inline">\(V_{t+1}(Az+Bw)\)</span>：代表从<span class="math inline">\(t+1\)</span>时刻开始，引起的最小代价值；</li>
</ul>
<p>提取等式(10)中与<span class="math inline">\(w\)</span>无关的选项得</p>
<p><span class="math display">\[
V_t(z)=z^TQz + \min_w\bigl(w^TRw + V_{t+1}(Az+Bw)\bigr)\tag{11}
\]</span></p>
<p>等式(11)描述了<span class="math inline">\(V_t(z)\)</span>与<span class="math inline">\(V_{t+1}(z)\)</span>之间的递归关系。</p>
<p>最优控制率<span class="math inline">\(u_t\)</span>可以表示为</p>
<p><span class="math display">\[
u_t^{lqr}=arg\min_w\bigl(w^TRw + V_{t+1}(Az+Bw)\bigr)
\]</span></p>
<h4 id="求极值">求极值</h4>
<p>假设<span class="math inline">\(V_{t+1}= z^TP_{t+1}z\)</span>,并且<span class="math inline">\(P_{t+1}=P^{T}_{t+1} \geq0\)</span>,等式(13)可以进一步转化为<span class="math inline">\(P_{t+1}\)</span>的形式：</p>
<p><span class="math display">\[
V_t(z)=z^TQz + \min_w\bigl(w^TRw + (Az+Bw)^TP_{t+1}(Az+Bw)\bigr)\tag{12}
\]</span></p>
<p>为了求最小值，对<span class="math inline">\(w\)</span>求导，导数为零的点即为最值点。</p>
<p><span class="math display">\[
2w^TR + 2(Az+Bw)^TP_{t+1}B = 0 \tag{13}
\]</span></p>
<p>推导等式(13)，求取<span class="math inline">\(w\)</span>:</p>
<p><span class="math display">\[
\begin{array}{cl}
w^TR + z^{T}A^{T}P_{t+1}B+w^{T}B^{T}P_{t+1}B &amp;= 0\\
w^T(R + B^TP_{t+1}B) &amp;= - z^{T}A^{T}P_{t+1}B &amp;\text{(合并同类项并移项)}\\
(R + B^TP_{t+1}B)^Tw &amp;= -B^TP_{t+1}^{T}Az &amp; \text{(转置)}\\
(R + B^TP_{t+1}B)w &amp;= -B^TP_{t+1}Az &amp;(P_{t+1}=P^{T}_{t+1},R=R^T)\\
w &amp;=-(R + B^TP_{t+1}B)^{-1}B^TP_{t+1}Az &amp;\text{(矩阵求逆)}
\end{array}\tag{14}
\]</span></p>
<p>由等式(14)可知，最优输入为</p>
<p><span class="math display">\[
w^* =-(R + B^TP_{t+1}B)^{-1}B^TP_{t+1}Az \tag{15}
\]</span></p>
<p>将等式(15)带入等式(12)得</p>
<p><span class="math display">\[
V_t(z)=z^TQz + w^{*T}Rw^* + (Az+Bw^*)^TP_{t+1}(Az+Bw^*)\tag{16}
\]</span></p>
<p>对等式(16)化简得</p>
<p><span class="math display">\[
\begin{array}{cl}
V_t(z) 
&amp;= &amp; z^TQz + w^{*T}Rw^* + (Az+Bw^*)^TP_{t+1}(Az+Bw^*)\\
&amp;= &amp; z^TQz + w^{*T}Rw^* + z^TA^TP_{t+1}Az + 2z^TA^TP_{t+1}Bw^* + w^{*T}B^TP_{t+1}Bw^*\\
&amp;= &amp;z^TQz + z^TA^TP_{t+1}Az + w^{*T}(R+B^TP_{t+1}B)w^*  + 2z^TA^TP_{t+1}Bw^*\\
&amp;= &amp;z^TQz + z^TA^TP_{t+1}Az\\
&amp;  &amp;+z^TA^TP_{t+1}B(R + B^TP_{t+1}B)^{-1}(R+B^TP_{t+1}B)(R + B^TP_{t+1}B)^{-1}B^TP_{t+1}Az\\
&amp;  &amp;-2z^TA^TP_{t+1}B(R + B^TP_{t+1}B)^{-1}B^TP_{t+1}Az\\
&amp;= &amp;z^TQz + z^TA^TP_{t+1}Az\\
&amp;  &amp;+z^TA^TP_{t+1}B(R + B^TP_{t+1}B)^{-1}B^TP_{t+1}Az\\
&amp;  &amp;-2z^TA^TP_{t+1}B(R + B^TP_{t+1}B)^{-1}B^TP_{t+1}Az\\
&amp;= &amp;z^TQz + z^TA^TP_{t+1}Az - z^TA^TP_{t+1}B(R + B^TP_{t+1}B)^{-1}B^TP_{t+1}Az\\
&amp;= &amp;z^T(Q + A^TP_{t+1}A - A^TP_{t+1}B(R + B^TP_{t+1}B)^{-1}B^TP_{t+1}A)z\\
&amp;= &amp;z^TP_tz
\end{array}\tag{17}
\]</span></p>
<p>上述公式化简过程中，由于<span class="math inline">\(P_{t+1}=P^{T}_{t+1},R=R^T\)</span>，所以<span class="math inline">\(\bigl((R+B^TP_{t+1}B)^{-1}\bigr)^T = (R + B^TP_{t+1}B)^{-1}\)</span>。</p>
<p>由等式(17)可知</p>
<p><span class="math display">\[
P_t = Q + A^TP_{t+1}A - A^TP_{t+1}B(R + B^TP_{t+1}B)^{-1}B^TP_{t+1}A \tag{18}
\]</span></p>
<h4 id="求解过程">求解过程</h4>
<p>关于LQR的求解过程，可以采用动态规划算法，依据上述公式(18)的递归关系，反向递推，求出满足一定条件的最小代价值。</p>
<ol type="1">
<li>确定迭代范围<span class="math inline">\(N\)</span></li>
<li>设置迭代初始值<span class="math inline">\(P_N=Q_f\)</span></li>
<li>循环迭代，<span class="math inline">\(t = N,\dots,1\)</span></li>
</ol>
<p><span class="math display">\[
P_{t-1} = Q + A^TP_{t+1}A - A^TP_{t+1}B(R + B^TP_{t+1}B)^{-1}B^TP_{t+1}A
\]</span></p>
<ol start="4" type="1">
<li>则反馈系数<span class="math inline">\(K_t = -(R + B^TP_{t+1}B)^{-1}B^TP_{t+1}A\)</span>，对于时间<span class="math inline">\(t=0,\dots,N-1\)</span></li>
<li>优化的控制量<span class="math inline">\(u_t^{lqr}=K_tx_t\)</span></li>
</ol>
]]></content>
      <categories>
        <category>基础算法</category>
        <category>最优算法</category>
      </categories>
      <tags>
        <tag>LQR</tag>
        <tag>Linear quadratic regulator</tag>
        <tag>最优</tag>
      </tags>
  </entry>
  <entry>
    <title>双线性插值</title>
    <url>/2019/10/19/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%8F%8C%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>线性差值在实际应用非常广泛，比如航空航天行业中广泛用到气动数据的插值，经常会用到三线性到四线性的插值，在汽车行业很多标定数据而需要使用双线性插值，本篇文章主要讲述双线性插值的实现方式。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/yLw1Imexs68bTHc.jpg" alt="重庆博物馆" /><figcaption aria-hidden="true">重庆博物馆</figcaption>
</figure>
<span id="more"></span>
<h2 id="应用场景">应用场景</h2>
<p>本文基于车辆扭矩标定的应用场景来说明2维线性插值的具体应用，根据车辆的控制原理可知，车辆的目标加速度与当前车速和发动机输出扭矩有关，因此对车辆扭矩进行标定后，我们就可以得到一个根据当前目标加速度和车速，获得车辆输出扭矩的关系表。 如下表所示，只选取了目标加速度为正的部分标定数据，其中横向表示速度(m/s)，纵向表示加速度(m/s2)，表中的数据代表汽车扭矩输出(Nm)。由于速度只采样了[0.1,0.2,0.3,0.4,0.5,0.6,0.7]这几个数值点的数据，加速度也只采样了[0.06,0.09,0.1,0.12,0.13,0.15,0.2,0.21,0.24,0.26]这几组数据点的数据，如果想得到中间任意数值的数值，就需要使用双线性插值算法来获得。</p>
<figure>
<img data-src="https://img-blog.csdnimg.cn/20190727155601290.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnaGZvcmV2ZXI=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>如下表所示，如果当前需求的目标加速度为0.094m/s2，当前车速为0.36m/s，想得到当前输出扭矩值，按照表格所圈出的扭矩值，进行多次线性插值，求得理想的输出扭矩。</p>
<figure>
<img data-src="https://img-blog.csdnimg.cn/20190727155822629.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnaGZvcmV2ZXI=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<h3 id="双线性插值原理">双线性插值原理</h3>
<p>双线性插值算法，是在线性插值的基础上进行多次插值的结果。 如下图所示，假设插值点<span class="math inline">\({(x_i,y_i)}\)</span>的坐标点<span class="math inline">\(x_i\)</span>和<span class="math inline">\(y_i\)</span>范围满足，<span class="math inline">\(x_1\le x_i \le x_2\)</span>，<span class="math inline">\(y_1\le y_i \le y_2\)</span>，其中<span class="math inline">\((x_1,y_1)\)</span>对应数值为<span class="math inline">\(z_1\)</span>，<span class="math inline">\((x_2,y_1)\)</span>对应数值为<span class="math inline">\(z_2\)</span>，<span class="math inline">\((x_2,y_2)\)</span>对应数值为<span class="math inline">\(z_3\)</span>，<span class="math inline">\((x_1,y_2)\)</span>对应数值为<span class="math inline">\(z_4\)</span>。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190729105119489.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnaGZvcmV2ZXI=,size_16,color_FFFFFF,t_70" /></p>
<p>第一步，进行x轴方向的线性插值。当y取值<span class="math inline">\(y_1\)</span>时，进行点<span class="math inline">\((x_1,z_1)\)</span>和点<span class="math inline">\((x_2,z_2)\)</span>之间的插值，得到插值点<span class="math inline">\((x_i,z5)\)</span>；同理y取值<span class="math inline">\(y_2\)</span>时，进行点<span class="math inline">\((x_1,z_4)\)</span>和点<span class="math inline">\((x_2,z_3)\)</span>之间的插值，可得第二个插值点<span class="math inline">\((x_i,z_6)\)</span>。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190727171729916.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnaGZvcmV2ZXI=,size_16,color_FFFFFF,t_70" /></p>
<p>第二步，进行y轴方向的插值。依据新的插值点<span class="math inline">\((y_1,z5)\)</span>和<span class="math inline">\((y_2,z_6)\)</span>，进行线性插值，得到插值点<span class="math inline">\((x_i,y_i,z_7)\)</span>。此时的点<span class="math inline">\((x_i,y_i,z_7)\)</span>就是双线性插值的最终结果。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190727171818236.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnaGZvcmV2ZXI=,size_16,color_FFFFFF,t_70" /></p>
<h2 id="软件实现">软件实现</h2>
<h3 id="概述-1">概述</h3>
<p>本文基于c语言去实现插值算法，数据结构采用简单的数组结构，不使用C++的关联容器属性去实现数据表的存储。</p>
<h3 id="数据表的存储结构">数据表的存储结构</h3>
<p>数据结构使用三个数组进行数组的存储，其中两个数组分别存储横向的速度值和纵向的加速度值，另一个数组存储对应的扭矩值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ACC_ARRAY_NUM  		( 10 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VELOCITY_ARRAY_NUM  (  7 )</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> acc_table[ACC_ARRAY_NUM]           = &#123;<span class="number">0.06f</span>,<span class="number">0.09f</span>,<span class="number">0.1f</span>,<span class="number">0.12f</span>,<span class="number">0.13f</span>,<span class="number">0.15f</span>,<span class="number">0.2f</span>,<span class="number">0.21f</span>,<span class="number">0.24f</span>,<span class="number">0.26f</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> velocity_table[VELOCITY_ARRAY_NUM] = &#123;<span class="number">0.1f</span>,<span class="number">0.2f</span>,<span class="number">0.3f</span>,<span class="number">0.4f</span>,<span class="number">0.5f</span>,<span class="number">0.6f</span>,<span class="number">0.7f</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> torque_table[ACC_ARRAY_NUM][VELOCITY_ARRAY_NUM]=</span><br><span class="line">&#123;</span><br><span class="line">		&#123;<span class="number">60</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">50</span>,<span class="number">50</span>,<span class="number">50</span>,<span class="number">50</span>&#125;,</span><br><span class="line">		&#123;<span class="number">140</span>,<span class="number">140</span>,<span class="number">100</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">50</span>,<span class="number">50</span>&#125;,</span><br><span class="line">		&#123;<span class="number">140</span>,<span class="number">140</span>,<span class="number">120</span>,<span class="number">80</span>,<span class="number">60</span>,<span class="number">60</span>,<span class="number">60</span>&#125;,</span><br><span class="line">		&#123;<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">100</span>,<span class="number">60</span>,<span class="number">60</span>,<span class="number">60</span>&#125;,</span><br><span class="line">		&#123;<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">120</span>,<span class="number">80</span>,<span class="number">60</span>,<span class="number">60</span>&#125;,</span><br><span class="line">		&#123;<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">100</span>,<span class="number">60</span>,<span class="number">60</span>&#125;,</span><br><span class="line">		&#123;<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">120</span>,<span class="number">100</span>,<span class="number">80</span>&#125;,</span><br><span class="line">		&#123;<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">120</span>,<span class="number">100</span>&#125;,</span><br><span class="line">		&#123;<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">120</span>&#125;,</span><br><span class="line">		&#123;<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>,<span class="number">140</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="索引id查找函数">索引ID查找函数</h3>
<p>输入参数 <strong><em>array</em></strong> ：需进行数值匹配查找的数组 输入参数 <strong><em>num</em></strong> ：数组的长度 输入参数 <strong><em>input</em></strong> ：需要匹配的值 输出参数 <strong><em>before</em></strong> ：匹配值的前数组边界ID 输出参数 <strong><em>before</em></strong> ：匹配值的后数组边界ID</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ArrayIndexFind</span><span class="params">(<span class="type">float</span> *<span class="built_in">array</span>,<span class="type">uint16_t</span> num,<span class="type">float</span> input,<span class="type">uint16_t</span> *before,<span class="type">uint16_t</span> *after)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint16_t</span> min_index,max_index;</span><br><span class="line">	<span class="type">uint16_t</span> middle_index;</span><br><span class="line">	min_index = <span class="number">0</span>;</span><br><span class="line">	max_index = num - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>( (max_index - min_index) &gt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		middle_index = (min_index + max_index) / <span class="number">2</span> ;</span><br><span class="line">		<span class="keyword">if</span>(input &lt; <span class="built_in">array</span>[middle_index])</span><br><span class="line">		&#123;</span><br><span class="line">			max_index = middle_index;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			min_index = middle_index;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	*before = min_index;</span><br><span class="line">	*after  = max_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据插值函数">数据插值函数</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">InterpolateValue</span><span class="params">(<span class="type">float</span> x,<span class="type">float</span> x0,<span class="type">float</span> y0,<span class="type">float</span> x1,<span class="type">float</span> y1)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">fabs</span>(x - x0) &lt; kDoubleEpsilon)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> y0;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">fabs</span>(x - x1) &lt; kDoubleEpsilon)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> y1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> y0 + (y1 - y0)*(x - x0)/ (x1 - x0);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线性差值函数">线性差值函数</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">Interpolation::InterpolationYZ</span><span class="params">(<span class="type">float</span> y,<span class="type">float</span> *y_tb,<span class="type">uint16_t</span> y_num,<span class="type">float</span> *z_tb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> max_y = y_tb[y_num - <span class="number">1</span>];</span><br><span class="line">	<span class="type">float</span> min_y = y_tb[<span class="number">0</span>];</span><br><span class="line">	<span class="type">uint16_t</span> y_before,y_after;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(y &gt;= (max_y - kDoubleEpsilon))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> z_tb[y_num - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(y &lt;= (min_y + kDoubleEpsilon))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> z_tb[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ArrayIndexFind(y_tb,y_num,y,&amp;y_before,&amp;y_after);</span><br><span class="line">	<span class="keyword">return</span> InterpolateValue(y,y_tb[y_before],z_tb[y_before],y_tb[y_after],z_tb[y_after]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双线性插值函数">双线性插值函数</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">Interpolation2D</span><span class="params">(<span class="type">float</span> x,<span class="type">float</span> y,<span class="type">float</span> *x_tb,<span class="type">uint16_t</span> x_num,<span class="type">float</span> *y_tb,<span class="type">uint16_t</span> y_num,<span class="type">float</span> *z_tb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> max_x = x_tb[x_num - <span class="number">1</span>];</span><br><span class="line">	<span class="type">float</span> min_x = x_tb[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	<span class="type">uint16_t</span> x_before,x_after;</span><br><span class="line">	<span class="type">uint16_t</span> z_before_value,z_after_value;</span><br><span class="line">	<span class="keyword">if</span>(x &gt; (max_x - kDoubleEpsilon))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> InterpolationYZ(y,y_tb,y_num, (z_tb + (x_num - <span class="number">1</span>)*y_num));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x &lt; (min_x + kDoubleEpsilon))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> InterpolationYZ(y,y_tb,y_num, z_tb);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ArrayIndexFind(x_tb,x_num,x,&amp;x_before,&amp;x_after);</span><br><span class="line"></span><br><span class="line">	z_before_value = InterpolationYZ(y,y_tb,y_num, (z_tb + x_before * y_num));</span><br><span class="line">	z_after_value  = InterpolationYZ(y,y_tb,y_num, (z_tb + x_after  * y_num));</span><br><span class="line">	<span class="keyword">return</span> InterpolateValue(x,x_tb[x_before],z_before_value,x_tb[x_after],z_after_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>线性插值</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最小二乘法线性拟合</title>
    <url>/2019/10/17/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95%E7%9A%84%E7%BA%BF%E6%80%A7%E6%8B%9F%E5%90%88/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>最小二乘法是曲线拟合的常用方法，使用该方法对匹配函数的选取非常重要。 <img data-src="https://i.loli.net/2021/08/30/67NEhYDHezj1PX2.jpg" alt="青岛" /></p>
<span id="more"></span>
<h2 id="理论">理论</h2>
<ol type="1">
<li>假设拟合的多项式为:</li>
</ol>
<p><span class="math display">\[
y = a_0 + a_1*x +a_2*x^2 + ...+a_m*x^m
\]</span></p>
<p>其中，<strong>m</strong>代表多项式的阶数。</p>
<ol start="2" type="1">
<li>离散点与该多项式的平方和<span class="math inline">\(F(a_0,a_1,,a_m)\)</span>为，其中<strong>n</strong>代表采样点数：</li>
</ol>
<p><span class="math display">\[
F(a_0,a_1,,a_m) = \sum_{i=0}^n[y_i - (a_0 + a_1*x_i +a_2*x_i^2 + ...+a_m*x_i^m)]^2
\]</span></p>
<ol start="3" type="1">
<li><p>最小二乘法的思想是求平方和函数<span class="math inline">\(F(a_0,a_1,,a_m)\)</span>的最小值，而对于二次方程求最小值的问题，常见的思路就是对方程求导，倒数为零的点，及为方程的极值点。</p></li>
<li><p>下面对<span class="math inline">\(F(a_0,a_1,,a_m)\)</span>分别求<span class="math inline">\(a_i\)</span>偏导数，得：</p></li>
</ol>
<p><span class="math display">\[
-2 \sum_{i=0}^n[y_i - (a_0 + a_1*x_i +a_2*x_i^2 + ...+a_m*x_i^m)] = 0 \\
-2 \sum_{i=0}^n[y_i - (a_0 + a_1*x_i +a_2*x_i^2 + ...+a_m*x_i^m)] x_i= 0\\
-2 \sum_{i=0}^n[y_i - (a_0 + a_1*x_i +a_2*x_i^2 + ...+a_m*x_i^m)] x_i^2= 0\\
\ldots\\
-2 \sum_{i=0}^n[y_i - (a_0 + a_1*x_i +a_2*x_i^2 + ...+a_m*x_i^m)] x_i^m= 0
\]</span></p>
<ol start="5" type="1">
<li>整理得</li>
</ol>
<p><span class="math display">\[
a_0\sum_{i=0}^{n}+a_1\sum_{i=0}^{n} x_i+ a_2\sum_{i=0}^{n} x_i^2+...+a_m\sum_{i=0}^{n}x_i^m = \sum_{i=0}^{n}y_i\\
a_0\sum_{i=0}^{n} x_i+a_1\sum_{i=0}^{n} x_i^2+ a_2\sum_{i=0}^{n} x_i^3+...+a_m\sum_{i=0}^{n}x_i^{m+1}  = \sum_{i=0}^{n}y_ix_i\\
\ldots\\
a_0\sum_{i=0}^{n} x_i^m+a_1\sum_{i=0}^{n} x_i^{m+1}+ a_2\sum_{i=0}^{n} x_i^{m+2}+...+a_m\sum_{i=0}^{n}x_i^{2m}  = \sum_{i=0}^{n}y_ix_i^m
\]</span></p>
<ol start="6" type="1">
<li>使用矩阵形式表示为：</li>
</ol>
<p><span class="math display">\[
\left[
\begin{matrix}
\sum_{i=0}^{n} &amp; \sum_{i=0}^{n}x_i&amp;\sum_{i=0}^{n}x_i^2&amp;\ldots&amp;\sum_{i=0}^{n}x_i^m\\
\sum_{i=0}^{n}x_i&amp;\sum_{i=0}^{n}x_i^2&amp;\sum_{i=0}^{n}x_i^3&amp;\ldots&amp;\sum_{i=0}^{n}x_i^{m+1}\\
\sum_{i=0}^{n}x_i^2&amp;\sum_{i=0}^{n}x_i^3&amp;\sum_{i=0}^{n}x_i^4&amp;\ldots&amp;\sum_{i=0}^{n}x_i^{m+2}\\
\ldots&amp;\ldots&amp;\ldots&amp;\ldots&amp;\ldots\\
\sum_{i=0}^{n}x_i^{m}&amp;\sum_{i=0}^{n}x_i^{m+1}&amp;\sum_{i=0}^{n}x_i^{m+2}&amp;\ldots&amp;\sum_{i=0}^{n}x_i^{2m}
\end{matrix}
\right] 
\left[
\begin{matrix}
a_0\\
a_1\\
a_2\\
\ldots\\
a_m
\end{matrix}
\right]=\\
\left[
\begin{matrix}
\sum_{i=0}^{n}y_i\\
\sum_{i=0}^{n}y_ix_i\\
\sum_{i=0}^{n}y_ix_i^2\\
\ldots\\
\sum_{i=0}^{n}y_ix_i^m\\
\end{matrix}
\right]
\]</span></p>
<ol start="7" type="1">
<li>下面就是求解一次线性方程，常用的方法是使用高斯消元法，也可以使用求矩阵的秩或者求解逆矩阵等方式求解。</li>
</ol>
<h2 id="高斯消元法求解线性方程">高斯消元法求解线性方程</h2>
<h3 id="原则">原则</h3>
<ul>
<li>两个方程互换解不变</li>
<li>一个方程乘以非零K,解不变</li>
<li>一个方程乘以非零K,加上另一个方程解不变</li>
</ul>
<h3 id="一阶线性函数">一阶线性函数</h3>
<p>假设多项式得阶数<strong>m</strong>为2，则上述矩阵方程为：</p>
<p><span class="math display">\[
\left[
\begin{matrix}
\sum_{i=0}^{n} &amp; \sum_{i=0}^{n}x_i\\
\sum_{i=0}^{n}x_i&amp;\sum_{i=0}^{n}x_i^2&amp;
\end{matrix}
\right] 
\left[
\begin{matrix}
a_0\\
a_1
\end{matrix}
\right]=\\
\left[
\begin{matrix}
\sum_{i=0}^{n}y_i\\
\sum_{i=0}^{n}y_ix_i
\end{matrix}
\right]
\]</span></p>
<p>写成行列式的形式为：</p>
<p><span class="math display">\[
\begin{vmatrix}
\sum_{i=0}^{n} &amp; \sum_{i=0}^{n}x_i&amp;\sum_{i=0}^{n}y_i\\
\sum_{i=0}^{n}x_i &amp; \sum_{i=0}^{n}x_i^2&amp;\sum_{i=0}^{n}y_ix_i\\
\end{vmatrix}
\]</span></p>
<p>第一行乘以系数<span class="math inline">\(\sum_{i=0}^{n}\)</span>，第二行乘以系数<span class="math inline">\(\sum_{i=0}^{n}x_i\)</span></p>
<p><span class="math display">\[
\begin{vmatrix}
1 &amp; \frac{\sum_{i=0}^{n}x_i}{\sum_{i=0}^{n}} &amp; \frac{\sum_{i=0}^{n}y_i}{\sum_{i=0}^{n}}\\
1 &amp; \frac{\sum_{i=0}^{n}x_i^2}{\sum_{i=0}^{n}x_i} &amp; \frac{\sum_{i=0}^{n}y_ix_i}{\sum_{i=0}^{n}x_i}
\end{vmatrix}
\]</span></p>
<p>第二行减去第一行得</p>
<p><span class="math display">\[
\begin{vmatrix}
1 &amp; \frac{\sum_{i=0}^{n}x_i}{\sum_{i=0}^{n}} &amp; \frac{\sum_{i=0}^{n}y_i}{\sum_{i=0}^{n}}\\
0 &amp; \frac{\sum_{i=0}^{n}x_i^2}{\sum_{i=0}^{n}x_i} -\frac{\sum_{i=0}^{n}x_i}{\sum_{i=0}^{n}} &amp; \frac{\sum_{i=0}^{n}y_ix_i}{\sum_{i=0}^{n}x_i} - \frac{\sum_{i=0}^{n}y_i}{\sum_{i=0}^{n}}
\end{vmatrix}
\]</span></p>
<p>通过上式可得<span class="math inline">\(a_1\)</span>为</p>
<p><span class="math display">\[
a_1 
= \frac{\frac{\sum_{i=0}^{n}y_ix_i}{\sum_{i=0}^{n}x_i} - \frac{\sum_{i=0}^{n}y_i}{\sum_{i=0}^{n}}}{\frac{\sum_{i=0}^{n}x_i^2}{\sum_{i=0}^{n}x_i} -\frac{\sum_{i=0}^{n}x_i}{\sum_{i=0}^{n}}}
=\frac{\sum_{i=0}^{n}y_ix_i*\sum_{i=0}^{n}-\sum_{i=0}^{n}y_i*\sum_{i=0}^{n}x_i}{\sum_{i=0}^{n}x_i^2*\sum_{i=0}^{n} - \sum_{i=0}^{n}x_i*\sum_{i=0}^{n}x_i}
\]</span></p>
<p>同理将<span class="math inline">\(a_1\)</span>回代入得：</p>
<p><span class="math display">\[
a_0 
= \frac{\sum_{i=0}^{n}y_i}{\sum_{i=0}^{n}} - \frac{(\sum_{i=0}^{n}y_ix_i*\sum_{i=0}^{n}-\sum_{i=0}^{n}y_i*\sum_{i=0}^{n}x_i)*\sum_{i=0}^{n}x_i}{(\sum_{i=0}^{n}x_i^2*\sum_{i=0}^{n} - \sum_{i=0}^{n}x_i*\sum_{i=0}^{n}x_i)*\sum_{i=0}^{n}}\\
=\frac{(\sum_{i=0}^{n}x_i^2*\sum_{i=0}^{n} - \sum_{i=0}^{n}x_i*\sum_{i=0}^{n}x_i)*\sum_{i=0}^{n}y_i -(\sum_{i=0}^{n}y_ix_i*\sum_{i=0}^{n}-\sum_{i=0}^{n}y_i*\sum_{i=0}^{n}x_i)*\sum_{i=0}^{n}x_i}{(\sum_{i=0}^{n}x_i^2*\sum_{i=0}^{n} - \sum_{i=0}^{n}x_i*\sum_{i=0}^{n}x_i)*\sum_{i=0}^{n}}\\
=\frac{\sum_{i=0}^{n}x_i^2*\sum_{i=0}^{n}\sum_{i=0}^{n}y_i -\sum_{i=0}^{n}y_ix_i*\sum_{i=0}^{n}\sum_{i=0}^{n}x_i}{(\sum_{i=0}^{n}x_i^2*\sum_{i=0}^{n} - \sum_{i=0}^{n}x_i*\sum_{i=0}^{n}x_i)*\sum_{i=0}^{n}}\\
=\frac{\sum_{i=0}^{n}x_i^2\sum_{i=0}^{n}y_i -\sum_{i=0}^{n}y_ix_i\sum_{i=0}^{n}x_i}{\sum_{i=0}^{n}x_i^2*\sum_{i=0}^{n} - \sum_{i=0}^{n}x_i*\sum_{i=0}^{n}x_i}
\]</span></p>
<p>故最终可得</p>
<p><span class="math display">\[
a_0
=\frac{\sum_{i=0}^{n}x_i^2\sum_{i=0}^{n}y_i -\sum_{i=0}^{n}y_ix_i\sum_{i=0}^{n}x_i}{\sum_{i=0}^{n}x_i^2*\sum_{i=0}^{n} - \sum_{i=0}^{n}x_i*\sum_{i=0}^{n}x_i}
\]</span></p>
<p><span class="math display">\[
a_1 
=\frac{\sum_{i=0}^{n}y_ix_i*\sum_{i=0}^{n}-\sum_{i=0}^{n}y_i*\sum_{i=0}^{n}x_i}{\sum_{i=0}^{n}x_i^2*\sum_{i=0}^{n} - \sum_{i=0}^{n}x_i*\sum_{i=0}^{n}x_i}
\]</span></p>
]]></content>
      <categories>
        <category>基础算法</category>
        <category>最优算法</category>
      </categories>
      <tags>
        <tag>最小二乘法</tag>
        <tag>C++/C</tag>
      </tags>
  </entry>
  <entry>
    <title>直线特征提取</title>
    <url>/2019/11/22/%E6%84%9F%E7%9F%A5%E7%AE%97%E6%B3%95-%E7%9B%B4%E7%BA%BF%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/</url>
    <content><![CDATA[<h2 id="问题概述">问题概述</h2>
<p>常见的直线特征提取算法是最小二乘法进行的直线拟合，但是线性二次拟合的效果容易受噪声影响，导致拟合效果较差。本文基于直线方程的另一种形式，详细给出最优直线的推导过程。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/Q7SMVU8LzrANGlv.jpg" alt="菊花展" /><figcaption aria-hidden="true">菊花展</figcaption>
</figure>
<span id="more"></span>
<p>直线方程可以表示为</p>
<p><span class="math display">\[
r = \cos\theta*x + \sin\theta*y
\]</span></p>
<p>几何关系如下图所示</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/qEJyiMoPC2jwhLn.gif" alt="几何关系" /><figcaption aria-hidden="true">几何关系</figcaption>
</figure>
<p>假设一组数据集合为</p>
<p><span class="math display">\[
S_k= \{ (x_0,y_0),...,(x_k,y_k)\}
\]</span></p>
<p>该数据集符合直线分布，那么满足<span class="math inline">\(S_k\)</span>数据的最优直线<span class="math inline">\(L\)</span>为</p>
<p><span class="math display">\[
r = \cos\theta*x + \sin\theta*y \tag{1}
\]</span></p>
<p>这组数据集与直线<span class="math inline">\(L\)</span>的误差值为</p>
<p><span class="math display">\[
e_i = \| \cos\theta*x_i + \sin\theta*y_i - r\| \tag{2}
\]</span></p>
<p>方差值为</p>
<p><span class="math display">\[
E_2 =\sum_{S_k}e_i^2 \tag{3}
\]</span></p>
<p>那么求取与数据点<span class="math inline">\(S_k\)</span>匹配度最优的线段<span class="math inline">\(L\)</span>问题,就可以转化为求取方差<span class="math inline">\(E_2\)</span>的最小值问题。</p>
<h2 id="最值求解过程推导">最值求解过程推导</h2>
<h3 id="函数定义">函数定义</h3>
<p>根据最值原理，求最小值的问题，可以转化为求解函数导数为零的解的问题。 假设函数</p>
<p><span class="math display">\[
f(\theta,r) = \sum_{S_k}(\cos\theta*x_i + \sin\theta*y_i - r)^2 \tag{4}
\]</span></p>
<p>导数为</p>
<p><span class="math display">\[
\dot{f}(\theta,r) = 2\sum_{S_k}(\cos\theta*x_i + \sin\theta*y_i - r)&#39; \tag{5}
\]</span></p>
<p>根据函数参数 <span class="math inline">\(\theta\)</span> 和 <span class="math inline">\(r\)</span>，分别对其求偏导数得</p>
<p><span class="math display">\[
\dot{f}(\theta,r) = \frac{\partial f}{\partial \theta} + \frac{\partial f}{\partial r} \tag{6}
\]</span></p>
<p>故得</p>
<p><span class="math display">\[
\dot{f}(\theta,r) = 2\sum_{S_k}(\cos\theta*x_i + \sin\theta*y_i - r)(\cos\theta*y_i - \sin\theta*x_i -1) \tag{7}
\]</span></p>
<p>当 <span class="math inline">\(\dot{f}(\theta,r)= 0\)</span>得</p>
<p><span class="math display">\[
\sum_{S_k}(\cos\theta*x_i + \sin\theta*y_i - r)(\cos\theta*y_i - \sin\theta*x_i -1) = 0 \tag{8}
\]</span></p>
<h3 id="求解假设">求解假设</h3>
<p>假设</p>
<p><span class="math display">\[
\begin{array}{r}
\sum_{S_k}\cos\theta*x_i + \sin\theta*y_i - r = 0 \\
\cos\theta\sum_{i_0}^kx_i + \sin\theta\sum_{i_0}^ky_i - \sum_{i_0}^kr = 0 \tag{9}
\end{array}
\]</span></p>
<p>由上述得</p>
<p><span class="math display">\[
\begin{array}{l}
\sum_{i=0}^{k}r &amp;= \cos\theta\sum_{i=0}^kx_i + \sin\theta\sum_{i=0}^ky_i \\
 r &amp;= \cos\theta\frac{\sum_{i=0}^kx_i}{k} + \sin\theta\frac{\sum_{i=0}^ky_i}{k} \tag{10}
\end{array}
\]</span></p>
<p>令</p>
<p><span class="math display">\[
\begin{array}{l}
V_x = \frac{\sum_{i=0}^kx_i}{k} \\
V_y = \frac{\sum_{i=0}^ky_i}{k} \tag{11}
\end{array}
\]</span></p>
<p>上述公式可以表述为</p>
<p><span class="math display">\[
r = \cos\theta*V_x + \sin\theta*V_y \tag{12}
\]</span></p>
<h3 id="函数导数化简">函数导数化简</h3>
<p>由公式(8)得</p>
<p><span class="math display">\[
\sum_{i=0}^{k}(\cos\theta*x_i + \sin\theta*y_i)(\cos\theta*y_i - \sin\theta*x_i) -\sum_{i=0}^{k}(\cos\theta*x_i + \sin\theta*y_i)- 
\sum_{i=0}^{k}r(\cos\theta*y_i - \sin\theta*x_i) + \sum_{i=0}^{k}r = 0 \tag{13}
\]</span></p>
<p>将等式(12)带入等式(13),并将等式分解为一下4个部分</p>
<p><span class="math display">\[
\begin{array}{l}
A = \sum_{i=0}^{k}\cos^2\theta*x_iy_i - \sin\theta\cos\theta*x_i^2 + \sin\theta\cos\theta*y_i^2 -\sin^2\theta*x_iy_i \\
B = \sum_{i=0}^{k}(\cos\theta*x_i + \sin\theta*y_i) \\
C = \sum_{i=0}^{k}(\cos\theta*V_x + \sin\theta*V_y)(\cos\theta*y_i - \sin\theta*x_i) \\
D = \sum_{i=0}^{k}(\cos\theta*V_x + \sin\theta*V_y) \tag{14}
\end{array}
\]</span></p>
<p>等式(14)的四个部分可化简为</p>
<ul>
<li><strong>A</strong></li>
</ul>
<p><span class="math display">\[
\begin{array}{l}
A = \sum_{i=0}^{k}\cos^2\theta*x_iy_i - \sin\theta\cos\theta*x_i^2 + \sin\theta\cos\theta*y_i^2 -\sin^2\theta*x_iy_i\\
\quad = (\cos^2\theta - \sin^2\theta)\sum_{i=0}^{k}x_iy_i - \sin\theta\cos\theta(\sum_{i=0}^{k}x_i^2 - \sum_{i=0}^{k}y_i^2)\\
\quad = \cos2\theta\sum_{i=0}^{k}x_iy_i - 0.5\sin2\theta(\sum_{i=0}^{k}x_i^2 - \sum_{i=0}^{k}y_i^2) \tag{15}
\end{array}
\]</span></p>
<ul>
<li><p><strong>B</strong> <span class="math display">\[
\begin{array}{l}
B = \sum_{i=0}^{k}(\cos\theta*x_i + \sin\theta*y_i) \\
\quad = \cos\theta\sum_{i=0}^{k}x_i + \sin\theta\sum_{i=0}^{k}y_i \tag{16}
\end{array}
\]</span></p></li>
<li><p><strong>C</strong> <span class="math display">\[
\begin{array}{l}
C = \sum_{i=0}^{k}(\cos\theta*V_x + \sin\theta*V_y)(\cos\theta*y_i - \sin\theta*x_i) \\
\quad =\cos^2\theta*V_x\sum_{i=0}^{k}y_i - \sin\theta\cos\theta*V_x\sum_{i=0}^{k}x_i+\sin\theta\cos\theta*V_y\sum_{i=0}^{k}y_i -\sin^2\theta*V_y\sum_{i=0}^{k}x_i\\
\quad =(\cos^2\theta - \sin^2\theta)\frac{\sum_{i=0}^{k}x_i\sum_{i=0}^{k}y_i}{k} - \sin\theta\cos\theta(V_x\sum_{i=0}^{k}x_i - V_y\sum_{i=0}^{k}y_i)\\
\quad =\cos2\theta\frac{\sum_{i=0}^{k}x_i\sum_{i=0}^{k}y_i}{k} - 0.5\sin2\theta(V_x\sum_{i=0}^{k}x_i - V_y\sum_{i=0}^{k}y_i)\tag{17}
\end{array}
\]</span></p></li>
<li><p><strong>D</strong> <span class="math display">\[
\begin{array}{l}
D = \sum_{i=0}^{k}(\cos\theta*V_x + \sin\theta*V_y) \\
\quad =\cos\theta*V_x\sum_{i=0}^{k} + \sin\theta*V_y\sum_{i=0}^{k} \\
\quad =\cos\theta\sum_{i=0}^{k}x_i + \sin\theta\sum_{i=0}^{k}y_i \tag{18}
\end{array}
\]</span></p></li>
</ul>
<p>故等式(13)可以表示为</p>
<p><span class="math display">\[
A - B - C + D = 0 \tag{19}
\]</span></p>
<p>根据等式(16)和(18)知，B和D相等，故等式(19)可以进一步简化为</p>
<p><span class="math display">\[
A - C = 0 \tag{20}
\]</span></p>
<p>等式(20)两端同时扩大两倍得</p>
<p><span class="math display">\[
2\cos2\theta\sum_{i=0}^{k}x_iy_i - \sin2\theta(\sum_{i=0}^{k}x_i^2 - \sum_{i=0}^{k}y_i^2) -2\cos2\theta\frac{\sum_{i=0}^{k}x_i\sum_{i=0}^{k}y_i}{k} + \sin2\theta(V_x\sum_{i=0}^{k}x_i - V_y\sum_{i=0}^{k}y_i) = 0\tag{21}
\]</span></p>
<p>合并同类项得</p>
<p><span class="math display">\[
\cos2\theta*2*(\sum_{i=0}^{k}x_iy_i - \frac{\sum_{i=0}^{k}x_i\sum_{i=0}^{k}y_i}{k}) + \sin2\theta(V_x\sum_{i=0}^{k}x_i - V_y\sum_{i=0}^{k}y_i - \sum_{i=0}^{k}x_i^2 + \sum_{i=0}^{k}y_i^2) = 0 \tag{22}
\]</span></p>
<p>令</p>
<ul>
<li><p><span class="math inline">\(V_{xy}\)</span> <span class="math display">\[
\begin{array}{l}
V_{xy} = \sum_{i=0}^{k}x_iy_i - \frac{\sum_{i=0}^{k}x_i\sum_{i=0}^{k}y_i}{k}\\
\qquad = \sum_{i=0}^{k}x_iy_i - \frac{\sum_{i=0}^{k}x_i\sum_{i=0}^{k}y_i}{k} -\frac{\sum_{i=0}^{k}x_i\sum_{i=0}^{k}y_i}{k} + \frac{\sum_{i=0}^{k}x_i\sum_{i=0}^{k}y_i}{k}\\
\qquad = \sum_{i=0}^{k}x_iy_i - \sum_{i=0}^{k}x_iV_y - \sum_{i=0}^{k}y_iV_x + \sum_{i=0}^{k}V_xV_y\\
\qquad = \sum_{i=0}^{k}(x_i - V_x)(y_i - V_y)\tag{23}
\end{array}
\]</span></p></li>
<li><p><span class="math inline">\(V_{xx}\)</span> <span class="math display">\[
\begin{array}{l}
V_{xx} = \sum_{i=0}^{k}x_i^2 - V_x\sum_{i=0}^{k}x_i\\
\qquad = \sum_{i=0}^{k}x_i^2 - 2\frac{\sum_{i=0}^{k}x_i\sum_{i=0}^{k}x_i}{k} + \frac{\sum_{i=0}^{k}x_i\sum_{i=0}^{k}x_i}{k}\\
\qquad =\sum_{i=0}^{k}x_i^2 - 2V_x\sum_{i=0}^{k}x_i + \sum_{i=0}^{k}V_xV_x\\
\qquad =\sum_{i=0}^{k}(x_i - V_x)^2 \tag{24}
\end{array}
\]</span></p></li>
<li><p><span class="math inline">\(V_{yy}\)</span></p></li>
</ul>
<p><span class="math display">\[
V_{yy} = \sum_{i=0}^{k}(y_i - V_y)^2 \tag{25}
\]</span></p>
<p>等式(22)可以表示为</p>
<p><span class="math display">\[
\cos2\theta*2*V_{xy} + \sin2\theta(V_{yy} - V_{xx}) = 0\tag{26}
\]</span></p>
<p>根据博客<a href="https://blog.csdn.net/zghforever/article/details/88644499">求解方程A<em>cos + B</em>sin = C</a>可知</p>
<p><span class="math display">\[
\theta = \arctan\frac{(V_{yy} - V_{xx}) - \sqrt{(V_{yy} - V_{xx})^2 + 4V_{xy}^2}}{2V_{xy}}\tag{27}
\]</span></p>
<p>根据数据集<span class="math inline">\(S_k\)</span>和等式(12)(27),可以求出最优的<span class="math inline">\(\theta\)</span>和<span class="math inline">\(r\)</span>参数。</p>
]]></content>
      <categories>
        <category>感知算法</category>
      </categories>
      <tags>
        <tag>特征提取</tag>
        <tag>超声波</tag>
      </tags>
  </entry>
  <entry>
    <title>超声波障碍物定位_库位中心</title>
    <url>/2019/11/12/%E6%84%9F%E7%9F%A5%E7%AE%97%E6%B3%95-%E8%B6%85%E5%A3%B0%E6%B3%A2%E9%9A%9C%E7%A2%8D%E7%89%A9%E5%AE%9A%E4%BD%8D-%E5%BA%93%E4%BD%8D%E4%B8%AD%E5%BF%83/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>垂直车位的检测存在许多技术上的瓶颈，通过超声波一次性检测很难达到较高的精度，而通过车辆泊车过程中的多次的库位定位，可以有效提高车位的定位精度。本文主要介绍垂直车位情形下，车辆已经进库的情形，如何通过辆边的障碍物，重新定位库位的中心。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/sYMfyTvGl5WFk6V.jpg" alt="菊花展" /><figcaption aria-hidden="true">菊花展</figcaption>
</figure>
<span id="more"></span>
<h2 id="数据处理">数据处理</h2>
<h3 id="概述-1">概述</h3>
<p>超声波的数据处理，主要将冗余的数据剔除和一些无效数据滤除。下面介绍了一些实际采用的超声波数据的滤波算法。</p>
<h3 id="原始数据">原始数据</h3>
<p>如下图所示，是车辆垂直进库过程中实际采集的数据，蓝色代表车辆左侧采集到的数据，橘黄色代表车辆右侧采集的数据。从图中可以看出，原始超声数据比较杂乱，很多无效数据都记录了下来。比如未检测到超声回波的数据，首先应该把这些无效数据滤除。 <img data-src="https://img-blog.csdnimg.cn/20190522172808439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnaGZvcmV2ZXI=,size_16,color_FFFFFF,t_70" alt="原始数据" /></p>
<h3 id="第一级滤波">第一级滤波</h3>
<p>如下图所示，是超声波数据第一级滤波后的结果，第一级滤波主要滤波无效的超声波数据，包括超声无回波的数据、超声回波幅值小于阀值的数据和车辆停止采集的冗余数据。将这些无效数据滤除后，得到如下比较整洁的数据图。图中绿色数据代表车辆后轴中心的轨迹坐标。虽然经过一级滤波后数据趋势有所改善，但仍然不便于直接进行线性拟合。因为图中存在车头的弧线段和一些突变边沿数据，所以数据还需进一步的滤波。 <img data-src="https://img-blog.csdnimg.cn/20190522173940224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnaGZvcmV2ZXI=,size_16,color_FFFFFF,t_70" alt="第一级滤波" /></p>
<h3 id="第二级滤波">第二级滤波</h3>
<p>如下图所示，是超声数据进行二级滤波后的效果。从图中可以看出二级滤波后，数据更加平滑，可以进行线性拟合。二级滤波的算法，主要采用数据的分布特性，提取数据中分布集中的数据点，将分散的数据剔除，这样就可以得到平滑的车辆边沿曲线，最后采用最小二乘法拟合直线。 <img data-src="https://img-blog.csdnimg.cn/2019052217495454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnaGZvcmV2ZXI=,size_16,color_FFFFFF,t_70" alt="第二级滤波" /> 根据库位边沿拟合的两个直线，求得新的中心线所在的直线，然后根据求得的中心线与车辆轨迹的偏差去调整车辆的入库轨迹。</p>
<h2 id="软件实现">软件实现</h2>
<h3 id="概述-2">概述</h3>
<p>软件实现部分使用<strong>Python</strong>进行前期的算法验证，利用python具有的强大的数学运算库，可以方便地进行前期的算法验证。</p>
<h3 id="代码实现">代码实现</h3>
<h4 id="第一级滤波-1">第一级滤波</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一级滤波</span></span><br><span class="line"><span class="comment"># 滤除无效的数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ValidDataProcess</span>(<span class="params">datx,daty,level,level_threshold</span>):   </span><br><span class="line">    valid_process_x = []</span><br><span class="line">    valid_process_y = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(level)):</span><br><span class="line">        <span class="keyword">if</span> level[i] &gt; level_threshold:</span><br><span class="line">            valid_process_x.append(datx[i])</span><br><span class="line">            valid_process_y.append(daty[i])</span><br><span class="line">    <span class="keyword">return</span> valid_process_x,valid_process_y</span><br></pre></td></tr></table></figure>
<h4 id="第二级滤波-1">第二级滤波</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第二级滤波</span></span><br><span class="line"><span class="comment"># 根据数据的分布特性滤除分布比较零散的数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">FitDataProcess</span>(<span class="params">datx,daty,threshold,step</span>):</span><br><span class="line">    valid_fit_x =[]</span><br><span class="line">    valid_fit_y =[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(daty)):</span><br><span class="line">        <span class="keyword">if</span> (daty[i] &gt;= threshold) <span class="keyword">and</span> (daty[i] &lt; (threshold + step)):</span><br><span class="line">            valid_fit_x.append(datx[i])</span><br><span class="line">            valid_fit_y.append(daty[i])</span><br><span class="line">    <span class="keyword">return</span> valid_fit_x,valid_fit_y</span><br></pre></td></tr></table></figure>
<h4 id="数据分布">数据分布</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#数值分布求取函数 该进版本v2</span></span><br><span class="line"><span class="keyword">def</span>  <span class="title function_">ValueDistributed_v2</span>(<span class="params">step,dat</span>):</span><br><span class="line">    <span class="comment">#获取数值范围</span></span><br><span class="line">    value_max = <span class="built_in">max</span>(dat)</span><br><span class="line">    value_min = <span class="built_in">min</span>(dat)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;最大值:&quot;</span>,value_max)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;最小值:&quot;</span>,value_min)</span><br><span class="line">    array_cnt = <span class="built_in">int</span>((value_max - value_min)/step) + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;分组数:&quot;</span>,array_cnt)</span><br><span class="line">    </span><br><span class="line">    DistributedCnt = np.zeros(array_cnt)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dat)):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,array_cnt):</span><br><span class="line">            <span class="keyword">if</span> (dat[v] &gt;= (value_min + step * i)) <span class="keyword">and</span> (dat[v] &lt; (value_min + step * (i+<span class="number">1</span>))):</span><br><span class="line">                DistributedCnt[i] = DistributedCnt[i] + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,array_cnt):           </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;分布:&quot;</span>,i,<span class="string">&quot;，值：&quot;</span>,DistributedCnt[i])</span><br><span class="line">    list_distribute_max_cnt = DistributedCnt.tolist()</span><br><span class="line">    distribute_max_cnt = list_distribute_max_cnt.index(<span class="built_in">max</span>(list_distribute_max_cnt))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;最高分布索引:&quot;</span>,distribute_max_cnt)</span><br><span class="line">    <span class="keyword">return</span> value_min + step * distribute_max_cnt</span><br></pre></td></tr></table></figure>
<h4 id="直线拟合函数的实现">直线拟合函数的实现</h4>
<p>使用Python的Scipy库中的optimize模块，可以实现一阶线性函数的拟合，具体使用如下： - 定义函数形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#直线方程函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f_1</span>(<span class="params">x, A, B</span>):</span><br><span class="line">    <span class="keyword">return</span> A*x + B</span><br></pre></td></tr></table></figure>
<ul>
<li>使用curve_fit方法实现 其中A1和B1就是所要求的系数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A1, B1 = optimize.curve_fit(f_1, valid_fit_11x, valid_fit_11y)[<span class="number">0</span>]</span><br><span class="line">x1 = np.arange(-<span class="number">7</span>,<span class="number">5</span>,<span class="number">0.1</span>)</span><br><span class="line">y1 = A1 * x1 + B1</span><br></pre></td></tr></table></figure>
<p>为了后期便于移植到C++/C平台，基于Python语言，实现了简单的直线最小二乘法拟合算法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一阶线性函数的拟合，采用最小二乘法</span></span><br><span class="line"><span class="comment"># 拟合函数形式:y = a*x +b</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">LineFit</span>(<span class="params">x,y</span>):</span><br><span class="line">    sum_x = <span class="built_in">sum</span>(x)</span><br><span class="line">    sum_y = <span class="built_in">sum</span>(y)</span><br><span class="line">    sum_xy = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)):</span><br><span class="line">        sum_xy = sum_xy + x[i]*y[i]</span><br><span class="line">    sum_x2 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)):</span><br><span class="line">        sum_x2 = sum_x2 + x[i]*x[i]</span><br><span class="line">    sum_n = <span class="built_in">len</span>(x)</span><br><span class="line">    <span class="comment"># 分母</span></span><br><span class="line">    Denominator = sum_n*sum_x2 - sum_x*sum_x</span><br><span class="line">    <span class="comment"># 分子</span></span><br><span class="line"> 	molecule_a = sum_n*sum_xy - sum_x*sum_y</span><br><span class="line">    molecule_b = sum_x2*sum_y - sum_x*sum_xy</span><br><span class="line">    <span class="keyword">return</span> molecule_a/Denominator,molecule_b/Denominator</span><br></pre></td></tr></table></figure>
<p>关于曲线拟合的具体内容可以参照<a href="https://blog.csdn.net/zghforever/article/details/90295051">最小二乘法的线性拟合</a>。</p>
<h4 id="最后的实现">最后的实现</h4>
<ol type="1">
<li>使用<strong>ValidDataProcess</strong>进行一级滤波</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">valid_process_11x,valid_process_11y = ValidDataProcess(GroundLocation_x11,GroundLocation_y11,LRU11_UltrasonicLevel,level_threadhold)</span><br><span class="line">valid_process_12x,valid_process_12y = ValidDataProcess(GroundLocation_x12,GroundLocation_y12,LRU12_UltrasonicLevel,level_threadhold)  </span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>使用<strong>ValueDistributed_v2</strong>函数，求取数据分布</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DistributeValue_11y = ValueDistributed_v2(<span class="number">0.05</span>,valid_process_11y)</span><br><span class="line">DistributeValue_12y = ValueDistributed_v2(<span class="number">0.05</span>,valid_process_12y)</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>根据分布特性，使用<strong>FitDataProcess</strong>进行二级滤波</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">valid_fit_11x,valid_fit_11y = FitDataProcess(valid_process_11x,valid_process_11y,DistributeValue_11y,<span class="number">0.05</span>)</span><br><span class="line">valid_fit_12x,valid_fit_12y = FitDataProcess(valid_process_12x,valid_process_12y,DistributeValue_12y,<span class="number">0.05</span>)</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>使用二级滤波的数据，进行线性拟合，求得直线方程</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A1, B1 = LineFit(valid_fit_11x, valid_fit_11y)</span><br><span class="line">A2, B2 = LineFit(valid_fit_12x, valid_fit_12y)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>超声波</tag>
        <tag>感知算法</tag>
        <tag>障碍物定位</tag>
        <tag>库位中心</tag>
      </tags>
  </entry>
  <entry>
    <title>超声波障碍物定位-库位角点</title>
    <url>/2019/11/11/%E6%84%9F%E7%9F%A5%E7%AE%97%E6%B3%95-%E8%B6%85%E5%A3%B0%E6%B3%A2%E9%9A%9C%E7%A2%8D%E7%89%A9%E5%AE%9A%E4%BD%8D-%E5%BA%93%E4%BD%8D%E8%A7%92%E7%82%B9/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>基于纯超声的垂直车位检测存在一些技术瓶颈，比如超声波的更新频率较低、探测开角较大等，都是影响检测精度的关键因素。另外对于垂直车位，车辆头部情况复杂、存在各种结构的进气栅格、引擎盖的高度不一等，增大了超声检测的难度。基于上述传感器本身性能限制和探测环境的复杂性，一次性精确检测很难实现，目前常规算法检测精度大概在30cm左右。为了进一步提升超声波检测的精度，利用车辆泊车过程中的检测的超声数据，重新进行库位的定位。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/eSXfcn2BYoTNR4K.jpg" alt="世纪公园" /><figcaption aria-hidden="true">世纪公园</figcaption>
</figure>
<span id="more"></span>
<h2 id="超声重定位">超声重定位</h2>
<h3 id="概述-1">概述</h3>
<p>首先车辆先通过超声波传感器确定车位的大概位置，然后规划车辆进行倒车入库，在入库的过程中，进行前车车头边沿的重新检测，并通过尾部超声波进行后车的检测，当车辆离后车距离达到30~40cm时，车辆停止。通过后置的短距超声波，使用三角定位算法实现，进行后车边沿数据的采集。等待数据量足够时，一般可以设定50个数据点左右。停止超声数据的推送，开始进行边沿算法的计算，从而实现垂直车位的二次定位。</p>
<p><img data-src="https://i.loli.net/2021/08/30/mC9TIKJhZdqGfMB.png" /></p>
<h3 id="数据滤波">数据滤波</h3>
<h4 id="状态滤波">状态滤波</h4>
<p>传感器本身会输出一些状态信号，如噪声干扰、硬件故障、盲区、振玲故障、通信故障和正常等状态。可以通过传感器输出的这些状态信号进行数据的一级滤波，只保留状态输出为正常的信号。</p>
<h4 id="幅值滤波">幅值滤波</h4>
<p>超声波的<strong>Level</strong>值反应了声波的回波强度，因此可以使用回波强度的大小，去滤除一部分无效信号，比如回波为0值数据。这些数据反应了未探测到障碍物，或者是障碍物的特殊结构反射了声波，特殊的材料吸收了声波。 比如某些车型的车头设计有很大的进气栅格，这种结构就会减少反射声波的强度，从而导致强度降低。</p>
<p><img data-src="https://i.loli.net/2021/08/30/OVlckaCFD34UqPY.png" alt="幅值滤波" style="zoom: 80%;" /></p>
<p>当超声波探测到车辆边沿时，此时由于很多回波反射方向变化，所以传感器接收到的强度变低。</p>
<p><img data-src="https://i.loli.net/2021/08/30/M9wzFi37mrlEYku.png" style="zoom:80%;" /></p>
<p>通过一系列的滤波操作，可以得出以下图形。其中蓝色是滤波前的原始数据，黄色是滤波后的数据。可以从下图看出，通过滤波操作可以滤除一些无效信号点。 <img data-src="https://img-blog.csdnimg.cn/20190513171545723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnaGZvcmV2ZXI=,size_16,color_FFFFFF,t_70" alt=""  /></p>
<hr />
<h3 id="边沿检测">边沿检测</h3>
<h4 id="概述-2">概述</h4>
<p>对原始数据进行处理后，可以得到一组有效的超声信号，基于这组数据，可以进行车辆边沿的检测。</p>
<h4 id="距离疏密程度">距离疏密程度</h4>
<p>由于所有的坐标点都已经转化到了地面坐标系下，所以只需要进行x方向的疏密度分析。从下图可知，在车辆边沿处，点比较稀疏，有的地方存在很长一段距离无数据点。这种情况一般是车头处存在镂空的结构，或者声波发生了散射，导致声波强度减小。所以在确定车辆边沿点时，需设置一个疏密距离阀值，当距离值大于阀值时，才认为该点是边界的跳变点。 <img data-src="https://img-blog.csdnimg.cn/20190513192450664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnaGZvcmV2ZXI=,size_16,color_FFFFFF,t_70" /></p>
<h3 id="数据分布">数据分布</h3>
<p>对于后车的边沿定位，使用的是车辆后方的短距传感器，该传感器使用三角定位原理，确定后车边沿的坐标值。可以从图中看出，图片左侧数据点描绘的是后车的边沿，可以通过数据的分布情况，及集中程度，确定最有可能车辆边沿的值。 <img data-src="https://img-blog.csdnimg.cn/20190513194816201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnaGZvcmV2ZXI=,size_16,color_FFFFFF,t_70" /> 如下图所示，是对上图x轴做了数值分布分析，可以看出，大部分点的x轴坐标都分布于区域5中，所以最后取区域5中的点作为可信的坐标点。 <img data-src="https://img-blog.csdnimg.cn/20190513201643149.PNG#pic_center" /></p>
<h2 id="结论">结论</h2>
]]></content>
      <categories>
        <category>感知算法</category>
        <category>超声波</category>
      </categories>
      <tags>
        <tag>超声波</tag>
        <tag>感知算法</tag>
        <tag>障碍物定位</tag>
        <tag>库位角点</tag>
      </tags>
  </entry>
  <entry>
    <title>霍夫变换-OpenCV源码分析</title>
    <url>/2019/10/20/%E6%84%9F%E7%9F%A5%E7%AE%97%E6%B3%95-%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2(Hough)-OpenCV%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>霍夫变换算法主要用于图像中的特征匹配，常见的应用场景是进行图像中的直线或者圆形的识别。该算法的原理就是实现笛卡尔空间到霍夫空间的转换，将在笛卡尔空间下难以判定的特性，转到霍夫空间，从而将问题简化。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/hyaDQrwBu37YFfJ.jpg" alt="世纪公园" /><figcaption aria-hidden="true">世纪公园</figcaption>
</figure>
<span id="more"></span>
<h2 id="分析">分析</h2>
<h3 id="建立三角函数查找表">建立三角函数查找表</h3>
<p>为了避免三角函数的反复计算，根据离散后的角度信息，提前计算出所需的三角函数值。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">createTrigTable</span><span class="params">( <span class="type">int</span> numangle, <span class="type">double</span> min_theta, <span class="type">double</span> theta_step,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">float</span> irho, <span class="type">float</span> *tabSin, <span class="type">float</span> *tabCos )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> ang = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(min_theta);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n = <span class="number">0</span>; n &lt; numangle; ang += (<span class="type">float</span>)theta_step, n++ )</span><br><span class="line">    &#123;</span><br><span class="line">        tabSin[n] = (<span class="type">float</span>)(<span class="built_in">sin</span>((<span class="type">double</span>)ang) * irho);</span><br><span class="line">        tabCos[n] = (<span class="type">float</span>)(<span class="built_in">cos</span>((<span class="type">double</span>)ang) * irho);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="计算离散点数">计算离散点数</h3>
<p>根据极经和极角的步长，极经和极角的范围，计算离散点数。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> numangle = <span class="built_in">cvRound</span>((max_theta - min_theta) / theta);</span><br><span class="line"><span class="type">int</span> numrho = <span class="built_in">cvRound</span>(((max_rho - min_rho) + <span class="number">1</span>) / rho);</span><br></pre></td></tr></table></figure></p>
<h3 id="填充累加器">填充累加器</h3>
<p>计算图像中每个像素点的霍夫变换，其中极角<span class="math inline">\(\theta\)</span>按照离散化的点采样，计算极经值<code>rho</code>，并更新对应的累加器<code>accum</code>的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stage 1. fill accumulator</span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; height; i++ )</span><br><span class="line">    <span class="keyword">for</span>( j = <span class="number">0</span>; j &lt; width; j++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( image[i * step + j] != <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> n = <span class="number">0</span>; n &lt; numangle; n++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> r = <span class="built_in">cvRound</span>( j * tabCos[n] + i * tabSin[n] );</span><br><span class="line">                r += (numrho - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                accum[(n+<span class="number">1</span>) * (numrho+<span class="number">2</span>) + r+<span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找局部极大值">查找局部极大值</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">findLocalMaximums</span><span class="params">( <span class="type">int</span> numrho, <span class="type">int</span> numangle, <span class="type">int</span> threshold,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">const</span> <span class="type">int</span> *accum, std::vector&lt;<span class="type">int</span>&gt;&amp; sort_buf )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> r = <span class="number">0</span>; r &lt; numrho; r++ )</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n = <span class="number">0</span>; n &lt; numangle; n++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> base = (n+<span class="number">1</span>) * (numrho+<span class="number">2</span>) + r+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>( accum[base] &gt; threshold &amp;&amp;</span><br><span class="line">                accum[base] &gt; accum[base - <span class="number">1</span>] &amp;&amp; accum[base] &gt;= accum[base + <span class="number">1</span>] &amp;&amp;</span><br><span class="line">                accum[base] &gt; accum[base - numrho - <span class="number">2</span>] &amp;&amp; accum[base] &gt;= accum[base + numrho + <span class="number">2</span>] )</span><br><span class="line">                sort_buf.<span class="built_in">push_back</span>(base);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="排序">排序</h3>
<p>对累加器内部的数据进行排序，由大到小进行排序。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stage 3. sort the detected lines by accumulator value</span></span><br><span class="line">std::<span class="built_in">sort</span>(_sort_buf.<span class="built_in">begin</span>(), _sort_buf.<span class="built_in">end</span>(), <span class="built_in">hough_cmp_gt</span>(accum));</span><br></pre></td></tr></table></figure></p>
<h3 id="输出直线">输出直线</h3>
<p>根据设定的最小直线数量和实际缓存的直线数量，求取最小的直线数。根据直线数从排过序的缓存中取最大的几组数据，并将这些数据转换成直线参数存储。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stage 4. store the first min(total,linesMax) lines to the output buffer</span></span><br><span class="line">   linesMax = std::<span class="built_in">min</span>(linesMax, (<span class="type">int</span>)_sort_buf.<span class="built_in">size</span>());</span><br><span class="line">   <span class="type">double</span> scale = <span class="number">1.</span>/(numrho+<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">   lines.<span class="built_in">create</span>(linesMax, <span class="number">1</span>, type);</span><br><span class="line">   Mat _lines = lines.<span class="built_in">getMat</span>();</span><br><span class="line">   <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; linesMax; i++ )</span><br><span class="line">   &#123;</span><br><span class="line">       LinePolar line;</span><br><span class="line">       <span class="type">int</span> idx = _sort_buf[i];</span><br><span class="line">       <span class="type">int</span> n = <span class="built_in">cvFloor</span>(idx*scale) - <span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> r = idx - (n+<span class="number">1</span>)*(numrho+<span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">       line.rho = (r - (numrho - <span class="number">1</span>)*<span class="number">0.5f</span>) * rho;</span><br><span class="line">       line.angle = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(min_theta) + n * theta;</span><br><span class="line">       <span class="keyword">if</span> (type == CV_32FC2)</span><br><span class="line">       &#123;</span><br><span class="line">           _lines.<span class="built_in">at</span>&lt;Vec2f&gt;(i) = <span class="built_in">Vec2f</span>(line.rho, line.angle);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">CV_DbgAssert</span>(type == CV_32FC3);</span><br><span class="line">           _lines.<span class="built_in">at</span>&lt;Vec3f&gt;(i) = <span class="built_in">Vec3f</span>(line.rho, line.angle, (<span class="type">float</span>)accum[idx]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<ol type="1">
<li><a href="https://github.com/opencv/opencv/blob/4.1.1/modules/imgproc/src/hough.cpp">GitHub源码</a></li>
<li><a href="https://docs.opencv.org/4.1.1/dd/d1a/group__imgproc__feature.html#ga46b4e588934f6c8dfd509cc6e0e4545a">文档说明</a></li>
</ol>
]]></content>
      <categories>
        <category>感知算法</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
        <tag>霍夫变换</tag>
      </tags>
  </entry>
  <entry>
    <title>控制算法-Stanley法</title>
    <url>/2020/02/23/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-Stanley%E6%B3%95/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>本文主要介绍Stanley方法的推导，该方法也称为前轮位置反馈。该方法基于车辆几何关系，算法简单，适合低速下的车辆路劲跟踪。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/hk7PBu8asVmbpox.jpg" alt="扬州廋西湖" /><figcaption aria-hidden="true">扬州廋西湖</figcaption>
</figure>
<span id="more"></span>
<h2 id="stanley方法">Stanley方法</h2>
<p><img data-src="https://i.loli.net/2021/08/30/kVdqQai6KhGrelT.png" style="zoom:80%;" /></p>
<p>Stanley方法是一种基于航迹误差<span class="math inline">\(e_{f}\)</span>的非线性反馈函数,该航向误差是车辆前轴中心点与目标路径最近点<span class="math inline">\((c_x,c_y)\)</span>的距离。由上图几何关系得</p>
<p><span class="math display">\[
\psi_e = \psi - \psi_{t} \tag{1}
\]</span></p>
<p>其中，<span class="math inline">\(\psi\)</span>表示车辆横向角，<span class="math inline">\(\psi_{t}\)</span>表示离车辆前轴中心最近目标路径点处的航向角。</p>
<p>前轮速度轴与目标路径航向之间的夹角<span class="math inline">\(\beta\)</span>为</p>
<p><span class="math display">\[
\beta = \arcsin(\frac{k\cdot e_{f}}{v_x}) \tag{2}
\]</span></p>
<p>但是在论文中都是使用反正切函数求<span class="math inline">\(\beta\)</span>角，可能原因是系数<span class="math inline">\(k\)</span>可以任意选择，选择可是的系数<span class="math inline">\(k\)</span>，确实可以转化为</p>
<p><span class="math display">\[
\beta = \arctan(\frac{k\cdot e_{f}}{v_x}) \tag{3}
\]</span></p>
<p>结合等式(1)和(3)得</p>
<p><span class="math display">\[
\begin{array}{cl}
\delta &amp;= \psi_e + \beta \\
&amp;= \psi - \psi_{t} +  \arctan(\dfrac{k\cdot e_{f}}{v_x})
\end{array}\tag{4}
\]</span></p>
]]></content>
      <categories>
        <category>控制算法</category>
        <category>路径跟踪</category>
      </categories>
      <tags>
        <tag>前轴反馈</tag>
        <tag>路径跟踪</tag>
        <tag>控制算法</tag>
      </tags>
  </entry>
  <entry>
    <title>控制算法-动力学模型</title>
    <url>/2019/12/02/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-%E5%8A%A8%E5%8A%9B%E5%AD%A6%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>当车辆速度很高时，单车模型中前后轮的速度矢量不再与轮子方向一致。此时运动学模型就不能准确地描述车辆的运动状态，这就需要使用动力学模型对车辆进行建模。车辆单车模型中需要考虑两个维度的信息，这两个维度分别指代表车辆横向位置信息的<span class="math inline">\(y\)</span>和表示车辆偏航角信息的<span class="math inline">\(\psi\)</span>。下面分析过程中，先不考虑路堤角度的影响。 <img data-src="https://i.loli.net/2021/08/30/fQ7RUE9SO6ADnXN.jpg" alt="菊花展" /></p>
<span id="more"></span>
<h2 id="受力分析">受力分析</h2>
<h3 id="平动">平动</h3>
<p>首先假设车辆为一个质点，对该质点进行受力分析，并根据牛顿第二定律得</p>
<p><span class="math display">\[
ma_y = F_{yf}+F_{yr} \tag{1}
\]</span></p>
<p>其中，<span class="math inline">\(a_y\)</span>为车辆重心处<span class="math inline">\(y\)</span>轴方向的惯性加速度，<span class="math inline">\(F_{yf}\)</span>和<span class="math inline">\(F_{yr}\)</span>为前后轮横向受到的力。平动过程中，有两种力共同作用于加速度<span class="math inline">\(a_y\)</span>：车辆延<span class="math inline">\(y\)</span>轴产生的惯性加速度<span class="math inline">\(\ddot{y}\)</span>和车辆绕旋转中心<span class="math inline">\(O\)</span>旋转产生的向心加速度<span class="math inline">\(a_c=V_x\dot{\psi}\)</span>。</p>
<p><span class="math display">\[
a_y = \ddot{y} + V_x\dot{\psi} \tag{2}
\]</span></p>
<p>将公式(2)带入公式(1)得</p>
<p><span class="math display">\[
m(\ddot{y} + V_x\dot{\psi}) = F_{yf}+F_{yr} \tag{3}
\]</span></p>
<h3 id="转动">转动</h3>
<p>假设车辆为刚体，刚体绕重心转动，该运动过程使用力矩和转动惯量进行描述。 车辆绕z轴旋转产生的力矩平衡，对应的偏航动力学方程为</p>
<p><span class="math display">\[
I_z\ddot{\psi} = l_fF_{yf} - l_rF_{yr} \tag{4}
\]</span></p>
<p>其中，<span class="math inline">\(l_f\)</span>和<span class="math inline">\(l_r\)</span>代表前后轮胎到重心的距离。</p>
<h3 id="受力计算">受力计算</h3>
<p>上述等式(3)和(4)中都用到了轮胎横向受力情况<span class="math inline">\(F_{yf}\)</span>和<span class="math inline">\(F_{yr}\)</span>，根据实验结果知，轮胎的横向力与小的滑移角存在正比例的关系,滑移角是轮胎方向与车轮速度矢量之间的夹角。</p>
<p><img data-src="https://i.loli.net/2021/08/30/zaCvGEqUsRDNJ8X.png" style="zoom: 67%;" /></p>
<p>根据上图可知 <span class="math display">\[
\alpha_f = \delta - \theta_{Vf} \tag{5}
\]</span></p>
<p>其中，<span class="math inline">\(\theta_{Vf}\)</span>代表速度矢量与车辆纵轴的夹角，<span class="math inline">\(\delta\)</span>代表前轮转向角。 同理，由于后轮转向角<span class="math inline">\(\delta\)</span>为0，故后轮滑移角为</p>
<p><span class="math display">\[
\alpha_r = -\theta_{Vr} \tag{6}
\]</span></p>
<p>车辆前轮的横向力可以表示为</p>
<p><span class="math display">\[
F_{yf} = 2C_{\alpha f}(\delta - \theta_{Vf} ) \tag{7}
\]</span></p>
<p>其中，比例常数<span class="math inline">\(C_{\alpha f}\)</span>代表每个前轮的侧偏刚度。</p>
<p>同理后轮的横向力可以写为</p>
<p><span class="math display">\[
F_{yr} = 2C_{\alpha r}(-\theta_{Vr}) \tag{8}
\]</span></p>
<p>其中，比例常数<span class="math inline">\(C_{\alpha r}\)</span>代表每个后轮的侧偏刚度。</p>
<h3 id="速度方向">速度方向</h3>
<p><img data-src="https://i.loli.net/2021/08/30/qBMO6K81ZVT2QNt.png" /></p>
<p>车辆平动产生的速度分量<span class="math inline">\(V_x\)</span>和<span class="math inline">\(V_y\)</span>，以及绕点<span class="math inline">\(C\)</span>转动产生的线速度<span class="math inline">\(l_f\dot{\psi}\)</span>和<span class="math inline">\(l_r\dot{\psi}\)</span>组成。根据上图得</p>
<p><span class="math display">\[
\tan(\theta_{Vf})=\frac{V_y + l_f\dot{\psi}}{V_x} \tag{9}
\]</span></p>
<p><span class="math display">\[
\tan(\theta_{Vr})=\frac{V_y - l_r\dot{\psi}}{V_x} \tag{10}
\]</span></p>
<p>由于通常情况下速度矢量的夹角很小，可以使用小角度近似原理得 <span class="math display">\[
\theta_{Vf}=\frac{\dot{y} + l_f\dot{\psi}}{V_x} \tag{11}
\]</span></p>
<p><span class="math display">\[
\theta_{Vr}=\frac{\dot{y} - l_r\dot{\psi}}{V_x} \tag{12}
\]</span></p>
<h2 id="微分方程">微分方程</h2>
<p>将等式(7)、(8)、(9)和(10)代入等式(3)中得</p>
<p><span class="math display">\[
m(\ddot{y} + V_x\dot{\psi}) = 2C_{\alpha f}(\delta - \frac{\dot{y} + l_f\dot{\psi}}{V_x} ) +2C_{\alpha r}(-\frac{\dot{y} - l_r\dot{\psi}}{V_x}) \tag{13}
\]</span></p>
<p>等式(13)左右两边同时除以<span class="math inline">\(m\)</span>，分别提取 <span class="math inline">\(\ddot{y}\)</span>、<span class="math inline">\(\dot{y}\)</span>、<span class="math inline">\(\dot{\psi}\)</span>和<span class="math inline">\(\delta\)</span>项得</p>
<p><span class="math display">\[
\ddot{y} = -\frac{2C_{\alpha f } + 2C_{\alpha r}}{mV_x}\dot{y}   - ( V_x +  \frac{2C_{\alpha f}l_f- 2C_{\alpha r}l_r}{mV_x})\dot{\psi}  + \frac{2C_{\alpha f}}{m} \delta \tag{14}
\]</span></p>
<p>转化为矩阵形式如下</p>
<p><span class="math display">\[
\frac{\mathrm{d}}{\mathrm{d}t} \dot{y} = 
\begin{bmatrix}
0 &amp; -\dfrac{2C_{\alpha f } + 2C_{\alpha r}}{mV_x} &amp; 0 &amp; - ( V_x +  \dfrac{2C_{\alpha f}l_f- 2C_{\alpha r}l_r}{mV_x})
\end{bmatrix}
 \begin{bmatrix}
y\\
\dot{y}\\
\psi\\
\dot{\psi}
\end{bmatrix} + \frac{2C_{\alpha f}}{m}\delta \tag{15}
\]</span></p>
<p>同理，将等式(7)、(8)、(9)和(10)代入等式(4)中得</p>
<p><span class="math display">\[
I_z\ddot{\psi} = 2l_fC_{\alpha f}(\delta - \frac{\dot{y} + l_f\dot{\psi}}{V_x} )  - 2l_rC_{\alpha r}(-\frac{\dot{y} - l_r\dot{\psi}}{V_x}) \tag{16}
\]</span></p>
<p>等式(13)左右两边同时除以<span class="math inline">\(I_z\)</span>，分别提取<span class="math inline">\(\dot{y}\)</span>、 <span class="math inline">\(\ddot{\psi}\)</span>、<span class="math inline">\(\dot{\psi}\)</span>和<span class="math inline">\(\delta\)</span>项得</p>
<p><span class="math display">\[
\ddot{\psi} = - \frac{2l_fC_{\alpha f} - 2l_rC_{\alpha r}}{I_zV_x}\dot{y}  - \frac{2{l_f}^2C_{\alpha f} + 2{l_r}^2C_{\alpha r}}{I_zV_x}\dot{\psi} + \frac{2l_fC_{\alpha f}}{I_z}\delta\tag{17}
\]</span></p>
<p>等效的矩阵形式为</p>
<p><span class="math display">\[
\frac{\mathrm{d}}{\mathrm{d}t} \dot{\psi} = 
\begin{bmatrix}
0 &amp; - \dfrac{2l_fC_{\alpha f} - 2l_rC_{\alpha r}}{I_zV_x} &amp; 0 &amp; -\dfrac{2{l_f}^2C_{\alpha f} + 2{l_r}^2C_{\alpha r}}{I_zV_x}
\end{bmatrix}
 \begin{bmatrix}
y\\
\dot{y}\\
\psi\\
\dot{\psi}
\end{bmatrix} + \frac{2l_fC_{\alpha f}}{I_z}\delta \tag{18}
\]</span></p>
<p>根据等式(15)和(18)得</p>
<p><span class="math display">\[
\frac{\mathrm{d}}{\mathrm{d}t}\left \{ \begin{array}{cccc}
y\\
\dot{y}\\
\psi\\
\dot{\psi}
\end{array} \right\} =  
\begin{bmatrix}
0 &amp; 1 &amp; 0 &amp; 0\\
0 &amp; -\dfrac{2C_{\alpha f } + 2C_{\alpha r}}{mV_x} &amp; 0 &amp; - ( V_x +  \dfrac{2C_{\alpha f}l_f- 2C_{\alpha r}l_r}{mV_x})\\
0 &amp; 0 &amp; 0 &amp; 1\\
0 &amp; - \dfrac{2l_fC_{\alpha f} - 2l_rC_{\alpha r}}{I_zV_x} &amp; 0 &amp; -\dfrac{2{l_f}^2C_{\alpha f} + 2{l_r}^2C_{\alpha r}}{I_zV_x}
\end{bmatrix}
\begin{bmatrix}
y\\
\dot{y}\\
\psi\\
\dot{\psi}
\end{bmatrix}\\+
\begin{bmatrix}
0\\
\dfrac{2C_{\alpha f}}{m}\\
0\\
 \dfrac{2l_fC_{\alpha f}}{I_z}
\end{bmatrix}\delta \tag{19}
\]</span></p>
<ul>
<li>注意：上述动力学方程的推导建立在车辆滑移角很小的情况下，这时的轮胎作用力与滑移角可以近似为线性关系。当滑移角很大时，轮胎作用力与滑移角就不再是线性关系。</li>
</ul>
<h2 id="参考">参考</h2>
<ol type="1">
<li>“vehicle dynamics and control”</li>
</ol>
]]></content>
      <categories>
        <category>控制算法</category>
        <category>车辆模型</category>
      </categories>
      <tags>
        <tag>动力学</tag>
        <tag>车辆模型</tag>
        <tag>dynamics model</tag>
        <tag>车辆控制</tag>
      </tags>
  </entry>
  <entry>
    <title>控制算法-后轮位置反馈</title>
    <url>/2020/02/26/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-%E5%90%8E%E8%BD%AE%E4%BD%8D%E7%BD%AE%E5%8F%8D%E9%A6%88/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>本文介绍一种使用后轮位置反馈的路径跟踪算法，使用李亚普洛夫稳定判据，推导控制率。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/2lkhLy4KTODtR56.jpg" alt="黄山" /><figcaption aria-hidden="true">黄山</figcaption>
</figure>
<span id="more"></span>
<h2 id="误差">误差</h2>
<p><img data-src="https://i.loli.net/2021/08/30/yxLlDEZFpgoi5cj.png" alt="后轮位置跟踪示意图" style="zoom:80%;" /></p>
<h3 id="位置误差">位置误差</h3>
<p>关于位置误差的计算，首先搜寻参考路径与车辆后轴中心距离最近的点：</p>
<p><span class="math display">\[
s(t) = arg\min_{\gamma}\|\bigl(x_r(t),y_r(t)\bigr)-\bigl(x_{ref}(\gamma),y_{ref}(\gamma)\bigr) \| \tag{1}
\]</span></p>
<p>其中，<span class="math inline">\(\bigl(x_r(t),y_r(t)\bigr)\)</span>代表<span class="math inline">\(t\)</span>时刻车辆后轴中心位置坐标，<span class="math inline">\(\bigl(x_{ref}(\gamma),y_{ref}(\gamma)\bigr)\)</span>代表参考路径上离车辆后轴距离最近点的位置坐标，<span class="math inline">\(s(t)\)</span>代表<span class="math inline">\(t\)</span>时刻与车辆后轴中心点距离最近参考路径点的位置参数<span class="math inline">\(\gamma\)</span>。</p>
<p>关于参考路径在<span class="math inline">\(s(t)\)</span>参数处的单位切向量为</p>
<p><span class="math display">\[
\hat{t}=
\frac{
\Bigl(\dfrac{\partial x_{ref}}{\partial s}\|_{s(t)},\dfrac{\partial y_{ref}}{ \partial s}\|_{s(t)}
\Bigr)}
{\Bigg\|
\Bigl(\dfrac{ \partial x_{ref}\bigl(s(t)\bigr)}{ \partial s},\dfrac{ \partial y_{ref}\bigl(s(t)\bigr)}{ \partial s}\Bigr)
\Biggr\|}
=(t_x,t_y) \tag{2}
\]</span></p>
<p>跟踪误差向量表示如下：</p>
<p><span class="math display">\[
\vec{d}(t)=\Bigl(x_r(t) - x_{ref}\bigl(s(t)\bigr),y_r(t) - y_{ref}\bigl(s(t)\bigr)\Bigr)=(d_x,d_y)\tag{3}
\]</span></p>
<p>所以跟踪误差向量<span class="math inline">\(\vec{d}\)</span>和参考路径上最近点的单位切向量<span class="math inline">\(\hat{t}\)</span>的向量积为</p>
<p><span class="math display">\[
\vec{e} = \hat{t} \times \vec{d} = 
\left\lvert 
\begin{array}{cl}
x &amp; y\\
t_x &amp; t_y\\
d_x &amp; d_y
\end{array}
\right\rvert=t_xd_y - t_yd_x \tag{4}
\]</span></p>
<h3 id="角度误差">角度误差</h3>
<p>关于车辆航向向量与目标路径切向量的夹角<span class="math inline">\(\psi_e\)</span>如下：</p>
<p><span class="math display">\[
\psi_e(t)=\psi-\arctan2(\frac{ \partial y_{ref}\bigl(s(t)\bigr)}{ \partial s},\frac{ \partial x_{ref}\bigl(s(t)\bigr)}{ \partial s}) \tag{5}
\]</span></p>
<h2 id="微分方程">微分方程</h2>
<h3 id="参考曲线最近点">参考曲线最近点</h3>
<p>关于参考曲线与车辆后轴中心最近点处的速度<span class="math inline">\(\dot{s}(t)\)</span>可以通过下图求得</p>
<p><img data-src="https://i.loli.net/2021/08/30/YbBKN6kUmxnAuWL.png" alt="最近点" style="zoom:80%;" /></p>
<p>如上图所示，车辆沿目标路径顺时针运动，点<span class="math inline">\(O\)</span>代表当前目标曲线点对应的旋转中心。很明显此时曲率为负值，即<span class="math inline">\(R &lt; 0\)</span>。根据矢量叉乘性质得，<span class="math inline">\(e &gt; 0\)</span>。假设以点<span class="math inline">\(O\)</span>为旋转中心的车辆后轴中心角速度<span class="math inline">\(\omega_r\)</span>和最近参考路径点处的角速度<span class="math inline">\(\omega_s\)</span>近似相等，得</p>
<p><span class="math display">\[
\omega_r = \omega_s &lt; 0\tag{6}
\]</span></p>
<p>根据车辆旋转角速度的计算等式<span class="math inline">\(\frac{V}{R}\)</span>，结合等式(6)得</p>
<p><span class="math display">\[
\frac{v_{rx}}{R-e} = \frac{\dot{s}}{R} \tag{7}
\]</span></p>
<p>故<span class="math inline">\(\dot{s}\)</span>结果如下</p>
<p><span class="math display">\[
\dot{s} = \frac{R \cdot v_{rx}}{R - e}=\frac{v_{r}\cdot\cos(\psi_e)}{1-k(s)e}\tag{8}
\]</span></p>
<h3 id="横向误差">横向误差</h3>
<p>车辆横向移动的速度<span class="math inline">\(\dot{e}\)</span>可以表示如下：</p>
<p><span class="math display">\[
\dot{e} = v_r \cdot \sin(\psi_e)\tag{9}
\]</span></p>
<h3 id="航向角误差">航向角误差</h3>
<p>关于车辆航向角误差的变化率表示如下：</p>
<p><span class="math display">\[
\begin{array}{cl}
\dot{\psi_e} &amp;= \dot{\psi} - \dot{\psi_{ref}} \\
&amp;= \dot{\psi} - \dot{s}\cdot k(s)\\
&amp;=\dot{\psi} - \dfrac{v_{r}\cdot\cos(\psi_e)\cdot k(s)}{1-k(s)e}
\end{array}\tag{10}
\]</span></p>
<h3 id="综述">综述</h3>
<p>基于上述参考曲线处的速度、横向误差变化率和航向角误差变化率，整理如下微分方程形式：</p>
<p><span class="math display">\[
\begin{array}{cl}
\dot{s} &amp;= \dfrac{v_{r}\cdot\cos(\psi_e)}{1-k(s)e}\\
\dot{e} &amp;= v_r \cdot \sin(\psi_e)\\
\dot{\psi_e} &amp;=\dot{\psi} - \dfrac{v_{r}\cdot\cos(\psi_e)\cdot k(s)}{1-k(s)e}
\end{array}\tag{11}
\]</span></p>
<h2 id="李亚普洛夫稳定判据">李亚普洛夫稳定判据</h2>
<h3 id="lyapunov函数">Lyapunov函数</h3>
<p>基于上述微分方程，定义李亚普洛夫函数形式如下：</p>
<p><span class="math display">\[
V(e,\psi_e) = \frac{1}{2}e^2 + \frac{1}{2k_2}\psi_e^2 \tag{12}
\]</span></p>
<p>其中<span class="math inline">\(k_2 &gt; 0\)</span>，为了使<span class="math inline">\((e,\psi_e)\)</span>在平衡点<span class="math inline">\((0,0)\)</span>处稳定，根据李亚普洛夫稳定判据，必须满足一下两个条件：</p>
<ol type="1">
<li><span class="math inline">\(\lim_{\rvert e,\psi_e \rvert \to \infty}V = \infty\)</span></li>
<li><span class="math inline">\(\begin{array}{rl}\dot{V} &lt; 0 &amp;(e \neq 0,\psi_e \neq 0)\end{array}\)</span></li>
</ol>
<p>对于条件1，等式(12)明显成立，所以李亚普洛夫稳定判据第一条满足。</p>
<p>对于<span class="math inline">\(\dot{V}\)</span>,结合等式(11)的微分方程，推导形式如下：</p>
<p><span class="math display">\[
\begin{array}{cl}
\dot{V} &amp;= e\dot{e} + \dfrac{1}{k_2}\psi_e\dot{\psi}_e\\
&amp;=e \cdot v_r \cdot \sin(\psi_e) + \dfrac{1}{k_2}\psi_e\Bigl(\dot{\psi} - \dfrac{v_{r}\cdot\cos(\psi_e)\cdot k(s)}{1-k(s)e}\Bigr)
\end{array}\tag{13}
\]</span></p>
<p>根据等式(13)，另<span class="math inline">\(\dot{V} = 0\)</span>，得</p>
<p><span class="math display">\[
\begin{array}{cl}
v_r \cdot \sin(\psi_e)\cdot e + \dfrac{1}{k_2}\psi_e\Bigl(\dot{\psi} - \dfrac{v_{r}\cdot\cos(\psi_e)\cdot k(s)}{1-k(s)e}\Bigr)=0\\
k_2 v_r \dfrac{\sin(\psi_e)}{\psi_e}e + \dot{\psi} - \dfrac{v_{r}\cdot\cos(\psi_e)\cdot k(s)}{1-k(s)e} = 0\\
\end{array} \tag{14}
\]</span></p>
<p>求出零界控制率<span class="math inline">\(\dot{\psi_e}\)</span> 如下：</p>
<p><span class="math display">\[
\dot{\psi}^* = \dfrac{v_{r}\cdot\cos(\psi_e)\cdot k(s)}{1-k(s)e} - k_2 v_r \dfrac{\sin(\psi_e)}{\psi_e}e \tag{15}
\]</span></p>
<p>为了满足第2条李亚普洛夫稳定判据，设置一个调节函数<span class="math inline">\(g(e, \psi_e, t) &gt; 0\)</span>,可以得出基于航向角变化率的控制命令：</p>
<p><span class="math display">\[
\dot{\psi} = \dot{\psi}^* - g(e,\psi_e,t)\psi_e\tag{16}
\]</span></p>
<p>设置<span class="math inline">\(g(e,{\psi}_e,t)= k_{\psi}|v_r|\)</span> ，其中<span class="math inline">\(k_{\psi} &gt; 0\)</span>。</p>
<p><span class="math display">\[
\dot{\psi} = \dfrac{v_{r}\cdot\cos(\psi_e)\cdot k(s)}{1-k(s)e} - k_2 v_r \dfrac{\sin(\psi_e)}{\psi_e}e - k_{\psi}|v_r|\psi_e \tag{17}
\]</span></p>
<p>将等式(17)带入等式(13)得</p>
<p><span class="math display">\[
\begin{array}{cl}
\dot{V} 
&amp;=v_r \cdot \sin(\psi_e) \cdot e + \dfrac{1}{k_2}\psi_e\Bigl(\dot{\psi} - \dfrac{v_{r}\cdot\cos(\psi_e)\cdot k(s)}{1-k(s)e}\Bigr)\\
&amp;=v_r \cdot \sin(\psi_e) \cdot e +\dfrac{1}{k_2}\psi_e\bigl(- k_2 v_r \dfrac{\sin(\psi_e)}{\psi_e}e - k_{\psi}|v_r|\psi_e\bigr)\\
&amp;=v_r \cdot \sin(\psi_e) \cdot e - v_r \cdot \sin(\psi_e) \cdot e -\dfrac{k_{\psi}}{k_2}|v_r|\psi_e^2\\
&amp;=-\dfrac{k_{\psi}}{k_2}|v_r|\psi_e^2 \leq 0
\end{array}\tag{18}
\]</span></p>
<p>所以设计得控制率满足稳定性条件。</p>
<h2 id="控制率">控制率</h2>
<p>根据车辆几何关系</p>
<p><span class="math display">\[
\tan(\delta) = \frac{L}{R} \tag{19}
\]</span></p>
<p>车辆航向变化率与车速和转弯半径的关系为<span class="math inline">\(\dot{\psi} = \frac{V}{R}\)</span>，结合等式(17)可得</p>
<p><span class="math display">\[
\tan(\delta) = \frac{\dot{\psi}L}{V} \tag{20}
\]</span></p>
<p>所以控制率<span class="math inline">\(\delta\)</span>为</p>
<p><span class="math display">\[
\delta = \arctan(\frac{\dot{\psi}L}{v_r})\tag{21}
\]</span></p>
<h2 id="仿真">仿真</h2>
<p><img data-src="https://i.loli.net/2021/08/30/8y5DujC4c3XSGWZ.png" style="zoom:80%;" /></p>
<p>根据上述控制系统框图，搭建仿真环境，分别测试三角函数曲线和圆弧曲线的跟踪效果。</p>
<h3 id="三角函数曲线跟踪">三角函数曲线跟踪</h3>
<p><img data-src="https://i.loli.net/2021/08/30/JbyuLNvZHDlhE6q.png" /></p>
<p><img data-src="https://i.loli.net/2021/08/30/qR7Zg6nM2ythaAk.png" /></p>
<h3 id="圆弧曲线跟踪">圆弧曲线跟踪</h3>
<p><img data-src="https://i.loli.net/2021/08/30/1An7yMSvCTNYpJz.png" /></p>
<p><img data-src="https://i.loli.net/2021/08/30/F7GJSnNzgyi6W3v.png" /></p>
<h2 id="实测数据">实测数据</h2>
<p>下图是实际车辆测试结果，测试条件如下： - 初始位置(0,0)，初始偏航角0° - 目标位置(5,-5)，目标偏航角-90° - 初始转向角0° - 初始速度0.5m/s - 跟踪圆弧曲率-0.2</p>
<p><img data-src="https://i.loli.net/2021/08/30/FZNv236WHmxlnqw.png" /></p>
<p><img data-src="https://i.loli.net/2021/08/30/5FTyLDrlSiWg7tM.png" /></p>
<p>基于上图可知，跟踪过程主要分为三个阶段：</p>
<ol type="1">
<li>第一阶段(0,0.7)m：车辆按最大角速度转到右转最大角度500°左右</li>
<li>第二阶段(0.7,3)m：车辆保持最大转向角趋近于跟踪曲线</li>
<li>第三阶段(3,5)m：车辆跟踪目标曲线，按照控制率输出转向角</li>
</ol>
<h2 id="总结">总结</h2>
<p>后轴位置反馈控制对于曲率连续变化的曲线控制较好，但对于曲率恒定的曲线(圆弧)，控制输出存在抖动。实际车辆控制时，由于执行器本身可以等效为一个低通滤波器，实测控制抖动较小。</p>
]]></content>
      <categories>
        <category>控制算法</category>
        <category>路径跟踪</category>
      </categories>
      <tags>
        <tag>Rear Wheel Position Base Feedback</tag>
        <tag>后轮位置反馈</tag>
      </tags>
  </entry>
  <entry>
    <title>控制算法-基于运动模型的LQR优化</title>
    <url>/2020/02/18/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-%E5%9F%BA%E4%BA%8E%E8%BF%90%E5%8A%A8%E6%A8%A1%E5%9E%8B%E7%9A%84LQR%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>本文主要讲述基于运动学模型的车辆路径跟踪，并使用<strong>LQR</strong>算法求取最优控制率。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/ActOf2zWvkdC4GT.jpg" alt="宏村" /><figcaption aria-hidden="true">宏村</figcaption>
</figure>
<span id="more"></span>
<h2 id="分析">分析</h2>
<p><img data-src="https://i.loli.net/2021/08/30/YbBKN6kUmxnAuWL.png" /></p>
<h3 id="运动学微分方程">运动学微分方程</h3>
<p>根据上图运动学特性易得</p>
<p><span class="math display">\[
\begin{array}{cl}
\dot{s} &amp;= \dfrac{v_{r}\cdot\cos(\psi_e)}{1-k(s)e}\\
\dot{e} &amp;= v_r \cdot \sin(\psi_e)\\
\dot{\psi_e} &amp;=\dfrac{v_r}{L}\tan(\delta) - \dfrac{v_{r}\cdot\cos(\psi_e)\cdot k(s)}{1-k(s)e}
\end{array}\tag{1}
\]</span></p>
<p>其中关于误差的微分方程如下：</p>
<p><span class="math display">\[
\begin{array}{cl}
\dot{e}_s      &amp;= v_r \cdot \sin(e_\psi)\\
\dot{e}_\psi &amp;= \dfrac{v_r}{L}\tan(\delta) - \dfrac{v_{r}\cdot\cos(e_\psi)\cdot k(s)}{1-k(s)e_s}
\end{array}\tag{2}
\]</span></p>
<h3 id="线性化">线性化</h3>
<p>将上述等式(2)中的<span class="math inline">\(\sin\)</span>和<span class="math inline">\(\cos\)</span>函数在<span class="math inline">\(e_\psi = 0\)</span>处线性化，<span class="math inline">\(\tan\)</span>函数在<span class="math inline">\(\delta = 0\)</span>处线性化得</p>
<p><span class="math display">\[
\begin{array}{cl}
\dot{e}_s    &amp;= v_r \cdot e_\psi \\
\dot{e}_\psi &amp;= \dfrac{v_r}{L}\delta - \dfrac{v_{r}}{R-e_s}
\end{array}\tag{3}
\]</span></p>
<p>对等式(3)中<span class="math inline">\(e_s\)</span>在<span class="math inline">\(e_s = 0\)</span>处线性化得</p>
<p><span class="math display">\[
\begin{array}{cl}
\dot{e}_s    &amp;= v_r \cdot e_\psi \\
\dot{e}_\psi &amp;= \dfrac{v_r}{L}\delta - \dfrac{v_{r}}{R} - \dfrac{v_r}{R^2}e_s 
\end{array}\tag{4}
\]</span></p>
<p>则相应的二阶导数为</p>
<p><span class="math display">\[
\begin{array}{cl}
\ddot{e}_s    &amp;= \dot{v}_r \cdot e_\psi \\
\ddot{e}_\psi &amp;= \dfrac{\dot{v}_r}{L}\delta - \dfrac{\dot{v}_{r}}{R} - \dfrac{\dot{v}_r}{R^2}e_s 
\end{array}\tag{5}
\]</span></p>
<h3 id="状态空间方程">状态空间方程</h3>
<p>整理等式(5)，状态空间方程如下：</p>
<p><span class="math display">\[
\frac{\mathrm{d}}{\mathrm{d}t}
\left[\begin{array}{cl}
e_s\\
\dot{e}_s\\
e_{\psi}\\
\dot{e}_{\psi}
\end{array}\right]=
\left [
\begin{array}{cl}
0  &amp; 1 &amp; 0 &amp; 0\\
0  &amp; 0  &amp; \dot{v}_r &amp; 0\\
0  &amp; 0  &amp; 0 &amp; 1\\
-\dot{v}_r \cdot k^2  &amp; 0 &amp; 0 &amp; 0
\end{array}
\right ]
\left[
\begin{array}{cl}
e_s\\
\dot{e}_s\\
e_{\psi}\\
\dot{e}_{\psi}
\end{array}
\right]+
\left[
\begin{array}{cl}
0\\
0\\
0\\
\dfrac{\dot{v}}{L}
\end{array}
\right]\delta \tag{6}
\]</span></p>
<p>其中<span class="math inline">\(A=\left [ \begin{array}{cl} 0 &amp; 1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; \dot{v}_r &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1\\ -\dot{v}_r \cdot k^2 &amp; 0 &amp; 0 &amp; 0 \end{array}\right ]\)</span>，<span class="math inline">\(B=\left[ \begin{array}{cl} 0\\ 0\\ 0\\ \dfrac{\dot{v}}{L} \end{array}\right]\)</span>，<span class="math inline">\(X= \left[ \begin{array}{cl} e_s\\ \dot{e}_s\\ e_{\psi}\\ \dot{e}_{\psi} \end{array} \right]\)</span>，<span class="math inline">\(U=\delta\)</span>，等式(6)简写如下：</p>
<p><span class="math display">\[
\dot{X} = AX + BU \tag{7}
\]</span></p>
<h3 id="离散化">离散化</h3>
<p>对上述(7)的连续状态空间方程离散化处理，得到如下离散化状态空间方程形式：</p>
<p><span class="math display">\[
X[k+1]=GX[k] + HU[k] \tag{8}
\]</span></p>
<p>其中，<span class="math inline">\(G = I + AT\)</span>、<span class="math inline">\(H = BT\)</span>，采用常规离散化方法得</p>
<p><span class="math display">\[
X[k+1] = (I + AT)X[k] + BTU[k] \tag{9}
\]</span></p>
<p>其中<span class="math inline">\(A\)</span>矩阵离散化得</p>
<p><span class="math display">\[
\begin{array}{cl}
G &amp;= I + AT\\
&amp;=\left[ \begin{array}{cl} 
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right]+
\left [
\begin{array}{cl}
0  &amp; 1 &amp; 0 &amp; 0\\
0  &amp; 0  &amp; \dot{v}_{r(k)} &amp; 0\\
0  &amp; 0  &amp; 0 &amp; 1\\
-\dot{v}_r k^2  &amp; 0 &amp; 0 &amp; 0
\end{array}
\right ]
T\\
&amp;=\left[ \begin{array}{cl} 
1 &amp; T &amp; 0 &amp; 0\\
0 &amp; 1 &amp; \dot{v}_rT &amp; 0\\
0 &amp; 0 &amp; 1 &amp; T\\
-\dot{v}_{r(k)} k^2T &amp; 0 &amp; 0 &amp; 1
\end{array}\right]
\end{array} \tag{10}
\]</span></p>
<p>其中<span class="math inline">\(B\)</span>矩阵离散化得</p>
<p><span class="math display">\[
\begin{array}{cl}
H &amp;= BT\\
&amp;=\left[
\begin{array}{cl}
0\\
0\\
0\\
\dfrac{\dot{v}_{r(k)}T}{L}
\end{array}\right]
\end{array} \tag{11}
\]</span></p>
<p>整理离散空间方程得</p>
<p><span class="math display">\[
\left[\begin{array}{cl}
e_{s(k+1)}\\
\dot{e}_{s(k+1)}\\
e_{\psi(k+1)}\\
\dot{e}_{\psi(k+1)}
\end{array}\right]=
\left [
\begin{array}{cl}
1 &amp; T &amp; 0 &amp; 0\\
0 &amp; 1 &amp; \dot{v}_{r(k)}T &amp; 0\\
0 &amp; 0 &amp; 1 &amp; T\\
-\dot{v}_{r(k)} k^2T &amp; 0 &amp; 0 &amp; 1
\end{array}
\right ]
\left[
\begin{array}{cl}
e_{s(k)}\\
\dot{e}_{s(k)}\\
e_{\psi(k)}\\
\dot{e}_{\psi(k)}
\end{array}
\right]+
\left[
\begin{array}{cl}
0\\
0\\
0\\
\dfrac{\dot{v}_rT}{L}
\end{array}
\right]\delta \tag{12}
\]</span></p>
<h3 id="相关简化">相关简化</h3>
<p>对上述(12)离散空间方程整理得</p>
<p><span class="math display">\[
\begin{array}{cl}
e_{s(k+1)} &amp;= e_{s(k)} + \dot{e}_{s(k)}T\\
\dot{e}_{s(k+1)} &amp;= \dot{e}_{s(k)} + \dot{v}_{r(k)} T e_{\psi(k)}\\
e_{\psi(k+1)}&amp;=e_{\psi(k)} + \dot{e}_{\psi(k)}T\\
\dot{e}_{\psi(k+1)} &amp;=  \dot{e}_{\psi(k)} + \dot{v}_{r(k)}T(\dfrac{\delta}{L} -k^2e_{s(k)})
\end{array} \tag{13}
\]</span></p>
<p>等式(13)中<span class="math inline">\(\dot{e}_{s(k+1)}\)</span>项结合等式(4)可进一步化简得</p>
<p><span class="math display">\[
\begin{array}{cl}
\dot{e}_{s(k)} + \dot{v}_{r(k)} T e_{\psi(k)} &amp;= v_{r(k)}e_{\psi(k)} + dv_{r(k)}e_{\psi(k)}\\
&amp;= (v_{r(k)} + dv_{r(k)})e_{\psi(k)}\\
&amp;=v_{r(k+1)}e_{\psi(k)}
\end{array} \tag{14}
\]</span></p>
<p>等式(13)中<span class="math inline">\(\dot{e}_{\psi(k+1)}\)</span>项结合等式(4)可进一步化简得</p>
<p><span class="math display">\[
\begin{array}{cl}
\dot{e}_{\psi(k)} + \dot{v}_{r(k)}T(\dfrac{\delta}{L} -k^2e_{s(k)})
&amp;=v_{r(k)}(\dfrac{\delta}{L} - k^2e_{s(k)}) + dv_{r(k)}(\dfrac{\delta}{L} - k^2e_{s(k)})\\
&amp;=(v_{r(k)} + dv_{r(k)})(\dfrac{\delta}{L}-k^2e_{s(k)})\\
&amp;=v_{r(k+1)}(\dfrac{\delta}{L}-k^2e_{s(k)})
\end{array}\tag{15}
\]</span></p>
<p>其中<span class="math inline">\(\dot{v}_r = \dfrac{dv_r}{dt}\)</span>，等式(13)结合等式(14)和(15)得</p>
<p><span class="math display">\[
\begin{array}{cl}
e_{s(k+1)} &amp;= e_{s(k)} + \dot{e}_{s(k)}T\\
\dot{e}_{s(k+1)} &amp;= v_{r(k+1)} e_{\psi(k)}\\
e_{\psi(k+1)}&amp;=e_{\psi(k)} + \dot{e}_{\psi(k)}T\\
\dot{e}_{\psi(k+1)} &amp;=  - v_{r(k+1)}k^2e_{s(k)} + \dfrac{v_{r(k+1)}}{L}\delta
\end{array}\tag{16}
\]</span></p>
<p>上述等式(16)整理为状态空间方程的形式为</p>
<p><span class="math display">\[
\left[\begin{array}{cl}
e_{s(k+1)}\\
\dot{e}_{s(k+1)}\\
e_{\psi(k+1)}\\
\dot{e}_{\psi(k+1)}
\end{array}\right]=
\left [
\begin{array}{cl}
1 &amp; T &amp; 0 &amp; 0\\
0 &amp; 0 &amp; v_{r(k+1)} &amp; 0\\
0 &amp; 0 &amp; 1 &amp; T\\
-v_{r(k+1)} k^2 &amp; 0 &amp; 0 &amp; 0
\end{array}
\right ]
\left[
\begin{array}{cl}
e_{s(k)}\\
\dot{e}_{s(k)}\\
e_{\psi(k)}\\
\dot{e}_{\psi(k)}
\end{array}
\right]+
\left[
\begin{array}{cl}
0\\
0\\
0\\
\dfrac{v_{r(k+1)}}{L}
\end{array}
\right]\delta \tag{17}
\]</span></p>
<h2 id="求解">求解</h2>
<p>采用<strong>LQR</strong>算法进行控制率求解。</p>
<ol type="1">
<li>确定迭代范围<span class="math inline">\(N\)</span></li>
<li>设置迭代初始值<span class="math inline">\(P_N=Q_f\)</span></li>
<li>循环迭代，<span class="math inline">\(t = N,\dots,1\)</span></li>
</ol>
<p><span class="math display">\[
P_{t-1} = Q + A^TP_{t+1}A - A^TP_{t+1}B(R + B^TP_{t+1}B)^{-1}B^TP_{t+1}A
\]</span></p>
<ol start="4" type="1">
<li>则反馈系数<span class="math inline">\(K_t = -(R + B^TP_{t+1}B)^{-1}B^TP_{t+1}A\)</span>，对于时间<span class="math inline">\(t=0,\dots,N-1\)</span></li>
<li>优化的控制量<span class="math inline">\(u_t^{lqr}=K_tx_t\)</span></li>
</ol>
<h2 id="参考">参考</h2>
<ul>
<li><a href="http://zgh551.top/2020/02/20/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-LQR-%E7%A6%BB%E6%95%A3%E6%97%B6%E9%97%B4%E6%9C%89%E9%99%90%E8%BE%B9%E7%95%8C/#more">LQR-离散时间有限边界</a></li>
</ul>
]]></content>
      <categories>
        <category>控制算法</category>
        <category>路径跟踪</category>
      </categories>
      <tags>
        <tag>LQR</tag>
        <tag>路径跟踪</tag>
        <tag>控制算法</tag>
        <tag>Path Tracking</tag>
        <tag>运动模型</tag>
      </tags>
  </entry>
  <entry>
    <title>控制算法-滑模控制抖振消除</title>
    <url>/2019/12/27/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-%E6%BB%91%E6%A8%A1%E6%8E%A7%E5%88%B6%E6%8A%96%E6%8C%AF%E6%B6%88%E9%99%A4/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>在实际控制系统中，包括直流电机和飞机控制，通过连续或者平滑控制信号来避免控制抖振都是非常重要的方式。进一步说，飞机的气动表面不能高频来回运动，但同时对于边界模型不确定且存在外部干扰的控制系统，渴望保持其鲁棒性或不敏感度。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/e6fD51xMwEGqdnO.jpg" alt="重庆美术学院" /><figcaption aria-hidden="true">重庆美术学院</figcaption>
</figure>
<span id="more"></span>
<h2 id="消抖方法">消抖方法</h2>
<h3 id="抖振消除">抖振消除</h3>
<p>一个显而易见使控制函数连续且平滑的解决方案就是通过一些连续或平滑函数代替非连续函数<span class="math inline">\(v(\sigma) = -\rho sign(\sigma)\)</span>。进一步说，它可以被"sigmoid function"替代。</p>
<p><span class="math display">\[
sign(\sigma) \approx \frac{\sigma}{\rvert \sigma \rvert + \varepsilon} \tag{1}
\]</span></p>
<p>其中，<span class="math inline">\(\varepsilon\)</span>是一个很小的正标量。可以看出，对于所有<span class="math inline">\(\sigma \neq 0\)</span>，下述等式成立：</p>
<p><span class="math display">\[
\lim_{\varepsilon \to 0}\frac{\sigma}{\rvert \sigma \rvert + \varepsilon} = sign(\sigma) \tag{2}
\]</span></p>
<p>对于<span class="math inline">\(\varepsilon\)</span>的选择需要权衡既要保持系统的性能理想又要确保控制的平滑。</p>
<p>关于 Sigmoid Function 的图形如下：</p>
<p><img data-src="https://i.loli.net/2021/08/30/NoXcDfzSPqBFMQJ.png" /></p>
<p>使用伪滑动模态控制率如下：</p>
<p><span class="math display">\[
u = -c \cdot x_2 - \rho\frac{\sigma}{\rvert \sigma \rvert + \varepsilon} \tag{3}
\]</span></p>
<h4 id="仿真结果">仿真结果</h4>
<p><img data-src="https://i.loli.net/2021/08/30/gsIFvU3k7RONlBe.png" /></p>
<p><img data-src="https://i.loli.net/2021/08/30/FyCmKcoS1YnELZ6.png" /></p>
<p><img data-src="https://i.loli.net/2021/08/30/xA2XwCuNatFjLpk.png" /></p>
<p>由上图可知，平滑控制函数不能够在存在外部干扰项<span class="math inline">\(f(x_1,x_2,t)\)</span>时，使得滑模变量在有限时间内收敛于0。并且滑模变量和状态变量都不能收敛于0，但由于干扰项<span class="math inline">\(f(x_1,x_2,t) = \sin(2t)\)</span>影响，使其收敛到原点附近的范围。实现平滑控制函数的代价是鲁棒性的损失和准确性降低。因为滑模变量在有限的时间内没有趋向于0，所以等式(3)所设计的平滑控制从技术上讲不是滑模控制，在系统中也不是理想的滑动模态。但是在等式(3)中平滑控制率下的系统性能接近于离散滑模控制下的系统性能。这就为我们将等式(3)对应的平滑控制率称为<strong>准滑模控制</strong>(<em>quasi-sliding mode control</em>)提供了依据，而当滑模面收敛于原点时，就叫做 <strong>准滑动模态</strong>(<em>quasi-sliding mode</em>)</p>
<h3 id="抖振衰减">抖振衰减</h3>
<p>考虑设计另一种对边界干扰具有鲁棒性的连续控制器，设计思想就是根据控制函数的微分形式设计滑模控制器。在这种情况下，高频切换函数的积分作为实际控制是连续的。这种方法叫做 <strong>抖振衰减</strong>(<em>chattering attenuation</em>)，这是因为在高频切换函数积分后仍然能在滑模控制中观察到一些周期性残差。</p>
<h4 id="微分方程">微分方程</h4>
<p>系统微分方程如下：</p>
<p><span class="math display">\[
\left \{
\begin{array}{rl}
&amp;\dot{x}_1 = x_2 &amp;x_1(0) &amp;= x_{10}\\
&amp;\dot{x}_2 = u + f(x_1,x_2,t) &amp;x_2(0) &amp;= x_{20}\\
&amp;\dot{u} = v &amp;u(0) &amp;= 0
\end{array}
\right. \tag{4}
\]</span></p>
<p>如果滑模变量 <span class="math inline">\(\sigma = x_2 + c \cdot x_1\)</span>被限制在有限时间<span class="math inline">\(t = t_r\)</span>内收敛于0，同样对于所有<span class="math inline">\(t \geq t_r\)</span>,状态变量渐进收敛于0。这里假设<span class="math inline">\(\rvert f(x_1,x_2,t) \leq L\)</span>，此外其有界导数<span class="math inline">\(\rvert \dot{f}(x_1,x_2,t) \rvert \leq \bar{L}\)</span>是平滑的。</p>
<h4 id="辅助滑动变量">辅助滑动变量</h4>
<p>为了达到抖振衰减，定义如下辅助滑动变量</p>
<p><span class="math display">\[
s = \dot{\sigma} + \bar{c}\sigma \tag{5}
\]</span></p>
<p>如果设计一个控制率<span class="math inline">\(v\)</span>使得在有限时间内收敛<span class="math inline">\(s \to 0\)</span>，那么理想的滑动模态发生在如下滑模面上：</p>
<p><span class="math display">\[
s = \dot{\sigma} + \bar{c}\sigma = 0 \tag{6}
\]</span></p>
<p>随着时间的递增，即使存在有界的干扰<span class="math inline">\(f(x_1,x_2,t)\)</span>，只要<span class="math inline">\(\sigma,\dot{\sigma} \to 0\)</span>,与此同时<span class="math inline">\(x_1,x_2 \to 0\)</span>。但是因为原始滑模变量<span class="math inline">\(\sigma\)</span>只是渐进收敛于0，所以对于系统(4)而言，这不是理想的滑动模态，而是 <strong>渐进滑动模态</strong>(<em>asymptotic sliding mode</em>)，这就是衰减抖振所付出的代价。</p>
<p>根据等式(4)对辅组滑动变量<span class="math inline">\(s\)</span>拆解得</p>
<p><span class="math display">\[
\begin{array}{rl}
s &amp;= \dot{\sigma} + \bar{c}\sigma\\
&amp;= \dot{x}_2 + c\dot{x}_1 + \bar{c}(x_2 + cx_1)\\
&amp;= u + f(x_1,x_2,t) + cx_2 + \bar{c}x_2 + c\bar{c}x_1\\
&amp;=u + (c + \bar{c})x_2 + c\bar{c}x_1 + f(x_1,x_2,t)
\end{array} \tag{7}
\]</span></p>
<p>辅组滑动变量<span class="math inline">\(s\)</span>求导得</p>
<p><span class="math display">\[
\begin{array}{rl}
\dot{s} 
&amp;= \dot{u} + (c + \bar{c})\dot{x}_2 + c\bar{c}\dot{x}_1 + \dot{f}(x_1,x_2,t)\\
&amp;= v + (c + \bar{c})(u + f(x_1,x_2,t)) + c\bar{c}x_2 + \dot{f}(x_1,x_2,t)\\
&amp;= v + (c + \bar{c})u + c\bar{c}x_2 + (c + \bar{c})f(x_1,x_2,t) + \dot{f}(x_1,x_2,t)
\end{array} \tag{8}
\]</span></p>
<p>根据李亚普洛夫稳定条件，设计滑模控制项<span class="math inline">\(v\)</span>，得到如下等式：</p>
<p><span class="math display">\[
s\dot{s} = s
\bigl(
v + (c + \bar{c})u + c\bar{c}x_2 + (c + \bar{c})f(x_1,x_2,t) + \dot{f}(x_1,x_2,t)
\bigr) \tag{9}
\]</span></p>
<p>选择如下控制率：</p>
<p><span class="math display">\[
v = -c\bar{c}x_2 - (c + \bar{c})u + v_1 \tag{10}
\]</span></p>
<p>将等式(10)带入等式(9)得</p>
<p><span class="math display">\[
s\dot{s} = s
\bigl(
v_1 + (c + \bar{c})f(x_1,x_2,t) + \dot{f}(x_1,x_2,t)
\bigr) \tag{11}
\]</span></p>
<p>由于有界干扰项<span class="math inline">\(\rvert f(x_1,x_2,t) \leq L\)</span>且<span class="math inline">\(\rvert \dot{f(x_1,x_2,t)} \rvert \leq \bar{L}\)</span>，故得</p>
<p><span class="math display">\[
s\dot{s} \leq sv_1 + \rvert s \rvert \bigl( (c + \bar{c})L + \bar{L}\bigr) \tag{12}
\]</span></p>
<p>选择切换函数为<span class="math inline">\(v_1 = - \rho sign(s)\)</span>，其中<span class="math inline">\(\rho &gt; 0\)</span>，带入等式(12)得</p>
<p><span class="math display">\[
s\dot{s} \leq \rvert s \rvert \bigl(-\rho + \bar{L} + (c + \bar{c})L \bigr) \tag{13}
\]</span></p>
<p>根据有限时间收敛条件</p>
<p><span class="math display">\[
s\dot{s} \leq -\frac{\alpha}{\sqrt{2}}\rvert s\rvert \tag{14}
\]</span></p>
<p>结合等式(13)和(14),计算控制增益<span class="math inline">\(\rho\)</span>如下：</p>
<p><span class="math display">\[
\rho = \bar{L} + (c + \bar{c})L + \frac{\alpha}{\sqrt{2}} \tag{15}
\]</span></p>
<p>驱使<span class="math inline">\(s\)</span>在有限时间<span class="math inline">\(t_r \leq \frac{\sqrt{2}\rvert s(0) \rvert}{\alpha}\)</span>内使<span class="math inline">\(s\)</span>收敛于0的控制率<span class="math inline">\(v\)</span>为</p>
<p><span class="math display">\[
v = -c\bar{c}x_2 - (c + \bar{c})u - \rho \cdot sign(s) \tag{16}
\]</span></p>
<h4 id="仿真结果-1">仿真结果</h4>
<p>如下图所示，包含高频切换项的<span class="math inline">\(\rho sign(s)\)</span>的控制率导致了抖振。</p>
<p><img data-src="https://i.loli.net/2021/08/30/NvsdctofEuqlKni.png" /></p>
<p>但如下图所示，抖振在实际物理控制率<span class="math inline">\(u = \int vdt\)</span>中逐步衰减。</p>
<p><img data-src="https://i.loli.net/2021/08/30/gsIFvU3k7RONlBe.png" /></p>
]]></content>
      <categories>
        <category>控制算法</category>
        <category>滑模控制</category>
      </categories>
      <tags>
        <tag>避免抖振</tag>
        <tag>chattering avoidance</tag>
        <tag>滑模控制</tag>
        <tag>准滑动模态</tag>
        <tag>Quasi-Sliding Mode</tag>
        <tag>渐近滑动模态</tag>
        <tag>抖振衰减</tag>
        <tag>Chattering Attenuation</tag>
        <tag>抖振消除</tag>
        <tag>Chattering Elimination</tag>
      </tags>
  </entry>
  <entry>
    <title>控制算法-滑模控制介绍</title>
    <url>/2019/12/21/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-%E6%BB%91%E6%A8%A1%E6%8E%A7%E5%88%B6%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="一维运动模型">一维运动模型</h2>
<p>考虑简单的单位质量块的一维运动模型，使用位移和速度状态变量进行描述。</p>
<p><img data-src="https://i.loli.net/2021/08/30/5gi8qy1jdHrvePa.png" /></p>
<p>定义位移变量<span class="math inline">\(x_1 = x\)</span>和速度变量<span class="math inline">\(x_2 = \dot{x_1} = v\)</span>，运动模型的微分形式使用<span class="math inline">\(x_1\)</span>、<span class="math inline">\(x_2\)</span>表示如下：</p>
<p><span class="math display">\[
\left\{
\begin{array}{rl}
&amp;\dot{x_1} = x_2&amp; x_1(0)=x_{10}\\
&amp;\dot{x_2} = u + f(x_1,x_2,t) &amp;x_2(0)=x_{20}
\end{array} \right.\tag{1}
\]</span></p>
<span id="more"></span>
<p>其中,<span class="math inline">\(u\)</span>代表控制力，干扰项<span class="math inline">\(f(x_1,x_2,t)\)</span>包括干粘摩檫力的影响和一些未知的阻力，并假定有界。</p>
<p><span class="math display">\[
\rvert f(x_1,x_2,t)\rvert \leqslant L \gt 0 \tag{2}
\]</span></p>
<p>问题关键在于设计一个反馈控制率<span class="math inline">\(u = u(x_1,x_2)\)</span>，驱动质量块渐进到达原点。换句话说，控制变量<span class="math inline">\(u=f(x_1,x_2)\)</span>应该驱使状态变量趋近于0：<span class="math inline">\(\lim_{t \to \infty}{x_1,x_2} = 0\)</span>。</p>
<p>这个问题看似简单，但对于存在未知的边界干扰项<span class="math inline">\(f(x_1,x_2,t)\)</span>的情况下，使系统渐进收敛仍然存在着挑战。</p>
<h3 id="状态反馈控制">状态反馈控制</h3>
<p>例如，通过一个线性状态反馈控制率</p>
<p><span class="math display">\[
\begin{matrix}
u = -k_1x_1 - k_2x_2, &amp;\text{其中}(k_1&gt;0,&amp;k_2&gt;0)
\end{matrix}\tag{3}
\]</span></p>
<p>在外界干扰项<span class="math inline">\(f(x_1,x_2,t)\equiv 0\)</span>，即不存在外界干扰时，系统可以实现渐进收敛。</p>
<h3 id="仿真结果">仿真结果</h3>
<ul>
<li>初始条件<span class="math inline">\(x_{10}=1\)</span>、<span class="math inline">\(x_{20} = -2\)</span>、控制率参数<span class="math inline">\(k_1=3\)</span>、<span class="math inline">\(k_2=4\)</span>。</li>
</ul>
<p>如下图所示，是无外界干扰项时的渐近收敛效果图，图中蓝色线代表距离<span class="math inline">\(x\)</span>，橘黄色线代表速度<span class="math inline">\(v\)</span>，可以看出在反馈控制率<span class="math inline">\(u = u(x_1,x_2)\)</span>的作用下，距离和速度值都趋近于0。</p>
<p><img data-src="https://i.loli.net/2021/08/30/ezqd9oHvbYJwhCB.png" /></p>
<p>加入外部干扰<span class="math inline">\(f(x_1,x_2,t) = \sin(2t)\)</span>，响应波形如下：</p>
<p><img data-src="https://i.loli.net/2021/08/30/heN7REVItMlwbqf.png" /></p>
<p>对于干扰项<span class="math inline">\(\rvert f(x_1,x_2,t)\rvert \leq L &gt; 0\)</span>,产生的状态边界范围为<span class="math inline">\(\Omega=(k_1,k_2,L)\)</span> 。</p>
<p>现在问题在于，仅使用未知扰动范围的知识是否可以解决规定的控制问题。</p>
<h2 id="滑模控制的主要特性">滑模控制的主要特性</h2>
<p>介绍对于等式(1)系统，所需的补偿动力。一个较好的替代这些动力学特性的是齐次线性时不变微分方程：</p>
<p><span class="math display">\[
\begin{array}{rl}
\dot{x}_1 + c \cdot x_1 = 0 ,&amp; c &gt; 0 \tag{4}
\end{array}
\]</span></p>
<p>因为 <span class="math inline">\(x_2(t) = \dot{x}_1(t)\)</span>,等式(4)的通用解和它的微分形式如下：</p>
<p><span class="math display">\[
\begin{array}{}
&amp;x_1(t) = x_1(0)\exp(-ct)\\
&amp;x_2(t) = \dot{x_1}(t)=-c \cdot x_1(0)\exp(-ct)
\end{array}\tag{5}
\]</span></p>
<p>从等式(5)可以看出，<span class="math inline">\(x_1(t)\)</span>和<span class="math inline">\(x_2(t)\)</span>都是逐渐趋近于0。注意，无干扰项<span class="math inline">\(f(x_1,x_2,t)\)</span>的状态补偿动力学是很明显的。如何获得这些补偿动力。</p>
<h3 id="滑模变量">滑模变量</h3>
<p>首先介绍一个等式(1)系统的状态空间的新变量(<strong><em>滑模变量</em></strong>)：</p>
<p><span class="math display">\[
\sigma = \sigma(x_1,x_2) = x_2 + c \cdot x_1 \tag{6}
\]</span></p>
<p>在给定等式(5)收敛率且存在有界干扰<span class="math inline">\(f(x_1,x_2,t)\)</span>的情况下，为了使状态变量<span class="math inline">\(x_1\)</span>，<span class="math inline">\(x_2\)</span>逐渐收敛于0，即<span class="math inline">\(\lim_{t \to \infty} x_1,x_2 = 0\)</span>，不得不通过控制率<span class="math inline">\(u\)</span>使得等式(6)的变量<span class="math inline">\(\sigma\)</span>在有限的时间内趋于0。</p>
<p>为了完成这个任务利用李亚普洛夫函数技术，结合等式(1)和(6)推动出关于滑模变量<span class="math inline">\(\sigma\)</span>的动力学方程如下：</p>
<p><span class="math display">\[
\begin{array}{rl}
\dot{\sigma} = c \cdot x_2 + f(x_1,x_2,t) + u ,&amp;\sigma(0) = \sigma_0
\end{array} \tag{7}
\]</span></p>
<h3 id="稳定判据">稳定判据</h3>
<p>李亚普洛夫函数(Lyapunov)形式如下：</p>
<p><span class="math display">\[
V = \frac{1}{2}\sigma^2 \tag{8}
\]</span></p>
<p>为了使等式(6)在平衡点<span class="math inline">\(\sigma = 0\)</span>处渐进稳定，根据李亚普洛夫稳定判据，必须满足下面两个条件：</p>
<ol type="1">
<li><span class="math inline">\(\begin{array}{rl}\dot{V} &lt; 0 &amp;(\sigma \neq 0)\end{array}\)</span></li>
<li><span class="math inline">\(\lim_{\rvert \sigma \rvert \to \infty}V = \infty\)</span></li>
</ol>
<p>由等式(8)知，条件2明显满足。为了满足有限时间内渐进稳定，条件(1)可以修改为：</p>
<p><span class="math display">\[
\dot{V} \leq -\alpha {V}^{\frac{1}{2}} ,\qquad \alpha &gt; 0 \tag{9}
\]</span></p>
<p>在时间间隔<span class="math inline">\(0 \leq \tau \leq t\)</span>内，对等式(9)所示的微分方程进行变量分离求积分得</p>
<p><span class="math display">\[
\begin{array}{rl}
\int_{0}^{t} V(\tau)^{-\frac{1}{2}}dV(\tau) &amp;\leq -\alpha*\int_{0}^{t}1 d\tau\\
2*V(\tau)^{\frac{1}{2}}|_0^t &amp;\leq -\alpha*\tau|_0^t\\
2*[V(t)^{\frac{1}{2}} - V(0)^{\frac{1}{2}}] &amp;\leq -\alpha*t\\
V(t)^{\frac{1}{2}} &amp;\leq -\dfrac{1}{2}\alpha*t + V(0)^{\frac{1}{2}}
\end{array}\tag{10}
\]</span></p>
<p>故<span class="math inline">\(V(t)\)</span>在有限时间<span class="math inline">\(t_r\)</span>达到0时的边界，根据等式(26)得</p>
<p><span class="math display">\[
t_r \leq \frac{2V(0)^{\frac{1}{2}}}{\alpha} \tag{11}
\]</span></p>
<p>因此，设计一个控制器<span class="math inline">\(u\)</span>满足等式(9)，使得变量<span class="math inline">\(s\)</span>在有限的时间内趋近于0并在之后一直保持。</p>
<p><span class="math inline">\(V\)</span>的微分计算如下：</p>
<p><span class="math display">\[
\dot{V} = \sigma\dot{\sigma}=\sigma(c \cdot x_2 + f(x_1,x_2,t) + u) \tag{12}
\]</span> 假设 <span class="math inline">\(u = -c \cdot x_2 + v\)</span>，并将其带入等式(12)得 <span class="math display">\[
\dot{V} 
= \sigma\bigl( f(x_1,x_2,t) + v \bigr) 
= \sigma \cdot f(x_1,x_2,t) + \sigma v
\leq   \rvert \sigma \rvert L + \sigma v \tag{13}
\]</span></p>
<p>此处选择<span class="math inline">\(v = -\rho sign(\sigma)\)</span>，该函数表示为</p>
<p><span class="math display">\[
sign(x) = 
\left \{
\begin{array}{rl}
&amp; 1 &amp; x &gt; 0\\
&amp; &amp; &amp;\\
&amp;-1 &amp; x &lt; 0
\end{array}
\right. \tag{14}
\]</span> 并且</p>
<p><span class="math display">\[
sign(0) \in [-1,1] \tag{15}
\]</span></p>
<p>由于<span class="math inline">\(\rho &gt; 0\)</span>，将其带入等式(13)得</p>
<p><span class="math display">\[
\dot{V} \leq \rvert \sigma  \rvert L - \rvert \sigma \rvert \rho 
= \rvert \sigma \rvert(L - \rho) \tag{16}
\]</span></p>
<p>考虑到等式(8)的形式，等式(9)可以表示为</p>
<p><span class="math display">\[
\dot{V} \leq -\alpha {V}^{\frac{1}{2}} = -\frac{\alpha}{\sqrt{2}}\rvert \sigma \rvert,\qquad \alpha &gt; 0 \tag{17}
\]</span></p>
<p>结合等式(16)和等式(17)得</p>
<p><span class="math display">\[
\dot{V} \leq \rvert \sigma \rvert(L - \rho)
=-\frac{\alpha}{\sqrt{2}}\rvert \sigma \rvert \tag{18}
\]</span></p>
<p>最终控制增益可以表示为</p>
<p><span class="math display">\[
\rho = L + \frac{\alpha}{\sqrt{2}} \tag{19}
\]</span></p>
<p>所以最终使滑模变量<span class="math inline">\(\sigma\)</span>在有限时间内趋近于0的控制率<span class="math inline">\(u\)</span>为</p>
<p><span class="math display">\[
u = -c \cdot x_2 - \rho \cdot sign(\sigma) \tag{20}
\]</span></p>
<blockquote>
<ol type="1">
<li>显然，为了成功地设计出等式(20)中的控制器，<span class="math inline">\(\dot{\sigma}\)</span>必须是控制率<span class="math inline">\(u\)</span>的函数。当设计像等式(6)中的滑模变量时，这个特性必须考虑其中。</li>
<li>等式(19)中控制增益<span class="math inline">\(\rho\)</span>的第一项被设计用来补偿有界干扰项<span class="math inline">\(f(x_1,x_2,t)\)</span>，同时第二项<span class="math inline">\(\frac{\alpha}{\sqrt{2}}\)</span>负责确定滑模面的到达时间。<span class="math inline">\(\alpha\)</span>的数值越大，到达时间就越短。</li>
</ol>
</blockquote>
<h3 id="基本定义">基本定义</h3>
<ul>
<li><strong>滑模变量</strong></li>
</ul>
<p>等式(6)中定义的变量<span class="math inline">\(\sigma\)</span>叫做 <strong>滑模变量</strong>(<code>sliding variable</code>)</p>
<ul>
<li><strong>滑模面</strong></li>
</ul>
<p>结合等式(4)和(5)，可以重新写成如下形式： <span class="math display">\[
\sigma = x_2 + c \cdot x_1 = 0, c &gt; 0 \tag{21}
\]</span> 相当于在系统(1)状态空间内的一条直线，这条直线被称为 <strong>滑模面</strong>(<code>sliding surface</code>)。</p>
<p>考虑到等式(9)可以等效于</p>
<p><span class="math display">\[
\sigma\dot{\sigma} \leq - \frac{\sigma}{\sqrt{2}} \rvert \sigma\rvert \tag{22}
\]</span></p>
<p>等式(22)经常被称为 <strong>到达条件</strong>(<code>reachability condition</code>)。满足<strong>到达条件</strong>意味着等式(1)系统的轨迹趋向于<strong>滑模面</strong>，并在此后一直保持。</p>
<ul>
<li><strong>滑模控制</strong></li>
</ul>
<p>等式(20)所对应的控制率<span class="math inline">\(u = u(x_1,x_2)\)</span>驱使状态变量<span class="math inline">\(x_1\)</span>、<span class="math inline">\(x_2\)</span>在有限时间<span class="math inline">\(t_r\)</span>内趋近于<strong>滑模面</strong>，并在存在有界干扰项<span class="math inline">\(f(x_1,x_2,t)\)</span>的情况下保持在该平面上，这个控制率<span class="math inline">\(u\)</span>就叫做 <strong>滑模控制</strong>。并且对于所有的<span class="math inline">\(t &gt; t_r\)</span>，系统都将产生一个<strong>理想滑动模态</strong>。</p>
<h3 id="仿真结果-1">仿真结果</h3>
<p>初始条件为<span class="math inline">\(x_1(0) = 1，x_2(0) = -2\)</span>，控制增益为<span class="math inline">\(\sigma = 2\)</span>，滑模参数为<span class="math inline">\(c = 1.5\)</span>同时干扰项为<span class="math inline">\(f(x_1,x_2,t) = \sin(2t)\)</span>。 使用等式(20)的滑模控制率的仿真结果如下：</p>
<p>下图表明，在有限的时间内，滑模变量趋近于0。</p>
<p><img data-src="https://i.loli.net/2021/08/30/LCQw2J7rU9axcKq.png" /></p>
<p>在干扰项作用的情况下，状态变量<span class="math inline">\(x\)</span>和<span class="math inline">\(v\)</span>逐渐收敛到0。</p>
<p><img data-src="https://i.loli.net/2021/08/30/jk5MfqmpabEFnAO.png" /></p>
<p>相图如下，展示了到达相位和滑移相位。</p>
<p><img data-src="https://i.loli.net/2021/08/30/k3HSfaLoPvgQ9C4.png" /></p>
<p>对上面的相图进行局部放大发现，在滑模状态下，状态变量存在小幅度且高频率的蜿蜒运动。</p>
<p><img data-src="https://i.loli.net/2021/08/30/7jGmgk14ruHwSOM.png" /></p>
<p>理想的滑模切换频率应该接近于无限并且蜿蜒运动的振幅接近于0。从下图可知，符号函数<span class="math inline">\(sign\)</span>不完美表现为在滑动模态中产生了有限幅度和频率的之字形运动，原因在于计算机仿真的离散特性，这样的影响叫做 <strong>抖振</strong>(<em>chattering</em>)。</p>
<p><img data-src="https://i.loli.net/2021/08/30/xme942slagIdZNK.png" /></p>
<p><img data-src="https://i.loli.net/2021/08/30/qvr8kst615cLNM4.png" /></p>
]]></content>
      <categories>
        <category>控制算法</category>
        <category>滑模控制</category>
      </categories>
      <tags>
        <tag>滑模控制</tag>
        <tag>滑模面</tag>
        <tag>滑模变量</tag>
        <tag>抖振</tag>
        <tag>sliding mode controller</tag>
        <tag>sliding mode variable</tag>
        <tag>sliding mode surface</tag>
        <tag>chattering</tag>
      </tags>
  </entry>
  <entry>
    <title>控制算法-纯追踪法</title>
    <url>/2020/02/23/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-%E7%BA%AF%E8%BF%BD%E8%B8%AA%E6%B3%95/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>在机器人领域，一种最受欢迎的路径追踪算法就是几何路径追踪。这些方法主要利用车辆和路径之间的几何关系去设计相应的控制率解决路径跟踪问题。</p>
<h2 id="几何车辆模型">几何车辆模型</h2>
<p><img data-src="https://i.loli.net/2021/08/30/XA45nZvx1sIiMUD.jpg" alt="荷花"  /></p>
<span id="more"></span>
<p>对于几何路径跟踪一般简化车辆模型为单车模型，如上图所示，前轮转向角和后轴跟随曲线之间的几何关系可以表示如下：</p>
<p><span class="math display">\[
\tan(\delta) = \frac{L}{R}\tag{1}
\]</span></p>
<p>其中，<span class="math inline">\(\delta\)</span>代表前轮转向角、<span class="math inline">\(L\)</span>代表车辆轴距、<span class="math inline">\(R\)</span>代表转弯半径。</p>
<h2 id="纯追踪">纯追踪</h2>
<p><img data-src="https://i.loli.net/2021/08/30/prkjiz1ZAaHyW4u.png" alt="纯追踪" style="zoom:80%;" /></p>
<p>纯追踪算法包括几何关系计算出后轴位置与车辆前方目标曲线上目标点之间圆弧的曲率，其中目标点由从当前车辆后轴位置到目标路径的超前距离<span class="math inline">\(l_d\)</span>决定。而车辆的转向角<span class="math inline">\(\delta\)</span>只能使用目标点位置和车辆航向量与超前向量之间的夹角<span class="math inline">\(\alpha\)</span>。由正弦定理得</p>
<p><span class="math display">\[
\frac{l_d}{\sin(2\alpha)} = \frac{R}{\sin(\frac{\pi}{2}-\alpha)}\tag{2}
\]</span></p>
<p>根据三角函数性质，对等式(2)化简得</p>
<p><span class="math display">\[
\frac{l_d}{2\sin(\alpha)\cos(\alpha)} = \frac{R}{\cos(\alpha)} \tag{3}
\]</span></p>
<p>由于<span class="math inline">\(\cos(\alpha) \neq 0\)</span>，对等式(3)进一步化简得</p>
<p><span class="math display">\[
R = \frac{l_d}{2\sin(\alpha)} \tag{4}
\]</span></p>
<p>故曲率表示为</p>
<p><span class="math display">\[
k = \frac{2\sin(\alpha)}{l_d} \tag{5}
\]</span></p>
<p>根据等式(1)所示的车辆几何关系得</p>
<p><span class="math display">\[
\delta = \arctan(k\cdot L) \tag{6}
\]</span></p>
<p>将等式(5)带入等式(6)得</p>
<p><span class="math display">\[
\delta = \arctan(\frac{2\sin(\alpha)L}{l_d})\tag{7}
\]</span></p>
]]></content>
      <categories>
        <category>控制算法</category>
        <category>路径跟踪</category>
      </categories>
      <tags>
        <tag>几何模型</tag>
        <tag>路径追踪</tag>
        <tag>纯追踪法</tag>
      </tags>
  </entry>
  <entry>
    <title>控制算法-跟踪误差动力学模型</title>
    <url>/2019/12/04/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-%E8%B7%9F%E8%B8%AA%E8%AF%AF%E5%B7%AE%E5%8A%A8%E5%8A%9B%E5%AD%A6%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>使用相对与目标曲线的位置和方向误差作为动力学模型的状态变量开发转向控制系统似乎更合适一些，对于<a href="https://blog.csdn.net/zghforever/article/details/103352211">车辆模型-动力学模型</a>章节中的动力学模型，需重新定义一下误差变量：</p>
<ul>
<li><span class="math inline">\(e_y\)</span>:车辆重心到目标曲线的距离；</li>
<li><span class="math inline">\(e_{\psi}\)</span>:车辆相对于目标曲线的方向误差；</li>
</ul>
<p>假设车辆纵向速度<span class="math inline">\(V_x\)</span>恒定且行驶路径的转弯半径<span class="math inline">\(R\)</span>不变，其中转弯半径<span class="math inline">\(R\)</span>足够大，以满足上述章节的小角度近似假设。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/SxsNHoFEdQjv5bP.jpg" alt="菊花展" /><figcaption aria-hidden="true">菊花展</figcaption>
</figure>
<span id="more"></span>
<h2 id="基本概念">基本概念</h2>
<h3 id="目标参数">目标参数</h3>
<ol type="1">
<li><p>定义车辆<strong>目标偏航角速度</strong>为 <span class="math display">\[
\dot{\psi}_{des} = \frac{V_x}{R} \tag{1}
\]</span></p></li>
<li><p>定义车辆<strong>目标向心加速度</strong>为 <span class="math display">\[
a_{des} = \frac{V_x^2}{R} = V_x\frac{V_x}{R}=V_x\dot{\psi}_{des}\tag{2}
\]</span></p></li>
</ol>
<h3 id="误差定义">误差定义</h3>
<ol type="1">
<li><p>定义车辆<strong>偏航角误差</strong>为 <span class="math display">\[
e_{\psi} = \psi - \psi_{des} \tag{3}
\]</span></p></li>
<li><p>定义车辆<strong>偏航角速度误差</strong>为 <span class="math display">\[
\dot{e}_{\psi} = \dot{\psi} - \dot{\psi}_{des} \tag{4}
\]</span></p></li>
<li><p>定义车辆<strong>偏航角加速度误差</strong>为 <span class="math display">\[
\ddot{e}_{\psi} = \ddot{\psi} - \ddot{\psi}_{des} \tag{5}
\]</span></p></li>
<li><p>定义车辆<span class="math inline">\(y\)</span>轴方向的<strong>加速度误差</strong>为 <span class="math display">\[
\ddot{e}_y = a_y - a_{des} \qquad\qquad\qquad\\
=(\ddot{y} + V_x\dot{\psi}) - V_x\dot{\psi}_{des} \\
=\ddot{y} + V_x(\dot{\psi} - \dot{\psi}_{des})\quad \tag{3}
\]</span></p></li>
<li><p>定义车辆<span class="math inline">\(y\)</span>轴方向的<strong>速度误差</strong>为 当车辆纵向速度恒定时，<span class="math inline">\(y\)</span>轴方向的速度误差可以表示为</p></li>
</ol>
<p><span class="math display">\[
\dot{e}_y = \int \ddot{e}_y\mathrm{d}t = \dot{y} + V_x(\psi - \psi_{des}) \tag{6}
\]</span></p>
<p>当纵向速度不再恒定，随着时间变化时，对等式(3)积分得 <span class="math display">\[
\dot{e}_y = \int \ddot{e}_y\mathrm{d}t = \dot{y} +\int V_x(\psi - \psi_{des})\mathrm{d}t \tag{7}
\]</span></p>
<p>这就使得模型非线性且时变，不利于控制系统的设计。因此解决方法就是假设纵向速度是恒定，这就获得了一个<strong>线性时不变</strong>(<strong>LTI</strong>)模型。如果速度变化，LTI模型就需要使用线性参变模型(LPV)替代，这个模型中纵向速度是一个随着时间变化的参数。</p>
<h2 id="跟踪误差动力学模型">跟踪误差动力学模型</h2>
<p>上述等式(3)、(6)可以变换如下：</p>
<p><span class="math display">\[
\ddot{y}  =\ddot{e}_y + V_x\dot{\psi}_{des} - V_x\dot{\psi}\tag{8}
\]</span></p>
<p><span class="math display">\[
 \dot{y} =\dot{e}_y - V_xe_{\psi} \tag{9}
\]</span></p>
<p>根据<a href="https://blog.csdn.net/zghforever/article/details/103352211">车辆模型-动力学模型(Dynamics Model)</a>章节中的等式(14) <span class="math display">\[
\ddot{y} = -\frac{2C_{\alpha f } + 2C_{\alpha r}}{mV_x}\dot{y}   - ( V_x +  \frac{2C_{\alpha f}l_f- 2C_{\alpha r}l_r}{mV_x})\dot{\psi}  + \frac{2C_{\alpha f}}{m} \delta \tag{10}
\]</span></p>
<p>将等式(8)和(9)代入等式(10)得</p>
<p><span class="math display">\[
\ddot{e}_y + V_x\dot{\psi}_{des} = -\frac{2C_{\alpha f } + 2C_{\alpha r}}{mV_x}(\dot{e}_y - V_xe_{\psi})   - ( V_x +  \frac{2C_{\alpha f}l_f- 2C_{\alpha r}l_r}{mV_x})\dot{\psi}  + \frac{2C_{\alpha f}}{m} \delta \tag{11}
\]</span></p>
<p>对等式(11)进行简化，提取<span class="math inline">\(\ddot{e}_y\)</span>、<span class="math inline">\(\dot{e}_y\)</span>、<span class="math inline">\(e_y\)</span>、<span class="math inline">\(\dot{\psi}_{des}\)</span>和<span class="math inline">\(\delta\)</span>项得</p>
<p><span class="math display">\[
\ddot{e}_y = \frac{-2C_{\alpha f}-2C_{\alpha r}}{mV_x}\dot{e}_y + \frac{2C_{\alpha f}+2C_{\alpha r}}{m}e_{\psi} +
\frac{-2C_{\alpha f}l_f + 2C_{\alpha r}l_r}{mV_x}\dot{e}_{\psi} \\+ (\frac{-2C_{\alpha f}l_f + 2C_{\alpha r}l_r}{mV_x}-V_x)\dot{\psi}_{des} +\frac{2C_{\alpha f}}{m}\delta \tag{12}
\]</span></p>
<p>整理成矩阵形式为</p>
<p><span class="math display">\[
\frac{\mathrm{d}}{\mathrm{d}t}\dot{e}_y =
\begin{bmatrix}
0 &amp;
-\dfrac{2C_{\alpha f } + 2C_{\alpha r}}{mV_x} &amp;
\dfrac{2C_{\alpha f}+2C_{\alpha r}}{m} &amp;
\dfrac{-2C_{\alpha f}l_f + 2C_{\alpha r}l_r}{mV_x}
\end{bmatrix}
\begin{bmatrix}
e_y\\
\dot{e}_y\\
e_{\psi}\\
\dot{e}_{\psi}
\end{bmatrix}\\
+(\dfrac{-2C_{\alpha f}l_f + 2C_{\alpha r}l_r}{mV_x} - V_x)\dot{\psi}_{des}+\frac{2C_{\alpha f}}{m}\delta \tag{13}
\]</span></p>
<p>同理根据<a href="https://blog.csdn.net/zghforever/article/details/103352211">车辆模型-动力学模型(Dynamics Model)</a>章节中的等式(17)</p>
<p><span class="math display">\[
\ddot{\psi} = - \frac{2l_fC_{\alpha f} - 2l_rC_{\alpha r}}{I_zV_x}\dot{y}  - \frac{2{l_f}^2C_{\alpha f} + 2{l_r}^2C_{\alpha r}}{I_zV_x}\dot{\psi} + \frac{2l_fC_{\alpha f}}{I_z}\delta\tag{14}
\]</span></p>
<p>将等式(5)、(8)和(9)代入等式(14)得</p>
<p><span class="math display">\[
\ddot{e}_{\psi}+ \ddot{\psi}_{des} = - \frac{2l_fC_{\alpha f} - 2l_rC_{\alpha r}}{I_zV_x}(\dot{e}_y - V_xe_{\psi})  - \frac{2{l_f}^2C_{\alpha f} + 2{l_r}^2C_{\alpha r}}{I_zV_x}\dot{\psi} + \frac{2l_fC_{\alpha f}}{I_z}\delta\tag{15}
\]</span></p>
<p>对等式(15)进行简化，提取<span class="math inline">\(\ddot{e}_y\)</span>、<span class="math inline">\(\dot{e}_y\)</span>、<span class="math inline">\(e_y\)</span>、<span class="math inline">\(\dot{\psi}_{des}\)</span>和<span class="math inline">\(\delta\)</span>项得</p>
<p><span class="math display">\[
\ddot{e}_{\psi} = - \frac{2l_fC_{\alpha f} - 2l_rC_{\alpha r}}{I_zV_x}\dot{e}_y + \frac{2l_fC_{\alpha f} - 2l_rC_{\alpha r}}{I_z}e_{\psi}\\
-\frac{2{l_f}^2C_{\alpha f} + 2{l_r}^2C_{\alpha r}}{I_zV_x}\dot{e}_{\psi}
-\frac{2{l_f}^2C_{\alpha f} + 2{l_r}^2C_{\alpha r}}{I_zV_x}\dot{\psi}_{des} + \frac{2l_fC_{\alpha f}}{I_z}\delta - \ddot{\psi}_{des} \tag{16}
\]</span></p>
<p>由于上述假设为<strong>线性时不变系统(LTI)</strong>(<span class="math inline">\(\dot{V}_x = 0\)</span>)，故<span class="math inline">\(\ddot{\psi}_{des}=\frac{\dot{V}_x}{R} = 0\)</span>，将上述等式整理成矩阵形式得</p>
<p><span class="math display">\[
\frac{\mathrm{d}}{\mathrm{d}t}\dot{e}_{\psi} =
\begin{bmatrix}
0 &amp;
-\dfrac{2l_fC_{\alpha f} - 2l_rC_{\alpha r}}{I_zV_x} &amp;
\dfrac{2l_fC_{\alpha f} - 2l_rC_{\alpha r}}{I_z} &amp;
-\dfrac{2{l_f}^2C_{\alpha f} + 2{l_r}^2C_{\alpha r}}{I_zV_x}
\end{bmatrix}
\begin{bmatrix}
e_y\\
\dot{e}_y\\
e_{\psi}\\
\dot{e}_{\psi}
\end{bmatrix}\\
-\frac{2{l_f}^2C_{\alpha f} + 2{l_r}^2C_{\alpha r}}{I_zV_x}\dot{\psi}_{des}+\frac{2l_fC_{\alpha f}}{I_z}\delta \tag{17}
\]</span></p>
<p>根据等式(13)和(17)，基于跟踪误差变量的状态空间模型表示为</p>
<p><span class="math display">\[
\frac{\mathrm{d}}{\mathrm{d}t}
\begin{bmatrix}
e_y\\
\dot{e}_y\\
e_{\psi}\\
\dot{e}_{\psi}
\end{bmatrix}=
\begin{bmatrix}
0 &amp; 1 &amp; 0 &amp; 0\\
0 &amp;
-\dfrac{2C_{\alpha f } + 2C_{\alpha r}}{mV_x} &amp;
\dfrac{2C_{\alpha f}+2C_{\alpha r}}{m} &amp;
\dfrac{-2C_{\alpha f}l_f + 2C_{\alpha r}l_r}{mV_x}\\
0 &amp; 0 &amp; 0 &amp; 1\\
0 &amp;
-\dfrac{2l_fC_{\alpha f} - 2l_rC_{\alpha r}}{I_zV_x} &amp;
\dfrac{2l_fC_{\alpha f} - 2l_rC_{\alpha r}}{I_z} &amp;
-\dfrac{2{l_f}^2C_{\alpha f} + 2{l_r}^2C_{\alpha r}}{I_zV_x}
\end{bmatrix}
\begin{bmatrix}
e_y\\
\dot{e}_y\\
e_{\psi}\\
\dot{e}_{\psi}
\end{bmatrix}\\
+
\begin{bmatrix}
0\\
\dfrac{2C_{\alpha f}}{m}\\
0\\
\dfrac{2l_fC_{\alpha f}}{I_z}
\end{bmatrix}\delta+
\begin{bmatrix}
0\\
(\dfrac{-2C_{\alpha f}l_f + 2C_{\alpha r}l_r}{mV_x} - V_x)\\
0\\
-\dfrac{2{l_f}^2C_{\alpha f} + 2{l_r}^2C_{\alpha r}}{I_zV_x}
\end{bmatrix}\dot{\psi}_{des}\tag{18}
\]</span></p>
<p>上述状态空间模型，将转向控制系统的目标跟踪问题转化为动力学的稳定性问题。 状态空间模型一般形式如下：</p>
<p><span class="math display">\[
\dot{x} = Ax + B_1\delta + B_2\dot{\psi}_{des}
\]</span></p>
]]></content>
      <categories>
        <category>控制算法</category>
        <category>车辆模型</category>
      </categories>
      <tags>
        <tag>跟踪误差模型</tag>
        <tag>动力学模型</tag>
      </tags>
  </entry>
  <entry>
    <title>控制算法-路径跟踪</title>
    <url>/2020/02/23/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-%E8%B7%AF%E5%BE%84%E8%B7%9F%E8%B8%AA%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>本文介绍常见几种路径跟踪算法，并分析各自的优势。目前主要分为基于几何关系控制设计和基于模型的控制设计。其中几何关系可以分为，纯追踪算法、前轴反馈和后轴反馈算法。基于模型可以分为运动模型和动力学模型，控制算法可以使用LQR优化或者使用MPC。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/H48QzVhRnge6Ec7.jpg" alt="喇叭花" /><figcaption aria-hidden="true">喇叭花</figcaption>
</figure>
<span id="more"></span>
<h2 id="基于几何关系设计">基于几何关系设计</h2>
<h3 id="纯追踪算法">纯追踪算法</h3>
<p>待补充</p>
<h3 id="前轴反馈">前轴反馈</h3>
<p>前轴反馈控制也就是常说的Stanley方法，几何关系如下：</p>
<p><img data-src="https://i.loli.net/2021/08/30/kVdqQai6KhGrelT.png" alt="前轴反馈" style="zoom:80%;" /></p>
<h4 id="三角函数曲线跟踪">三角函数曲线跟踪</h4>
<p><img data-src="https://i.loli.net/2021/08/30/to9hPGfxzk1LXnl.png" /></p>
<p><img data-src="https://i.loli.net/2021/08/30/qR7Zg6nM2ythaAk.png" /></p>
<h4 id="圆弧跟踪">圆弧跟踪</h4>
<p><img data-src="https://i.loli.net/2021/08/30/Qg3jSZLXif7Dqxc.png" /></p>
<p><img data-src="https://i.loli.net/2021/08/30/Hc4Ab2qGKdvZTwV.png" /></p>
<h3 id="后轴反馈">后轴反馈</h3>
<p><img data-src="https://i.loli.net/2021/08/30/YbBKN6kUmxnAuWL.png" alt="后轴反馈" style="zoom:80%;" /></p>
<h4 id="仿真系统框图">仿真系统框图</h4>
<p>基于下图框图，搭建仿真环境。 仿真条件： - 仿真周期20ms - 目标曲线采样间隔 5 - 初始位置(0,0) - 初始偏航角0度</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/9YFO1wxWV3jsJuU.png" alt="仿真系统框图" /><figcaption aria-hidden="true">仿真系统框图</figcaption>
</figure>
<h4 id="余弦曲线跟踪">余弦曲线跟踪</h4>
<figure>
<img data-src="https://i.loli.net/2021/08/30/JbyuLNvZHDlhE6q.png" alt="余弦曲线跟踪误差对比" /><figcaption aria-hidden="true">余弦曲线跟踪误差对比</figcaption>
</figure>
<p>由上图可知，对于曲率连续变化的跟踪效果较好。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/qR7Zg6nM2ythaAk.png" alt="余弦曲线跟踪控制率" /><figcaption aria-hidden="true">余弦曲线跟踪控制率</figcaption>
</figure>
<p>输出控制抖动也较小。</p>
<h4 id="圆弧跟踪-1">圆弧跟踪</h4>
<figure>
<img data-src="https://i.loli.net/2021/08/30/1An7yMSvCTNYpJz.png" alt="圆弧跟踪误差对比" /><figcaption aria-hidden="true">圆弧跟踪误差对比</figcaption>
</figure>
<p>由上图可知，对于曲率恒定的圆弧曲线，控制效果较差，存在较大的位置偏差。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/F7GJSnNzgyi6W3v.png" alt="圆弧跟踪控制率" /><figcaption aria-hidden="true">圆弧跟踪控制率</figcaption>
</figure>
<p>由上图可知，控制率震荡较大。</p>
<h4 id="c仿真效果">C++仿真效果</h4>
<p>仿真条件：</p>
<ul>
<li>初始位置为<span class="math display">\[(0,0)\]</span></li>
<li>初始偏航角为<span class="math display">\[0\]</span>度</li>
<li>仿真周期20ms</li>
<li>目标曲线采样间隔 1</li>
</ul>
<p>车辆刚起步时，由于输出转向角为0，而此时的圆弧曲率为-0.2，所以存在一段转向角按照最大角速度转到目标转向角的过程。跟踪过程中，从图中转向角的振荡幅度存在小范围的变化。在两个圆弧的交界处，由于曲率由-0.2突变到0.2，方向盘转向角需要按照最大角速度转到目标角度。在该过程中存在较大误差，但是在角度达到目标角度后，误差逐渐缩小，最后完全跟踪上目标曲线。</p>
<h5 id="圆弧前进">圆弧前进</h5>
<figure>
<img data-src="https://i.loli.net/2021/08/30/uDGjqHKANykIg4U.gif" alt="圆弧前进" /><figcaption aria-hidden="true">圆弧前进</figcaption>
</figure>
<h5 id="圆弧后退">圆弧后退</h5>
<figure>
<img data-src="https://i.loli.net/2021/08/30/aWeYsn983ZXRbE7.gif" alt="圆弧后退" /><figcaption aria-hidden="true">圆弧后退</figcaption>
</figure>
<h2 id="基于模型设计">基于模型设计</h2>
<h3 id="运动学模型">运动学模型</h3>
<h3 id="动力学模型">动力学模型</h3>
<h2 id="参考">参考</h2>
<blockquote>
<ol type="1">
<li><a href="https://zgh551.github.io/2020/02/23/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-Stanley%E6%B3%95/#more">前轴反馈控制算法</a></li>
<li><a href="https://zgh551.github.io/2020/02/26/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-%E5%90%8E%E8%BD%AE%E4%BD%8D%E7%BD%AE%E5%8F%8D%E9%A6%88/">后轴反馈控制算法</a></li>
<li><a href="https://zgh551.github.io/2020/02/23/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-%E7%BA%AF%E8%BF%BD%E8%B8%AA%E6%B3%95/">纯追踪控制算法</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>控制算法</category>
        <category>路径跟踪</category>
      </categories>
      <tags>
        <tag>路径跟踪</tag>
        <tag>纯追踪法</tag>
        <tag>动力学模型</tag>
        <tag>Stanley法</tag>
        <tag>运动学模型</tag>
        <tag>转向控制</tag>
      </tags>
  </entry>
  <entry>
    <title>车辆停车优化</title>
    <url>/2019/11/11/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-%E8%BD%A6%E8%BE%86%E5%81%9C%E8%BD%A6%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>车辆控制中，如何舒适平衡的停车也是一个比较讲究的事。日常生活中，对于一个刚接触车的新手，控车时可能会猛踩刹车，给人一种很冲的感觉。但是对于老司机，每次踩刹车都是先轻踩，然后逐渐增大踩刹车的力度，这样对于乘客来说就会感觉很舒适。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/T3i8DBrFA7zSRPv.jpg" alt="世纪公园" /><figcaption aria-hidden="true">世纪公园</figcaption>
</figure>
<span id="more"></span>
<h2 id="模型">模型</h2>
<p>为了模拟出舒适的停车体验，使用变减速度的速度模型进行车辆停车控制。假设<strong>加速度的变化率</strong>为<span class="math inline">\(\dot{a}\)</span>，则<strong>加速度</strong>与<strong>加速度变化率</strong>的关系为</p>
<p><span class="math display">\[
\dot{a} * t = a \tag{1}
\]</span></p>
<p>对应的减速度曲线如下图所示：</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/exlCYdmJbpOk1IA.png" alt="减速度曲线" /><figcaption aria-hidden="true">减速度曲线</figcaption>
</figure>
<p>对等式(1)求导得<strong>速度</strong>与<strong>加速度的变化率</strong>的关系为 <span class="math display">\[
v_0 - \int_0^{t}a*dt = v \Longrightarrow v_0 - \frac{1}{2}\dot{a}*t^2 = v \tag{2}
\]</span></p>
<p>由于减速度一直变化，对应的速度曲线如下图所示：</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/peAHWyGjz6cCm8L.png" alt="速度曲线" /><figcaption aria-hidden="true">速度曲线</figcaption>
</figure>
<p>图中速度曲线下方的面积<span class="math inline">\(S\)</span>为行驶的位移，根据上述速度曲线，车辆运动模型如下：</p>
<p><span class="math display">\[
\int_0^{t}vdt = S \Longrightarrow v_0*t - \frac{1}{6}\dot{a}t^3 = S
\]</span></p>
<p>当速度从<span class="math inline">\(v_0\)</span>下降到0的过程中，时间<span class="math inline">\(t_0\)</span>为：</p>
<p><span class="math display">\[
v_0 - \frac{1}{2}\dot{a}*t^2 = 0 \Longrightarrow t_0 = {(\frac{2*v_0}{\dot{a}})}^{\frac{1}{2}}
\]</span></p>
<p>将时间<span class="math inline">\(t_0\)</span>代入得：</p>
<p><span class="math display">\[
t_0*(v_0 - \frac{1}{6}\dot{a}{t_0}^2) = S \Longrightarrow {(\frac{2*v_0}{\dot{a}})}^{\frac{1}{2}} * (v_0 - \frac{1}{6}\dot{a}\frac{2*v_0}{\dot{a}}) = S\\
{(\frac{2*v_0}{\dot{a}})}^{\frac{1}{2}}*\frac{2*v_0}{3} = S
\]</span></p>
<p>计算<span class="math inline">\(\dot{a}\)</span>得：</p>
<p><span class="math display">\[
\dot{a} = \frac{8 {v_0}^3}{9S^2}
\]</span></p>
<p>所以当控制车辆减速时，根据当前车辆速度<span class="math inline">\(v_0\)</span>和距离停车点的位移<span class="math inline">\(S\)</span>，计算出减速度的增量<span class="math inline">\(\dot{a}\)</span>，控制输出的减速度<span class="math inline">\(a = a - \dot{a}*dt\)</span>。</p>
]]></content>
      <categories>
        <category>控制算法</category>
      </categories>
      <tags>
        <tag>速度曲线</tag>
      </tags>
  </entry>
  <entry>
    <title>控制算法-运动学模型</title>
    <url>/2019/12/02/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-%E8%BF%90%E5%8A%A8%E5%AD%A6%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>车辆横向运动学模型描述了车辆横向运动的数学模型，该模型不考虑车辆的受力情况。一般考虑运动学模型时，将车辆模型简化成单车模型(bicycle model)。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/ot5fGZUwzhgNx94.jpg" alt="菊花展" /><figcaption aria-hidden="true">菊花展</figcaption>
</figure>
<span id="more"></span>
<h2 id="单车模型">单车模型</h2>
<p><img data-src="https://i.loli.net/2021/08/30/vNEmAlxMSaX9cWu.png" style="zoom: 80%;" /></p>
<p>单车模型中：</p>
<ul>
<li><p><strong>左右轮等效为单个轮子</strong> 左右前轮合并为单个轮子，其中心点为<span class="math inline">\(A\)</span>点，同样后轮等效后的中心点为<span class="math inline">\(B\)</span>点。</p></li>
<li><p><strong>转向角</strong> 前后轮的转向角用<span class="math inline">\(\delta_f\)</span>和<span class="math inline">\(\delta_r\)</span>表示，模型中前后轮都可以转向，对于只有前轮转向的系统，后轮转向角<span class="math inline">\(\delta_r\)</span>可以设置为0.</p></li>
<li><p><strong>重心</strong> 点<span class="math inline">\(C\)</span>代表车辆的重心，<span class="math inline">\(A\)</span>点和<span class="math inline">\(B\)</span>点到重心的距离分别用<span class="math inline">\(l_f\)</span>和<span class="math inline">\(l_r\)</span>表示，轴距表示为<span class="math inline">\(L = l_f + l_r\)</span>。</p></li>
<li><p><strong>速度</strong> 车辆重心的速度用<span class="math inline">\(V\)</span>表示，与车辆纵向轴的夹角为<span class="math inline">\(\beta\)</span>，该角度叫做车辆的滑移角。</p></li>
<li><p><strong>运动描述</strong> 假设车辆平动，车辆运动状态可以用三个坐标量描述：<span class="math inline">\(X\)</span> 、 <span class="math inline">\(Y\)</span> 和 <span class="math inline">\(\psi\)</span>。其中<span class="math inline">\((X,Y)\)</span>代表车辆重心的位置，<span class="math inline">\(\Psi\)</span>描述了车辆的方向。</p></li>
<li><p><strong>条件假设</strong> 假设速度矢量<span class="math inline">\(V\)</span>的方向在点<span class="math inline">\(A\)</span>点和<span class="math inline">\(B\)</span>点的方向与转向角的方向相同，换句话说，在A点的速度矢量与车辆纵轴的夹角为<span class="math inline">\(\delta_f\)</span>，同样<span class="math inline">\(B\)</span>点的速度矢量与车辆纵轴的夹角为<span class="math inline">\(\delta_r\)</span>。也就是说前后轮的滑移角都为0。该条件假设成立前提的是车辆速度很低(&lt;5m/s)，此时轮胎产生的横向力很小，可以忽略。</p></li>
<li><p><strong>轨迹半径</strong> 点<span class="math inline">\(O\)</span>代表车辆的瞬时旋转中心，线段<span class="math inline">\(AO\)</span>与<span class="math inline">\(BO\)</span>与前后两个转轮方向垂直，他们的交点即为<span class="math inline">\(O\)</span>点，线段<span class="math inline">\(OC\)</span>的长度代表车辆的轨迹半径<span class="math inline">\(R\)</span>。</p></li>
<li><p><strong>航迹角</strong> 车辆重心处的速度垂直于<span class="math inline">\(OC\)</span>,车辆速度矢量与车辆纵轴的夹角为<span class="math inline">\(\beta\)</span>，车辆的航向角为<span class="math inline">\(\psi\)</span>，则航迹角为<span class="math inline">\(\gamma = \psi + \beta\)</span>。</p></li>
</ul>
<h2 id="运动方程">运动方程</h2>
<h3 id="概述-1">概述</h3>
<p>运动方程可以根据单车模型几何关系推导出，下面根据单车模型的几何关系，推导出车辆运动的微分方程。</p>
<h3 id="姿态信息偏航角">姿态信息(偏航角)</h3>
<p>三角形<span class="math inline">\(OCA\)</span>根据正弦定理得</p>
<p><span class="math display">\[
\frac{\sin(\delta_f - \beta)}{l_f} = \frac{\sin(\frac{\pi}{2} - \delta_f)}{R} \tag{1}
\]</span></p>
<p>同理，三角形<span class="math inline">\(OCB\)</span>根据正弦定理可得</p>
<p><span class="math display">\[
\frac{\sin(\beta - \delta_r)}{l_r} = \frac{\sin(\frac{\pi}{2} + \delta_r)}{R} \tag{2}
\]</span></p>
<p>根据<strong>和差定理</strong>，等式(1)得</p>
<p><span class="math display">\[
\frac{\sin(\delta_f)\cos(\beta) - \cos(\delta_f)\sin(\beta)}{l_f} = \frac{\cos(\delta_f)}{R} \tag{3}
\]</span></p>
<p>同理，根据等式(2)得</p>
<p><span class="math display">\[
\frac{\cos(\delta_r)\sin(\beta) - \cos(\beta)\sin(\delta_r)}{l_r} = \frac{\cos(\delta_f)}{R} \tag{4}
\]</span></p>
<p>等式(3)两边同时乘<span class="math inline">\(\frac{l_f}{\cos(\delta_f)}\)</span>得</p>
<p><span class="math display">\[
\tan(\delta_f)\cos(\beta) - sin(\beta) = \frac{l_f}{R} \tag{5}
\]</span></p>
<p>同理，等式(4)两边同时乘<span class="math inline">\(\frac{l_r}{\cos(\delta_r)}\)</span>得</p>
<p><span class="math display">\[
sin(\beta) - \tan(\delta_r)\cos(\beta) = \frac{l_r}{R} \tag{6}
\]</span></p>
<p>等式(5)和(6)相加得</p>
<p><span class="math display">\[
\{\tan(\delta_f) - \tan(\delta_r)\}\cos(\beta) = \frac{l_f + l_r}{R} \tag{7}
\]</span></p>
<p>根据条件假设，车辆速度很低，车辆的轨迹半径变化就很慢。车辆偏航角的变化率(<span class="math inline">\(\dot{\psi}\)</span>)可以近似等于车辆的角速度(<span class="math inline">\(\omega\)</span>)。根据车辆角速度<span class="math inline">\(\omega = \frac{V}{R}\)</span>得</p>
<p><span class="math display">\[
\dot{\psi} = \frac{V}{R} \tag{8}
\]</span></p>
<p>将等式(8)带入等式(7)中，消除<span class="math inline">\(R\)</span>项得</p>
<p><span class="math display">\[
\dot{\psi} = \frac{V\cos(\beta)}{l_f + l_r}\{\tan(\delta_f) - \tan(\delta_r)\} \tag{9}
\]</span></p>
<p>上述等式一共三个输入变量：<span class="math inline">\(\delta_f\)</span> 、<span class="math inline">\(\delta_r\)</span>和<span class="math inline">\(V\)</span>。其中<span class="math inline">\(\delta_f\)</span>和<span class="math inline">\(\delta_r\)</span>是车辆的转向角，可以通过车身传感器获得。<span class="math inline">\(V\)</span>是一个外部变量，可以假设其为时变函数，可以从纵向控制中获得。</p>
<h4 id="滑移角beta的计算">滑移角<span class="math inline">\(\beta\)</span>的计算</h4>
<p>等式(5)乘以<span class="math inline">\(l_r\)</span>，</p>
<p><span class="math display">\[
\tan(\delta_f)\cos(\beta)l_r - sin(\beta)l_r = \frac{l_f*l_r}{R} \tag{10}
\]</span></p>
<p>等式(6)乘以<span class="math inline">\(l_f\)</span>得</p>
<p><span class="math display">\[
sin(\beta)l_f - \tan(\delta_r)\cos(\beta)l_f = \frac{l_f*l_r}{R} \tag{11}
\]</span></p>
<p>等式(10)和(11)相减得</p>
<p><span class="math display">\[
\cos(\beta)(l_f\tan(\delta_r) + l_r\tan(\delta_f)) = \sin(\beta)(l_f + l_r) \tag{12}
\]</span></p>
<p>等式(12)两端同时乘以<span class="math inline">\(\frac{1}{\cos(\beta)}\)</span>得</p>
<p><span class="math display">\[
\tan(\beta) = \frac{l_f\tan(\delta_r) + l_r\tan(\delta_f)}{l_f + l_r} \tag{13}
\]</span></p>
<p>故取反三角函数得</p>
<p><span class="math display">\[
\beta = \arctan(\frac{l_f\tan(\delta_r) + l_r\tan(\delta_f)}{l_f + l_r} \tag{13})
\]</span></p>
<h3 id="位置信息">位置信息</h3>
<p>根据单车模型得</p>
<p><span class="math display">\[
\dot{X} = V\cos(\beta + \psi) \tag{14}
\]</span> <span class="math display">\[
\dot{Y} = V\sin(\beta + \psi) \tag{15}
\]</span></p>
<h2 id="补充">补充</h2>
<p><img data-src="https://i.loli.net/2021/08/30/CZdbvJf1uQzR47S.png" style="zoom: 80%;" /></p>
<p>由上图可知，<span class="math inline">\(l_w\)</span>为车轴宽度，为了避免与上述单车模型的转向角定义重复，使用<span class="math inline">\(\delta_o\)</span>表示外部转向角，<span class="math inline">\(\delta_i\)</span>表示内部转向角。由于轴距<span class="math inline">\(L = l_f + l_r\)</span>远远小于轨迹半径<span class="math inline">\(R\)</span>，滑移角<span class="math inline">\(\beta\)</span>接近于0。一般车辆模型后轴为固定轴，故<span class="math inline">\(\delta_r\)</span>为0，所以等式(9)可以近似为</p>
<p><span class="math display">\[
\dot{\psi} = \frac{V}{L}\tan(\delta_f) \tag{16}
\]</span></p>
<p>由于<span class="math inline">\(\delta_f\)</span>很小</p>
<p><span class="math display">\[
\tan(\delta_f) \approx \delta_f \tag{17}
\]</span></p>
<p>根据等式(8)和等式(16)得</p>
<p><span class="math display">\[
\frac{\dot{\psi}}{V} \approx \frac{\delta_f}{L} = \frac{1}{R} \tag{18}
\]</span></p>
<p>故不区分前后轴，等效转向角为</p>
<p><span class="math display">\[
\delta = \frac{L}{R} \tag{19}
\]</span></p>
<p>由于内外轮的转弯半径不同，根据等式(19),外轮转角为</p>
<p><span class="math display">\[
\delta_o = \frac{L}{R + \frac{l_w}{2}} \tag{20}
\]</span></p>
<p>内轮转角为</p>
<p><span class="math display">\[
\delta_i = \frac{L}{R - \frac{l_w}{2}} \tag{21}
\]</span></p>
<p>故前轮平均转向角为</p>
<p><span class="math display">\[
\delta = \frac{\delta_o + \delta_i}{2} = \frac{L}{R - \frac{l_w^2}{4R}} \tag{22}
\]</span></p>
<p>由于<span class="math inline">\(\frac{l_w^2}{4R}\)</span>项中，<span class="math inline">\(l_w\)</span>远远小于<span class="math inline">\(R\)</span>,且<span class="math inline">\(l_w\)</span>的二次项更小，故</p>
<p><span class="math display">\[
\frac{l_w^2}{4R} \cong 0 \tag{23}
\]</span></p>
<p>所以等式(22)可以近似为</p>
<p><span class="math display">\[
\delta = \frac{L}{R} \tag{24}
\]</span></p>
<p>比较等式(20)和(21)知，<span class="math inline">\(\delta_i\)</span>始终大于<span class="math inline">\(\delta_o\)</span>，故</p>
<p><span class="math display">\[
\delta_i - \delta_o = \frac{L}{R - \frac{l_w}{2}} - \frac{L}{R + \frac{l_w}{2}} \quad\\
=\frac{Ll_w}{R^2 - \frac{l_w^2}{4}} \qquad\\
\cong \frac{L}{R^2}l_w = \delta^2\frac{l_w}{L} \tag{25}
\]</span></p>
<p>根据等式(25)可知，前轮内外转向角的差值接近于平均转向角的二次方，所以当前轮转向角较大时，内外轮的转向角误差就越大。</p>
<h2 id="结论">结论</h2>
<p>车辆运动模型基于单车模型推导，推导过程不考虑车辆受到的横向力，故该模型只适用于车辆速度很低的情形。</p>
<p><span class="math display">\[
a = \frac{mV^2}{R} \tag{26}
\]</span></p>
<p>根据等式(26)知，速度很小时，车辆受到的向心力可以忽略不记，所以才有公式(8)的成立。所以当车辆的运动场景速度较低时，可以使用该模型描述车辆的运动。</p>
<h3 id="微分方程形式">微分方程形式</h3>
<p>根据等式(9)、(14)和(15)，对于前轮转向系统，<span class="math inline">\(\delta_r = 0\)</span>，可得</p>
<p><span class="math display">\[
\dot{X} = V\cos(\beta + \psi) \qquad\\
\dot{Y} = V\sin(\beta + \psi) \qquad\\
\dot{\psi} = \frac{V\cos(\beta)\tan(\delta_f)}{L}
\]</span></p>
<p>其中</p>
<p><span class="math display">\[
\beta = \arctan(\frac{l_r\tan(\delta_f)}{l_f + l_r})
\]</span></p>
<p>假设车辆重心点在后轴中心点，则<span class="math inline">\(beta \cong 0\)</span>，由上述微分方程得</p>
<p><span class="math display">\[
\dot{X} = V\cos(\psi) \quad\\
\dot{Y} = V\sin(\psi) \quad\\
\dot{\psi} = \frac{V\tan(\delta_f)}{L}
\]</span></p>
<h2 id="参考">参考</h2>
<ol type="1">
<li>" vehicle dynamics and control "</li>
</ol>
]]></content>
      <categories>
        <category>控制算法</category>
        <category>车辆模型</category>
      </categories>
      <tags>
        <tag>车辆模型</tag>
        <tag>车辆控制</tag>
        <tag>运动模型</tag>
        <tag>单车模型</tag>
        <tag>Kinematic Model</tag>
        <tag>bycycle model</tag>
      </tags>
  </entry>
  <entry>
    <title>控制算法-非时间参考的车辆路径跟踪</title>
    <url>/2019/12/23/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95-%E9%9D%9E%E6%97%B6%E9%97%B4%E5%8F%82%E8%80%83%E7%9A%84%E8%BD%A6%E8%BE%86%E8%B7%AF%E5%BE%84%E8%B7%9F%E8%B8%AA/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>基于非时间的参考的路径跟踪方法最早应用于机器人的路径跟踪系统，通过引入非时间参考量代替时间参考量，解决传统路径跟踪方法中将期望轨迹视为时间函数的问题。该方法选择移动机器人实际路径在某参考系下的x 轴投影作为非时间参考量。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/KaPA5HQMmo8WnDZ.jpg" alt="国家会议中心" /><figcaption aria-hidden="true">国家会议中心</figcaption>
</figure>
<span id="more"></span>
<h2 id="非时间参考量下的微分方程">非时间参考量下的微分方程</h2>
<h3 id="定义">定义</h3>
<p>定义一个非时间参考的标量<span class="math inline">\(s\)</span>,该<span class="math inline">\(s\)</span>为时间t的单调递增函数。</p>
<p><span class="math display">\[
\left\{
\begin{array}{rl} 
&amp;s = S(t)\\
&amp;\dot{S}(t) &gt; 0
\end{array} 
\right.\tag{1}
\]</span></p>
<p>在车辆控制中，可以定义车辆的位移<span class="math inline">\(x\)</span>为非时间参考量，为了满足随时间递增的要求，且泊车时速度为负值<span class="math inline">\((v&lt;0)\)</span>，选取的非时间参考量为</p>
<p><span class="math display">\[
f = -x(t) \tag{2}
\]</span></p>
<p>对上式求导得</p>
<p><span class="math display">\[
\dot{f}(t) = -v(t)\cos\psi(t) \tag{3}
\]</span></p>
<p>由于车辆泊车过程中偏航角<span class="math inline">\(\psi \in (-\frac{\pi}{2},\frac{\pi}{2})\)</span>，故<span class="math inline">\(\dot{f}(t)&gt;0\)</span>，满足非时间参考量随时间变化单调递增得要求。</p>
<p>基于非时间参考的车辆运动学方程可表示为: <span class="math display">\[
\left \{
\begin{array}{cl}
&amp;\dfrac{dx}{df}= \dfrac{dx}{dt}\dfrac{dt}{df} = \dfrac{\dot{x}(t)}{\dot{f}(t)}\\
&amp;\dfrac{dy}{df}= \dfrac{dy}{dt}\dfrac{dt}{df} = \dfrac{\dot{y}(t)}{\dot{f}(t)}\\
&amp;\dfrac{d\psi}{df}= \dfrac{d\psi}{dt}\dfrac{dt}{df} = \dfrac{\dot{\psi}(t)}{\dot{f}(t)}
\end{array}
\right. \tag{4}
\]</span></p>
<h3 id="目标路径曲线">目标路径曲线</h3>
<p>假设目标路径曲线函数为<span class="math inline">\(y_r = F(x_r)\)</span>，如果车辆可以无误差地跟踪，当车辆后轴中心横坐标为<span class="math inline">\(x_r\)</span>时，对应的纵坐标为<span class="math inline">\(y_r\)</span>、航向角为<span class="math inline">\(\psi_r\)</span>、前轮等效转角为<span class="math inline">\(\delta_r\)</span>。</p>
<ul>
<li>目标航向角<span class="math inline">\(\psi_r\)</span>计算</li>
</ul>
<p>目标航向角<span class="math inline">\(\psi_r\)</span>可以看作是函数<span class="math inline">\(y_r = F(x_r)\)</span>在点<span class="math inline">\(x_r\)</span>处的斜率所对应的航向角度，即</p>
<p><span class="math display">\[
\tan(\psi_r) = \dot{F}(x_r)= \frac{dy_r}{dx_r} \tag{5}
\]</span></p>
<p>通过反三角函数求得目标航向角为</p>
<p><span class="math display">\[
\psi_r = \arctan\bigl(\dot{F}(x_r)\bigr)= \arctan(\frac{dy_r}{dx_r}) \tag{6}
\]</span></p>
<ul>
<li>目标转向角<span class="math inline">\(\delta_r\)</span>计算</li>
</ul>
<p>根据转向角的几何关系得</p>
<p><span class="math display">\[
\delta_r = \arctan(l*k) \tag{7}
\]</span></p>
<p>其中，<span class="math inline">\(l\)</span>代表车辆轴距、<span class="math inline">\(k\)</span>代表点<span class="math inline">\(x_r\)</span>处的目标路径曲线的曲率。</p>
<p>根据轨迹函数<span class="math inline">\(y_r = F(x_r)\)</span>的一阶导数和二阶导数，曲率计算公式表示如下：</p>
<p><span class="math display">\[
k = \frac{\rvert\ddot{F}(x_r)\rvert}{[1+\dot{F}(x_r)^{2}]^\frac{3}{2}} \tag{8}
\]</span></p>
<p>根据目标路径曲线，如果某段曲线是凸的，对应的二阶导数<span class="math inline">\(\ddot{F}(x_r) &lt; 0\)</span>。很明显，当偏航角满足<span class="math inline">\(\psi \in (-\frac{\pi}{2},\frac{\pi}{2})\)</span>时，如果希望车辆跟踪凸形路线，对应的转向角应该为负值。同理，当曲线某段是凹形，对应的二阶导数<span class="math inline">\(\ddot{F}(x_r) &gt; 0\)</span>，要想继续跟踪路线，转向角应该为正值。考虑<span class="math inline">\(\delta_r\)</span>的正负性与曲线函数<span class="math inline">\(\ddot{F}(x_r)\)</span>的二阶导数符号一致，等式(8)的绝对值符号可以消除，将其带入等式(7)得</p>
<p><span class="math display">\[
\delta_r = \arctan\Biggl( l*\frac{\ddot{F}(x_r)}{[1+\dot{F}(x_r)^{2}]^\frac{3}{2}}\Biggr)\tag{9}
\]</span></p>
<p>将等式(5)带入等式(9)得</p>
<p><span class="math display">\[
\delta_r = \arctan\Bigl(l*\cos(\psi_r)^{3}\ddot{F}(x_r)\Bigr) \tag{10}
\]</span></p>
<p>通过等式(6)和(10)可知，已知目标路径函数的前提下，可以计算得到横坐标为<span class="math inline">\(x_r\)</span>下的车辆理想状态参数。</p>
<p><span class="math display">\[
\left \{
\begin{array}{cl}
&amp;\psi_r = \arctan\bigl(\dot{F}(x_r)\bigr)\\
&amp;\delta_r = \arctan\Bigl(l*\cos(\psi_r)^{3}\ddot{F}(x_r)\Bigr)
\end{array}
\right. \tag{11}
\]</span></p>
<h3 id="车辆跟踪误差模型">车辆跟踪误差模型</h3>
<p>车辆的跟踪误差表示如下： <span class="math display">\[
\left \{
\begin{array}{rl}
&amp;e_x= 0\\
&amp;e_y = y_r - y\\
&amp;e_\psi = \psi_r - \psi
\end{array}
\right.\tag{12}
\]</span></p>
<p>其中，<span class="math inline">\(y\)</span>和<span class="math inline">\(\psi\)</span>为车辆后轴中心点横坐标为<span class="math inline">\(x_r\)</span>时，对应的车辆实际状态参数。<span class="math inline">\(e_x\)</span>、<span class="math inline">\(e_y\)</span>和<span class="math inline">\(e_\psi\)</span>分别表示纵向误差、横向误差和航向角误差。</p>
<p>则以非时间参考量<span class="math inline">\(f = -x(t)\)</span>为参考的路径跟踪误差微分方程如下：</p>
<ul>
<li>纵向距离误差的微分方程</li>
</ul>
<p><span class="math display">\[
\begin{array}{rl}
\dfrac{dy_e}{-dx} &amp;= \dfrac{d(y_r-y)}{-dx}\\
&amp;=\dfrac{-dy_r}{dx} + \dfrac{dy}{dx}\\
&amp;=-tan(\psi_r) + \tan(\psi)
\end{array}\tag{13}
\]</span></p>
<ul>
<li>偏航角误差微分方程</li>
</ul>
<p>由等式(10)得</p>
<p><span class="math display">\[
\tan(\delta_r) = l*\cos(\varphi_r)^{3}\ddot{F}(x_r) \tag{14}
\]</span></p>
<p>等式(5)对<span class="math inline">\(x\)</span>求导得</p>
<p><span class="math display">\[
[1 + \tan(\psi_r)^2]*\frac{d\psi_r}{dx} = \ddot{F}(x_r) \tag{15}
\]</span></p>
<p>等式(15)带入等式(14)得</p>
<p><span class="math display">\[
\begin{array}{cl}
\tan(\delta_r) &amp;= l*\cos(\psi_r)^{3}*[1+\tan(\psi_r)^{2}]*\dfrac{d\psi_r}{dx}\\
&amp;= l*\cos(\psi_r)*\dfrac{d\psi_r}{dx}
\end{array} \tag{16}
\]</span></p>
<p>由于<span class="math inline">\(\psi \in (-\frac{\pi}{2},\frac{\pi}{2})\)</span>，故<span class="math inline">\(\cos(\psi_r) \neq 0\)</span>，等式(16)移项整理得</p>
<p><span class="math display">\[
\frac{d\psi_r}{dx} = \frac{\tan(\delta_r)}{l*\cos(\psi_r)} \tag{17}
\]</span></p>
<p>根据等式(17)，可得航向角误差的微分方程为</p>
<p><span class="math display">\[
\begin{array}{rl}
\dfrac{d\psi_e}{-dx} &amp;= -\dfrac{d\psi_r}{dx} + \dfrac{d\psi}{dx}\\
&amp;=-\dfrac{\tan(\delta_r)}{l*\cos(\psi_r)} + \dfrac{\tan(\delta)}{l*\cos(\psi)}
\end{array}\tag{18}
\]</span></p>
<p>整理等式(13)和(18)得</p>
<p><span class="math display">\[
\left \{
\begin{array}{rl}
&amp; \dfrac{de_y}{-dx} = -tan(\psi_r) + \tan(\psi)\\
&amp; \dfrac{de_\psi}{-dx} = -\dfrac{\tan(\delta_r)}{l*\cos(\psi_r)} + \dfrac{\tan(\delta)}{l*\cos(\psi)}
\end{array}
\right. \tag{19}
\]</span></p>
<h2 id="滑模控制器设计">滑模控制器设计</h2>
<p>滑模控制算法因算法简单、鲁棒性好、适应性强、实用性而被广泛运用。滑模控制的核心是设计处合适的切换函数和变结构控制率，使系统状态轨迹线能快速到达设计的切换面进行滑动模态运动。</p>
<h3 id="微分方程">微分方程</h3>
<p>系统参考状态量为：</p>
<p><span class="math display">\[
\left \{
\begin{array}{rl}
&amp;x_1 = y_r - y\\
&amp;x_2 = -tan(\psi_r) + \tan(\psi)
\end{array}
\right. \tag{20}
\]</span></p>
<p>结合等式(12)、(17)，对应的微分方程为：</p>
<p><span class="math display">\[
\left \{
\begin{array}{rl}
&amp;\dot{x_1} &amp;= \dfrac{dx_1}{-dx} &amp;= \dfrac{y_r - y}{-dx} &amp;= x_2\\
&amp;\dot{x_2} &amp;= \dfrac{dx_2}{-dx} &amp;=\dfrac{-tan(\psi_r) + \tan(\psi)}{-dx} 
&amp;= \dfrac{\tan(\delta_r)}{l*\cos(\psi_r)^3} - \dfrac{\tan(\delta)}{l*\cos(\psi)^3}
\end{array}
\right. \tag{21}
\]</span></p>
<h3 id="滑模面">滑模面</h3>
<p>定义滑模变量<span class="math inline">\(s\)</span>为：</p>
<p><span class="math display">\[
s = x_2 + c \cdot x_1 \tag{22}
\]</span></p>
<p>其中<span class="math inline">\(c &gt; 0\)</span>，结合等式(20)和(21)，对等式(22)求导得：</p>
<p><span class="math display">\[
\dot{s}=\frac{ds}{-dx} = \dfrac{\tan(\delta_r)}{l*\cos(\psi_r)^3} -\dfrac{\tan(\delta)}{l*\cos(\psi)^3} + c \cdot \bigl(\tan(\psi)-tan(\psi_r)\bigr) \tag{23}
\]</span></p>
<h3 id="基于趋近律的滑模控制">基于趋近律的滑模控制</h3>
<p>采用指数趋近率<span class="math inline">\(\dot{s} = -\rho \cdot sign(s) - k\cdot s\)</span>，可以减弱变结构控制系统的抖振。通过调整趋近率参数<span class="math inline">\(\rho\)</span>和<span class="math inline">\(k\)</span>，既可以保证滑动模态到达过程的动态品质，又可以减弱控制信号的高频抖振，但是较大的<span class="math inline">\(\rho\)</span>会引起抖振。</p>
<p>采用指数趋近率为</p>
<p><span class="math display">\[
\dot{s} = -\rho \cdot sign(s) - k\cdot s \tag{24}
\]</span></p>
<p>其中<span class="math inline">\(\rho &gt; 0\)</span>、<span class="math inline">\(k &gt; 0\)</span>、<span class="math inline">\(sign(s)\)</span>为符号函数。</p>
<h3 id="稳定判据">稳定判据</h3>
<p>定义李亚普洛夫函数(<strong>Lyapunov</strong>)形式如下：</p>
<p><span class="math display">\[
V = \frac{1}{2}s^2 \tag{25}
\]</span></p>
<p>为了使滑模变量在平衡点<span class="math inline">\(s = 0\)</span>处渐进稳定，根据李亚普洛夫稳定判据，必须满足下面两个条件：</p>
<ol type="1">
<li><span class="math inline">\(\begin{array}{rl}\dot{V} &lt; 0 &amp;(s \neq 0)\end{array}\)</span></li>
<li><span class="math inline">\(\lim_{\rvert s\rvert \to \infty}V = \infty\)</span></li>
</ol>
<p>由等式(25)的形式可知，条件2明显满足。将等式(24)所示的指数趋近率代入，并计算<span class="math inline">\(\dot{V}\)</span>得</p>
<p><span class="math display">\[
\begin{array}{rl}
\dot{V} = s\dot{s} &amp;= s(-\rho \cdot sign(s) - k\cdot s)\\
&amp;=-k \cdot s^2 - \rho \cdot sign(s) \cdot s\\
&amp;= -k \cdot \rvert s \rvert ^2 - \rho \cdot \rvert s \rvert
\end{array} \tag{26}
\]</span></p>
<p>其中<span class="math inline">\(k &gt; 0\)</span>，<span class="math inline">\(\rho &gt; 0\)</span>，很明显等式(26)中<span class="math inline">\(\dot{V} &lt; 0\)</span>，即满足条件1。因此采用等式(24)的指数趋近率可以使滑模变量渐进稳定。</p>
<h3 id="控制率">控制率</h3>
<p>驱使滑模变量<span class="math inline">\(s\)</span>变为0的控制率可以根据等式(23)和(24)得：</p>
<p><span class="math display">\[
\dfrac{\tan(\delta_r)}{l*\cos(\psi_r)^3} -\dfrac{\tan(\delta)}{l*\cos(\psi)^3} + c \cdot \bigl(\tan(\psi)-tan(\psi_r)\bigr) = -\rho \cdot sign(s) - k\cdot s \tag{27}
\]</span></p>
<p>根据等式(27)，提取<span class="math inline">\(\delta\)</span>项得</p>
<p><span class="math display">\[
\delta = \arctan 
\Biggl(
    l*\cos(\psi)^3 \cdot 
    \Bigl(
        \dfrac{\tan(\delta_r)}{l*\cos(\psi_r)^3} +
        c \cdot \bigl(\tan(\psi)-tan(\psi_r)\bigr) +
        \rho \cdot sign(s) +
        k\cdot s
    \Bigr)
\Biggr) \tag{28}
\]</span></p>
<p>等式(28)进一步化简为如下形式：</p>
<p><span class="math display">\[
\delta = \arctan
\Biggl(
l*\cos(\psi)^3 \cdot 
    \Bigl(
        \dfrac{\tan(\delta_r)}{l*\cos(\psi_r)^3} +
        c \cdot x_2 +
        \rho \cdot sign(s) +
        k\cdot s
    \Bigr)
\Biggr) \tag{29}
\]</span></p>
<h3 id="切换函数">切换函数</h3>
<p>由于上述滑模控制器中使用的是符号函数<span class="math inline">\(sign(s)\)</span>，系统会出现不连续的开关特性，使得滑模变结构系统在滑动模态下存在高频的振动现象，从而导致路径跟踪过程中控制器出现较大波动，继而影响泊车的控制精度。</p>
<p>为了抑制振动，本文分别采用饱和函数<span class="math inline">\(sat(\dfrac{s}{\Delta})\)</span>和<span class="math inline">\(sigmoid\)</span>函数代替符号函数<span class="math inline">\(sign(s)\)</span>，保证系统的切换面附近光滑连续。</p>
<ul>
<li><strong>Sigmoid Function</strong>: <span class="math display">\[
Sigmoid(x) = \frac{x}{\rvert x \rvert + \varepsilon} \tag{30}
\]</span></li>
</ul>
<p>其中<span class="math inline">\(\varepsilon\)</span>是很小的正标量，下图为<span class="math inline">\(\varepsilon = 0.001\)</span>时，<span class="math inline">\(Sigmoid(x)\)</span>函数的波形图入下：</p>
<p><img data-src="https://i.loli.net/2021/08/30/NoXcDfzSPqBFMQJ.png" /></p>
<ul>
<li><strong>Sat Function</strong>:</li>
</ul>
<p><span class="math display">\[
Sat(\frac{x}{\Delta}) =
\left \{
\begin{array}{rl}
&amp;1  &amp; , &amp;x \geq \Delta\\
&amp;\dfrac{x}{\Delta}  &amp; , &amp;\rvert x \rvert &lt; \Delta\\
&amp;-1 &amp; , &amp;x \leq -\Delta
\end{array}
\right. \tag{31}
\]</span></p>
<p>其中，<span class="math inline">\(\Delta\)</span>为很小的正标量，代表边界层的厚度，当<span class="math inline">\(\Delta = 0.05\)</span>时，<span class="math inline">\(Sat(x)\)</span>波形图如下：</p>
<p><img data-src="https://i.loli.net/2021/08/30/Uag93Qfq14nL6uh.png" /></p>
<h2 id="性能分析">性能分析</h2>
<p>根据如下控制系统框图，搭建仿真环境。</p>
<p><img data-src="https://i.loli.net/2021/08/30/i8oHQE4J5k1UPeq.png" style="zoom:67%;" /></p>
<ul>
<li>滑模变量<span class="math inline">\(s\)</span> 下图所示，是滑模变量<span class="math inline">\(s\)</span>随距离<span class="math inline">\(x\)</span>变化的图形。随着距离的增大，滑模变量<span class="math inline">\(s\)</span>趋近于0，系统也趋近于稳定，但是滑模变量在0附近存在抖振。</li>
</ul>
<p><img data-src="https://i.loli.net/2021/08/30/F4KWyDJEi8BwRbC.png" /></p>
<ul>
<li>相图 如下图所示，是系统的相图，可以看出，系统逐渐收敛于原点。</li>
</ul>
<figure>
<img data-src="https://i.loli.net/2021/08/30/gOeB8KIDYdZkQoP.png" alt="相图" /><figcaption aria-hidden="true">相图</figcaption>
</figure>
<ul>
<li>路径跟踪图 如下图所示，是系统的路径跟踪波形图。刚开始时，跟踪存在偏差。经过一段时间的修正，跟踪路径趋近于一致。</li>
</ul>
<figure>
<img data-src="https://i.loli.net/2021/08/30/PmykNo5iZcAXsap.png" alt="路径跟踪图" /><figcaption aria-hidden="true">路径跟踪图</figcaption>
</figure>
<ul>
<li>转向角图 如下图所示，是系统控制产生的转向角信号。从图中可以发现，系统在趋于稳定时，控制信号存在抖振现象。</li>
</ul>
<figure>
<img data-src="https://i.loli.net/2021/08/30/6UVk2o1cSsT5iym.png" alt="转向角图" /><figcaption aria-hidden="true">转向角图</figcaption>
</figure>
<ul>
<li>轨迹误差图 如下图所示，是系统产生的轨迹误差图，随着时间推移，估计误差趋近于0。</li>
</ul>
<figure>
<img data-src="https://i.loli.net/2021/08/30/J4fnwU5QmtpLS78.png" alt="轨迹误差图" /><figcaption aria-hidden="true">轨迹误差图</figcaption>
</figure>
]]></content>
      <categories>
        <category>控制算法</category>
        <category>路径跟踪</category>
      </categories>
      <tags>
        <tag>路径跟踪</tag>
        <tag>滑模控制</tag>
        <tag>非时间参考系</tag>
      </tags>
  </entry>
  <entry>
    <title>碰撞检测-apollo</title>
    <url>/2020/11/04/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B-apollo/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>本文主要分析<strong>aplollo</strong>代码中关于障碍物碰撞检测相关算法，该算法通过将车辆抽象成二维矩形盒(Box)，建立点与矩形盒、线段与矩形盒、矩形盒与矩形盒的碰撞检测算法。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/WiSODpuQYsy4KkC.jpg" alt="大连" /><figcaption aria-hidden="true">大连</figcaption>
</figure>
<span id="more"></span>
<h2 id="碰撞判断">碰撞判断</h2>
<h3 id="点与矩形盒">点与矩形盒</h3>
<p>关于点与矩形盒子的位置关系,可能情况为点在矩形盒内,点在矩形边框上和点在矩形盒外部,如果点在矩形盒的外部,可以求取点到矩形盒的距离值.</p>
<h4 id="判定点是否在矩形盒内">判定点是否在矩形盒内</h4>
<p>如下图所示,红色圆点与矩形盒的关系如下图左侧,为了便于判定红点是否在矩形盒内,将下图左侧整体按照航向角顺时针旋转<span class="math inline">\(\theta\)</span>角度,得到下图右侧状态.此时,只需要判定红点的坐标<span class="math inline">\((dx,dy)\)</span>是否满足<span class="math inline">\(\mid dx \mid &lt;= length_h\)</span> 或者 <span class="math inline">\(\mid dy \mid &lt;= width_h\)</span>，则说明红点位于矩形盒内.</p>
<p><img data-src="https://i.loli.net/2020/11/04/NwXoO1iQdxHSm4R.png" alt="point_in_box" style="zoom:80%;" /></p>
<p>其中, - <span class="math inline">\(length_{half}\)</span>:车长的一半; - <span class="math inline">\(width_{half}\)</span>: 车宽的一半;</p>
<h4 id="判定点是否在矩形盒边界上">判定点是否在矩形盒边界上</h4>
<p>如下图所示,当红点位于矩形盒的边界上时,先以航向角顺时针旋转<span class="math inline">\(\theta\)</span>角度,然后通过判断旋转后的红点坐标<span class="math inline">\((dx,dy)\)</span>是否满足<span class="math inline">\(\mid \mid dx \mid - length_h \mid == 0\)</span> 或者 <span class="math inline">\(\mid \mid dy \mid - width_h \mid == 0\)</span>,则说明点红点位于矩形盒边界上.</p>
<p><img data-src="https://i.loli.net/2020/11/04/8PclGvub46QxOrR.png" alt="point_on_box_bound" style="zoom:80%;" /></p>
<p>其中,</p>
<ul>
<li><span class="math inline">\(length_{half}\)</span>:车长的一半;</li>
<li><span class="math inline">\(width_{half}\)</span>: 车宽的一半;</li>
</ul>
<h4 id="计算点到矩形盒的距离">计算点到矩形盒的距离</h4>
<p>如下图所示,点到矩形盒的距离可以分为如下三种情况:</p>
<ol type="1">
<li><code>dx &lt;= 0</code>:如果红点在<span class="math inline">\(x\)</span>轴上的投影小于等于车长距离的一半,则此时的距离可以表示为<span class="math inline">\(\mid dy \mid\)</span>;</li>
<li><code>dy &lt;= 0</code>:如果条件1不满足,即<code>dx &gt; 0</code>,则判断红点在<span class="math inline">\(y\)</span>轴上的投影是否小于等于车宽的一半,如果满足条件,则距离可以表示为<span class="math inline">\(\mid dx \mid\)</span>;</li>
<li><code>dx &gt; 0 and dy &gt; 0</code>: 如果条件1和2都不满足,则距离可以表示为红点与矩形盒边角点的距离,即<span class="math inline">\(\sqrt{dx^2 + dy^2}\)</span>;</li>
</ol>
<p><img data-src="https://i.loli.net/2020/11/06/pqGR8F4jxWJ5fCV.png" alt="point_to_box_distance" style="zoom:80%;" /></p>
<h3 id="线段与矩形盒">线段与矩形盒</h3>
<h4 id="判定线段与矩形盒是否交叠">判定线段与矩形盒是否交叠</h4>
<p>关于某线段与矩形盒关系的判定,先计算线段的长度,如果线段的长度为0,则可以把该线段当作一个点,利用点和矩形盒的距离来判断是否交叠;如果线段的长度不为0,则先进行线段与矩形盒的粗判定,即线段的起始点与终点是否落在矩形盒的一边,如下图所示,表示线段位于矩形盒一边的四种情况.如果线段不满足如下关系,则交叠关系可以通过距离来判断.</p>
<p><img data-src="https://i.loli.net/2020/11/04/9NrinbFamEds1p6.png" alt="line_to_box_outside" style="zoom:50%;" /></p>
<h4 id="计算线段到矩形盒的距离">计算线段到矩形盒的距离</h4>
<h5 id="区域划分">区域划分</h5>
<p>如下图所示,将矩形盒的外围分成如下8个区域,关于区域的划分,可以根据线段起始点和终点分别在<span class="math inline">\(x\)</span>轴和<span class="math inline">\(y\)</span>轴的投影,表示为<span class="math inline">\((p_x,p_y)\)</span>;以车辆中心<span class="math inline">\(o\)</span>为原点,则四个边角点可以表示为<span class="math inline">\((box_x,box_y)\)</span>,<span class="math inline">\((box_x,-box_y)\)</span>,<span class="math inline">\((-box_x,box_y)\)</span>,<span class="math inline">\((-box_x,-box_y)\)</span>.</p>
<p>其中,根据点在<span class="math inline">\(x\)</span>轴的投影,可以将区域值表示如下:</p>
<p><span class="math display">\[
g_x=\begin{cases}
1  &amp; \text{if } (p_x &gt;= box_x),\\
0  &amp; \text{if } (-box_x &lt; p_x &lt; box_x),\\
-1 &amp; \text{if } (p_x &lt;= -box_x),\\
\end{cases}
\]</span></p>
<p><img data-src="https://i.loli.net/2020/11/04/uriBfCcGEX3H4Sl.png" alt="line_to_box_group" style="zoom:80%;" /></p>
<p>根据上图,区域的值表示如下:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">区域</th>
<th style="text-align: center;">gx</th>
<th>gy</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td>1</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">0</td>
<td>1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">-1</td>
<td>1</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">-1</td>
<td>0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">5</td>
<td style="text-align: center;">-1</td>
<td>-1</td>
</tr>
<tr class="even">
<td style="text-align: center;">6</td>
<td style="text-align: center;">0</td>
<td>-1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">7</td>
<td style="text-align: center;">1</td>
<td>-1</td>
</tr>
<tr class="even">
<td style="text-align: center;">8</td>
<td style="text-align: center;">1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>其中,区域<span class="math inline">\((0,0)\)</span>位于矩形盒内,即线段中有一点位于矩形盒内,必定与矩形盒交叠.因此去除点位于区域<span class="math inline">\((0,0)\)</span>的情形,考虑线段两个端点与矩形盒的关系共有<span class="math inline">\(8 \times 8 = 64\)</span>种情况.</p>
<h5 id="对称变换">对称变换</h5>
<p>首先将起始点通过<span class="math inline">\(x\)</span>轴和<span class="math inline">\(y\)</span>轴对称变换,将落在区域3,4,5,6,7的点变换到区域1,2,8中.对于区域2和8,进行<span class="math inline">\(xy\)</span>轴对称变换,将区域2变换为区域8.所以经过三种轴对称转换后,起始点将会落在区域1和区域8两种区域状态. - 区域1</p>
<p>当<strong>起始点</strong>位于区域1,则将终点进行<span class="math inline">\(xy\)</span>轴对称变换,将位于区域2,3,4的终点,对称变换到区域8,7,6中.因此关于终点的所在区域的情况只需考虑落在区域1,8,7,6,5,这五个区域的情况;</p>
<ul>
<li>区域8</li>
</ul>
<p>当<strong>起始点</strong>位于区域8,对终点进行<span class="math inline">\(y\)</span>轴对称变换,将位于<span class="math inline">\(y\)</span>轴下方的区域变换到<span class="math inline">\(y\)</span>轴上方,即区域5,6,7对称变换到区域3,2,1.因此终点只需考虑区域8,1,2,3,4五个区域的请况.</p>
<p>通过上述对称变换,可以将原先的64种线段与矩形的关系减少到10种,从而减少相关计算量.</p>
<h5 id="线段与矩形盒距离计算">线段与矩形盒距离计算</h5>
<p>如下图所示,线段起始点与矩形盒边角点之间的向量表示为<span class="math inline">\(\vec{sb}\)</span>,起始点与终点之间的向量表示为<span class="math inline">\(\vec{sg}\)</span>.</p>
<ul>
<li>当<span class="math inline">\(\vec{sb}\cdot\vec{sg} &lt;= 0\)</span>时,即下图浅绿色表示的区域,此时,线段与矩形盒的距离表示为<span class="math inline">\(\mid \vec{sb}\mid\)</span>.</li>
</ul>
<p><img data-src="https://i.loli.net/2020/11/05/DknoJSP8vbcrLaU.png" alt="vector_cdot_less_zero" style="zoom:80%;" /></p>
<ul>
<li>当<span class="math inline">\(\vec{sb}\cdot\vec{sg} &gt;= \vec{sg} \cdot \vec{sg}\)</span>,即下图浅绿色区域,线段与矩形盒的距离可以表示为<span class="math inline">\(\mid \vec{sb}-\vec{sg}\mid\)</span>.</li>
</ul>
<p><img data-src="https://i.loli.net/2020/11/07/fMP1eUWuH2dngjS.png" alt="vector_cdot_length_two" style="zoom:80%;" /></p>
<ul>
<li>当上述条件都不满足时,即位于下图浅黄色区域,线段与矩形盒的距离可以表示为<span class="math inline">\(\mid \vec{sb} \mid \sin{\theta}\)</span>,可使用向量叉乘得到<span class="math inline">\(\frac{\vec{sb}\times\vec{sg}}{\mid \vec{sg} \mid}\)</span>.</li>
</ul>
<p><img data-src="https://i.loli.net/2020/11/05/j1CodMGyezNSWwB.png" alt="vector_times" style="zoom:80%;" /></p>
<h5 id="起始点区域1">起始点区域1</h5>
<ol type="1">
<li>当终点位于区域1时,直接使用上述方法计算距离值;</li>
<li>当终点位于区域8时,先判定起始点与终点的<span class="math inline">\(x\)</span>轴坐标的关系,当起始点坐标的<span class="math inline">\(x\)</span>轴坐标大于终点的<span class="math inline">\(x\)</span>轴坐标,则距离值为<span class="math inline">\(\mid g_x - b_x \mid\)</span>,否则按照上述方法计算距离值;</li>
<li>当终点位于区域7时,先判定起始点与终点的<span class="math inline">\(x\)</span>轴坐标的关系,选取不同的矩形盒的边角点;</li>
<li>当终点位于区域6时,先判定线段与矩形盒是否交叠,如下图所示,通过计算向量叉乘<span class="math inline">\(\vec{sg}\times\vec{sb}\)</span>,判断线段是否与矩形盒交叠.</li>
</ol>
<figure>
<img data-src="https://i.loli.net/2020/11/05/XS4Q7WVujPgZhmc.png" alt="vector_times_less_zero" /><figcaption aria-hidden="true">vector_times_less_zero</figcaption>
</figure>
<ol start="5" type="1">
<li>当终点位于区域5时,矩形盒的边角点分两种,首先判断与右下角的边角点的关系,如果不交叠则直接按上述方法计算距离值,否则判断与左上角边角点的关系,如果无交叠则按上述方法计算距离值.</li>
</ol>
<figure>
<img data-src="https://i.loli.net/2020/11/05/QZCTfSRhJEa2zLA.png" alt="vector_times_two_bound_zero" /><figcaption aria-hidden="true">vector_times_two_bound_zero</figcaption>
</figure>
<h5 id="起始点区域8">起始点区域8</h5>
<ol type="1">
<li>当终点位于区域1时,如下图所示,先判定起始点与终点的<span class="math inline">\(x\)</span>轴坐标的关系,如果起始点小于终点,则距离值为<span class="math inline">\(\mid s_x - b_x \mid\)</span>,否则计算线段与矩形盒的距离;</li>
</ol>
<figure>
<img data-src="https://i.loli.net/2020/11/05/aAnrLxq2S1f9GTQ.png" alt="zoom8_1" /><figcaption aria-hidden="true">zoom8_1</figcaption>
</figure>
<ol start="2" type="1">
<li><p>当终点位于区域8时,选取起始点与终点中离矩形盒最近的点到矩形盒的距离,即<span class="math inline">\(\mid min(s_x,g_x) -b_x \mid\)</span>;</p></li>
<li><p>当终点位于区域2和3时,如下图所示,通过右上边角点与线段的起始点,终点形成的矢量,进行矢量叉乘,通过数值的正负判断线段是否与矩形盒交叠;</p></li>
</ol>
<p><img data-src="https://i.loli.net/2020/11/05/dsHiLS9M5FO4xZm.png" alt="zoom8_23" style="zoom:80%;" /></p>
<ol start="4" type="1">
<li>当终点位于区域4时,线段与矩形盒一定交叠;</li>
</ol>
<h3 id="矩形盒与矩形盒">矩形盒与矩形盒</h3>
<p>关于矩形盒与矩形盒的碰撞检测采用分离轴原理,即通过判断任意两个<strong>凸多边形</strong>在任意角度下的投影是否均存在重叠，来判断是否发生碰撞。若在某一角度光源下，两物体的投影存在间隙，则为不碰撞，否则为发生碰撞。 如下图所示,将左右两个矩形盒投影到左侧矩形盒长边所在轴上,从图中可以看出投影重叠;</p>
<p><img data-src="https://i.loli.net/2020/11/06/cvArUsyTKzZHPqJ.png" alt="projection_1" style="zoom:50%;" /></p>
<p>如下图所示,以左侧矩形盒短边为轴,将矩形盒投影到该轴上,可以发现投影无重叠,只要存在一种投影方式无重叠,则说明无碰撞。</p>
<p><img data-src="https://i.loli.net/2020/11/06/3xbcGn8ViREtNmp.png" alt="projection_2" style="zoom: 50%;" /></p>
]]></content>
      <categories>
        <category>碰撞检测算法</category>
      </categories>
      <tags>
        <tag>collision checker</tag>
        <tag>obstacle collision</tag>
        <tag>碰撞检测</tag>
        <tag>apllo碰撞检测分析</tag>
      </tags>
  </entry>
  <entry>
    <title>算法优化-1bit转8bit-NEON处理</title>
    <url>/2021/03/17/%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96_NEON%E5%90%8E%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="概述">1. 概述</h2>
<p>使用IVE可以加速sobel滤波器和canny滤波器，但是IVE生成的滤波器结果格式不满足实际需求。为此，需要通过软件方式将IVE的输出结果转化成需要的形式，可以使用c语言、NEON Intrinscis和NEON汇编等方式去实现。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/luRx6nbg58KvOp2.jpg" alt="大连" /><figcaption aria-hidden="true">大连</figcaption>
</figure>
<span id="more"></span>
<h2 id="sobel滤波">2. Sobel滤波</h2>
<p>Sobel滤波器的结果形式如下，使用16比特存储<code>x</code>和<code>y</code>方向的梯度值，其中低8位表示<code>x</code>轴方向梯度，高8位表示<code>y</code>轴方向梯度。</p>
<figure>
<img data-src="https://i.loli.net/2021/03/22/aREjy9znB63wgOH.png" alt="IVE-sobel_result_form" /><figcaption aria-hidden="true">IVE-sobel_result_form</figcaption>
</figure>
<p>实际需求要将<code>x</code>和<code>y</code>方向的梯度拆分为两个字节，具体形式如下：</p>
<p><img data-src="https://i.loli.net/2021/03/22/bvPYqLWknwjQdu9.png" alt="sobel_result_form_xy" style="zoom:150%;" /></p>
<h3 id="nfsu16tou8withtwo函数实现">2.1. NfsU16ToU8WithTwo函数实现</h3>
<p>该函数实现将<code>16bit</code>的高低位拆分为两个独立的字节，并将拆分后的字节单独输出。</p>
<h4 id="c语言代码">2.1.1 C语言代码</h4>
<p>使用C语言编写代码如下 ： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int32_t</span> i = <span class="number">0</span>; i &lt; IMG_BUF_SIZE; i++)</span><br><span class="line">&#123;</span><br><span class="line">	sobel_x[i] =  data_sobel[i]       &amp; <span class="number">0xff</span>;</span><br><span class="line">	sobel_y[i] = (data_sobel[i] &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>Running Time</strong> : 14.3ms</p>
</blockquote>
<h3 id="nfsu16tou8square-函数实现">2.2. NfsU16ToU8Square 函数实现</h3>
<p>该函数实现将<code>16bit</code>的高低位拆分为两个独立的字节(x,y)，并计算<span class="math inline">\(x^2 + y^2\)</span>，将<code>x</code>和<code>y</code>轴的梯度求平方和后按照<code>16bit</code>输出结果。</p>
<h4 id="c语言代码-1">2.2.1. C语言代码</h4>
<p>使用C语言编写代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span> temp_x, temp_y; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int32_t</span> i = <span class="number">0</span>; i &lt; IMG_BUF_SIZE; i++)</span><br><span class="line">&#123;</span><br><span class="line">     temp_x =  data_sobel[i]       &amp; <span class="number">0xff</span>;</span><br><span class="line">     temp_y = (data_sobel[i] &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">     output_sobel[i] = temp_x * temp_x + temp_y * temp_y;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Running Time</strong> : 18.2ms</p>
</blockquote>
<h4 id="intrinsics优化">2.2.2. Intrinsics优化</h4>
<p>首先想到的优化方式是采用<strong>NEON Intrinsics</strong>方式对上述<strong>C</strong>语言代码进行重构，该方式相比于编写汇编代码更加简单，且便于移植。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int32_t</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint16x8_t</span> v_in;</span><br><span class="line"><span class="type">uint8x8_t</span> x, y;</span><br><span class="line"><span class="type">uint16x8_t</span> x2;</span><br><span class="line"><span class="type">uint16x8_t</span> xy_square;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i + <span class="number">7</span> &lt; size; i += <span class="number">8</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// load the input data</span></span><br><span class="line">    v_in = vld1q_u8(input + i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// seprate the u16 to two u8</span></span><br><span class="line">    x = vmovn_u16(v_in); <span class="comment">// mov low 8bit to the x </span></span><br><span class="line">    y = vshrn_n_u16(v_in, <span class="number">8</span>); <span class="comment">// the element right shift 8bit </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate the x^2 + y^2</span></span><br><span class="line">    x2 = vmull_u8(x, x);</span><br><span class="line">    xy_square = vmlal_u8(x2, y, y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// store the result</span></span><br><span class="line">    vst1q_u16(output + i, xy_square);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Running Time</strong> : 3.42ms</p>
</blockquote>
<h4 id="数据加载优化">2.2.3. 数据加载优化</h4>
<p>随着对NEON指令集理解的深入，可以直接使用<code>VLD2</code>指令直接在加载数据时就实现<code>x</code>和<code>y</code>通道的拆分，从而进一步提升了处理的速度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int32_t</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8x8x2_t</span> v_in;</span><br><span class="line"><span class="type">uint16x8_t</span> x2;</span><br><span class="line"><span class="type">uint16x8_t</span> xy_square;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i + <span class="number">7</span> &lt; size; i += <span class="number">8</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// load the input data</span></span><br><span class="line">    v_in = vld2_u8((<span class="type">uint8_t</span>*)input + i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate the x^2 + y^2</span></span><br><span class="line">    x2 = vmull_u8(v_in.val[<span class="number">0</span>], v_in.val[<span class="number">0</span>]);</span><br><span class="line">    xy_square = vmlal_u8(x2, v_in.val[<span class="number">1</span>], v_in.val[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// store the result</span></span><br><span class="line">    vst1q_u16(output + i, xy_square);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过该方式，处理器时可以减少一次<code>mov</code>操作和一次<code>shift</code>操作。如下图所示，<code>VLD2.8</code>直接加载<code>sobel_x</code>进<code>D8</code>，同时加载<code>sobel_y</code>进<code>D9</code>。</p>
<p><img data-src="https://i.loli.net/2021/03/22/CSVYXb1ADeKv3M2.png" alt="IVE-u16totwobyte_load2" style="zoom: 50%;" /></p>
<blockquote>
<p><strong>Running Time</strong>: 2.64ms</p>
</blockquote>
<h4 id="使能向量优化">2.2.4. 使能向量优化</h4>
<p>在使用<code>NEON Intinsics</code>时，编译选项中需要使能向量化，具体编译参数如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -mcpu=cortex-a9 -mfloat-abi=hard -ftree-vectorize -O2 </span><br></pre></td></tr></table></figure>
<h2 id="canny滤波">3. Canny滤波</h2>
<p>Canny滤波器的结果使用一个字节表示8个像素信息，具体形式如下：</p>
<figure>
<img data-src="https://i.loli.net/2021/03/22/jchBaQpVIzUw6FE.png" alt="IVE-one_bit_to_byte" /><figcaption aria-hidden="true">IVE-one_bit_to_byte</figcaption>
</figure>
<p>因此，需要通过软件的方式将字节中的每一个bit像素拆分为一个字节表示，将上图中的两个字节数据进行转换，结果如下图所示：</p>
<figure>
<img data-src="https://i.loli.net/2021/03/22/NwAekVfE3v18PF7.png" alt="one_bit_to_byte_split" /><figcaption aria-hidden="true">one_bit_to_byte_split</figcaption>
</figure>
<h3 id="nfsonebittou8函数实现">3.1.NfsOneBitToU8函数实现</h3>
<h4 id="c语言代码-2">3.1.1. C语言代码</h4>
<p>使用C语言编写代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; IMG_BUF_SIZE; i++)</span><br><span class="line">&#123;</span><br><span class="line">	data_canny_8bit[i]  = ((data_canny[i/<span class="number">8</span>] &gt;&gt; (i % <span class="number">8</span>)) &amp; <span class="number">0x01</span>) &lt;&lt; <span class="number">7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="汇编语言代码">3.1.2. 汇编语言代码</h4>
<h5 id="算法思路">3.1.2.1 算法思路</h5>
<p>上述功能可以使用NEON汇编进行加速，具体思路如下：</p>
<ol type="1">
<li><strong>加载</strong>操作 使用<code>VLD1</code>指令从内存空间加载图像数据到<code>Q6</code>寄存器，该指令可以一次加载16个字节数据，对应图像的128个像素值；</li>
</ol>
<figure>
<img data-src="https://i.loli.net/2021/03/22/AcrYxXTozQDMNq4.png" alt="one_bit_to_byte_neon1" /><figcaption aria-hidden="true">one_bit_to_byte_neon1</figcaption>
</figure>
<ol start="2" type="1">
<li><strong>位与</strong>操作 使用<code>VAND</code>指令，对<code>Q6</code>与<code>Q4</code>寄存器的元素进行<code>位与</code>操作，并将结果存入<code>Q7</code>寄存器，其中<code>Q4</code>寄存器可使用<code>DUP</code>指令全部置为<code>0x01</code>；此步骤将每个元素的低位像素值取出放入<code>Q7</code>寄存器中；</li>
</ol>
<figure>
<img data-src="https://i.loli.net/2021/03/22/auqrLtTUV3CO1WP.png" alt="one_bit_to_byte_neon2" /><figcaption aria-hidden="true">one_bit_to_byte_neon2</figcaption>
</figure>
<ol start="3" type="1">
<li><strong>比较</strong>操作 使用<code>VCGT</code>指令对<code>Q7</code>和<code>Q5</code>寄存器的元素逐个进行比较，判断<code>Q7</code>寄存器的元素是否大于对应<code>Q5</code>中的元素，其计算结果保存在<code>Q8</code>寄存器中。如果<code>Q7</code>的元素大于<code>Q5</code>的元素，则对应<code>Q8</code>元素设置为<strong>255</strong>,否则设置为<strong>0</strong>。</li>
</ol>
<figure>
<img data-src="https://i.loli.net/2021/03/22/fvabiuxP3wOpdZk.png" alt="one_bit_to_byte_neon3" /><figcaption aria-hidden="true">one_bit_to_byte_neon3</figcaption>
</figure>
<ol start="4" type="1">
<li><strong>移位</strong>操作 使用<code>VSHR</code>指令，将<code>Q6</code>中的元素整体向右移动1比特位，即将下一组像素移到元素最低位，方便循环取出图像像素值。</li>
</ol>
<figure>
<img data-src="https://i.loli.net/2021/03/22/A9rf8uEphmtJ1nR.png" alt="one_bit_to_byte_neon4" /><figcaption aria-hidden="true">one_bit_to_byte_neon4</figcaption>
</figure>
<ol start="5" type="1">
<li><strong>循环</strong>操作 循环上述2、3、4步骤，将<code>Q6</code>寄存器中的像素值分别取出，放入<code>Q8~Q15</code>寄存器中。</li>
</ol>
<figure>
<img data-src="https://i.loli.net/2021/03/22/y4FhAPkxJOp3b5B.png" alt="one_bit_to_byte_neon5" /><figcaption aria-hidden="true">one_bit_to_byte_neon5</figcaption>
</figure>
<ol start="6" type="1">
<li><strong>打包</strong>操作 使用<code>VZIP</code>指令每隔4个<code>Q</code>寄存器进行一次打包操作，如下图所示，使像素索引号间隔4排列。该步骤的目的是未了方便下一步的存储操作。</li>
</ol>
<figure>
<img data-src="https://i.loli.net/2021/03/22/i4ovKyuaHsO5T1P.png" alt="one_bit_to_byte_neon6" /><figcaption aria-hidden="true">one_bit_to_byte_neon6</figcaption>
</figure>
<ol start="7" type="1">
<li><strong>存储</strong>操作 使用<code>VST4</code>指令将上述打包好的数据，按照像素循序存储相应的内存地址。</li>
</ol>
<p><img data-src="https://i.loli.net/2021/03/22/gtaHZXzmK685opf.png" alt="one_bit_to_byte_neon7" style="zoom:80%;" /></p>
<h5 id="汇编代码">3.1.2.2 汇编代码</h5>
<p>使用<strong>NEON Assembly</strong>编写上述功能代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NfsOneBitToU8Asm</span><span class="params">(<span class="type">uint8_t</span>* <span class="keyword">restrict</span> input, <span class="type">uint8_t</span>* <span class="keyword">restrict</span> output, <span class="type">uint32_t</span> size)</span> &#123;</span><br><span class="line">  <span class="type">uint8_t</span>* input_temp = input;</span><br><span class="line">  <span class="type">uint8_t</span>* output_temp = output;</span><br><span class="line">  <span class="type">uint32_t</span> size_tmp = size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;vmov.i8      q4, #0x01         \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vmov.i8      q5, #0x00         \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;100:                           \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vld1.8      &#123;q6&#125;, [%0]!        \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;pld         [%0, #128]         \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vshr.u8     q9, q6, #1         \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vshr.u8     q10, q6, #2        \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vshr.u8     q11, q6, #3        \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vshr.u8     q12, q6, #4        \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vshr.u8     q13, q6, #5        \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vshr.u8     q14, q6, #6        \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vshr.u8     q15, q6, #7        \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vand.i8     q8, q6, q4         \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vand.i8     q9, q9, q4         \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vand.i8     q10, q10, q4       \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vand.i8     q11, q11, q4       \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vand.i8     q12, q12, q4       \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vand.i8     q13, q13, q4       \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vand.i8     q14, q14, q4       \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vand.i8     q15, q15, q4       \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vcgt.s8     q8, q8, q5         \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vcgt.s8     q9, q9, q5         \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vcgt.s8     q10, q10, q5       \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vcgt.s8     q11, q11, q5       \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vcgt.s8     q12, q12, q5       \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vcgt.s8     q13, q13, q5       \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vcgt.s8     q14, q14, q5       \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vcgt.s8     q15, q15, q5       \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vzip.8      q8, q12            \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vzip.8      q9, q13            \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vzip.8      q10, q14           \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vzip.8      q11, q15           \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vst4.8      &#123;d16, d18, d20, d22&#125;, [%1]! \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vst4.8      &#123;d17, d19, d21, d23&#125;, [%1]! \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vst4.8      &#123;d24, d26, d28, d30&#125;, [%1]! \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;vst4.8      &#123;d25, d27, d29, d31&#125;, [%1]! \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;subs        %2, #16             \n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;bgt         100b                \n&quot;</span></span></span><br><span class="line"><span class="params">               : <span class="string">&quot;=r&quot;</span>(input_temp), <span class="string">&quot;=r&quot;</span>(output_temp), <span class="string">&quot;=r&quot;</span>(size_tmp)</span></span><br><span class="line"><span class="params">               : <span class="string">&quot;0&quot;</span>(input_temp), <span class="string">&quot;1&quot;</span>(output_temp), <span class="string">&quot;2&quot;</span>(size_tmp)</span></span><br><span class="line"><span class="params">               : <span class="string">&quot;memory&quot;</span>,</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;cc&quot;</span>,</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;q4&quot;</span>,</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;q5&quot;</span>,</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;q6&quot;</span>,</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;q7&quot;</span>,</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;q8&quot;</span>,</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;q9&quot;</span>,</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;q10&quot;</span>,</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;q11&quot;</span>,</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;q12&quot;</span>,</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;q13&quot;</span>,</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;q14&quot;</span>,</span></span><br><span class="line"><span class="params">                 <span class="string">&quot;q15&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性能对比">4. 性能对比</h2>
<p>如下表所示，上述代码在联咏<strong>NT96565A</strong>平台运行时间如下：</p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>C language</th>
<th>Intrinsics</th>
<th>Assembly</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>NfsU16ToU8WithTwo</strong></td>
<td>14.3</td>
<td><strong>3.2</strong></td>
<td>3.56</td>
</tr>
<tr class="even">
<td><strong>NfsU16ToU8Square</strong></td>
<td>18.6</td>
<td><strong>2.64</strong></td>
<td>2.82</td>
</tr>
<tr class="odd">
<td><strong>NfsOneBitToU8</strong></td>
<td>10.2</td>
<td>2.13</td>
<td><strong>1.78</strong></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>算法优化</category>
        <category>NEON</category>
      </categories>
      <tags>
        <tag>图像算法加速</tag>
        <tag>NEON</tag>
        <tag>联咏</tag>
      </tags>
  </entry>
  <entry>
    <title>路径规划-ReedsShepp曲线</title>
    <url>/2020/04/15/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92-ReedsShepp%E6%9B%B2%E7%BA%BF/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p><strong>ReedsShepp</strong>算法简称<strong>RS</strong>，由 <strong>J.AReeds</strong>和<strong>L.A.Sheep</strong>于1990年发表的论文<a href="https://projecteuclid.org/download/pdf_1/euclid.pjm/1102645450">(optimal path for a car that goes both forward and backwards)</a>。该方法基于<strong>Dubins</strong>算法进行改进，将反向运动加入到规划中，这就使得在某些情况下可以得出比<strong>Dubins</strong>曲线更优的解。</p>
<figure>
<img data-src="https://i.loli.net/2021/08/30/ESWCixm4uDdRv61.jpg" alt="青岛" /><figcaption aria-hidden="true">青岛</figcaption>
</figure>
<span id="more"></span>
<h2 id="曲线">曲线</h2>
<h3 id="dubins曲线">Dubins曲线</h3>
<p>关于<strong>Dubins</strong>曲线，不考虑车辆后退，且不允许出现尖瓣。<strong>Dubins</strong>给出了充分的路径集合，该集合里所包含的曲线叫做<strong>测地线</strong>或<strong>最佳路径</strong>。但是这个充分集合很小，对于每种特定终点情况下的集合中，最多只有6个可选曲线,分别表示如下：</p>
<p><span class="math display">\[
\begin{array}{cl}
\{&amp;LRL  &amp;LSL  &amp;LSR  &amp;RLR  &amp;RSR  &amp;RSL &amp;\} \tag{1}
\end{array}
\]</span></p>
<p>其中等式(1)中符号含义如下：</p>
<table>
<thead>
<tr class="header">
<th>符号</th>
<th>含义</th>
<th>绕单位圆</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>L</strong></td>
<td>左转</td>
<td>逆时针</td>
</tr>
<tr class="even">
<td><strong>R</strong></td>
<td>右转</td>
<td>顺时针</td>
</tr>
<tr class="odd">
<td><strong>S</strong></td>
<td>直走</td>
<td>直走</td>
</tr>
</tbody>
</table>
<p><strong>Dubins</strong>证明，一个最优路径一定是由分段圆弧(单位圆)和线段组成的平滑曲线，且最多3部分组成。可以进一步简化表示为如下形式：</p>
<p><span class="math display">\[
\begin{array}{cl}
CCC&amp;\to&amp;\{&amp;LRL &amp;RLR &amp;&amp;&amp;\} \\
CSC&amp;\to&amp;\{&amp;LSL &amp;RSR &amp;LSR &amp;RSL&amp;\}
\end{array} \tag{2}
\]</span></p>
<p>等式(2)中符号含义如下：</p>
<table>
<thead>
<tr class="header">
<th><strong>符号</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>C</strong></td>
<td>单位圆弧</td>
</tr>
<tr class="even">
<td><strong>S</strong></td>
<td>一条直线段</td>
</tr>
</tbody>
</table>
<p>一个字段表示相应的一类路径，使用文字符号的下标指定相应弧长和线段的长度，比如<span class="math inline">\((L_tS_uR_v)\)</span>。</p>
<h3 id="reedsheep曲线">ReedSHeep曲线</h3>
<p>在<strong>ReedSHeep</strong>曲线的路径中，允许尖瓣存在。为了表示，需要在字段中的字母上加入上标，用来表示运动方向，表示如下：</p>
<table>
<thead>
<tr class="header">
<th>符号</th>
<th>含义</th>
<th>绕单位圆</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math display">\[L^+\]</span></td>
<td>向<strong>前</strong>左转</td>
<td>逆时针</td>
</tr>
<tr class="even">
<td><span class="math display">\[L^-\]</span></td>
<td>向<strong>后</strong>左转</td>
<td>顺时针</td>
</tr>
<tr class="odd">
<td><span class="math display">\[R^+\]</span></td>
<td>向<strong>前</strong>右转</td>
<td>逆时针</td>
</tr>
<tr class="even">
<td><span class="math display">\[R^-\]</span></td>
<td>向<strong>后</strong>右转</td>
<td>顺时针</td>
</tr>
<tr class="odd">
<td><span class="math display">\[S^+\]</span></td>
<td>向<strong>前</strong>直走</td>
<td>/</td>
</tr>
<tr class="even">
<td><span class="math display">\[S^-\]</span></td>
<td>向<strong>后</strong>直走</td>
<td>/</td>
</tr>
</tbody>
</table>
<p>例如：<span class="math inline">\(L^+R^-\)</span>拥有一个尖瓣而<span class="math inline">\(L^+R^+\)</span>无尖瓣。</p>
<blockquote>
<p>在车辆中，字母L、R、S参考方向盘转角，符号<span class="math inline">\(+\)</span>和<span class="math inline">\(-\)</span>参考挡位切换</p>
</blockquote>
<p>使用C、S字符可以给出如下集合：</p>
<p><span class="math display">\[
\begin{array}{cl}
CCC \gets \{&amp;C^+C^-C^+ &amp;C^+C^-C^-  &amp;C^+C^+C^- &amp;C^+C^+_uC^-_uC^- &amp;C^+C^-_uC^-_uC^+&amp;\}\\
CSC \gets \{&amp;C^+S^+C^+ &amp;C^-C^+_{\pi/2}S^+C^+ &amp;C^+S^+C^+_{\pi/2}C^- &amp;C^-C^+_{\pi/2}S^+C^+_{\pi/2}C^-&amp;&amp;\}
\end{array}\tag{3}
\]</span></p>
<p>以及通过反转等式(3)的符号可以获得新的的字段。上式(3)中，<span class="math inline">\(C\)</span>表示<span class="math inline">\(L\)</span>或者<span class="math inline">\(R\)</span>，<span class="math inline">\(C^+_{\pi/2}\)</span>表示相应的<span class="math inline">\(L\)</span>或<span class="math inline">\(R\)</span>的弧长为<span class="math inline">\(\pi/2\)</span>，<span class="math inline">\(C_uC_u\)</span>组合表示相应的弧段拥有相等的长度。</p>
<h4 id="下标符号">下标符号</h4>
<p>为了更加缜密表示，在<span class="math inline">\(C^\pm_t,L^\pm_t,R^\pm_t,S^\pm_t\)</span>中使用有点多余的约定，规定<span class="math inline">\(t\)</span>的符号与方向匹配。</p>
<blockquote>
<p>如果<span class="math inline">\(t &gt; 0\)</span>：车辆前进，符号<span class="math inline">\(+\)</span> 如果<span class="math inline">\(t&lt;0\)</span>：车辆后退，符号<span class="math inline">\(-\)</span></p>
</blockquote>
<h4 id="自由参数数量">自由参数数量</h4>
<p>在等式(3)的曲线族中，<span class="math inline">\(C^+_tC^-_uC^-_vC^+_w\)</span>具有自由参数<span class="math inline">\((t,u,v,w)\)</span>的数量比最终情形的数量多一个。优化路径族通过给定额外的方程式，例如<span class="math inline">\(u=v\)</span>或者<span class="math inline">\(v = \pi/2\)</span>。确保等式(3)中的每个情形只有3个自由参数。</p>
<h4 id="紧凑表示">紧凑表示</h4>
<p>为了以紧凑的表示，避免<span class="math inline">\(\pm\)</span>，可以写出充分路径的列表如下：</p>
<p><span class="math display">\[
\begin{array}{cl}
CCC \gets \{&amp;C\mid C\mid C &amp;C\mid CC  &amp;CC\mid C &amp;CC_u\mid C_uC &amp;C\mid C_uC_u\mid C&amp;\}\\
CSC \gets \{&amp;CSC &amp;C\mid C_{\pi/2}SC &amp;CSC_{\pi/2}\mid C &amp;C\mid C_{\pi/2}SC_{\pi/2}\mid C&amp;&amp;\}\\
\end{array}\tag{4}
\]</span></p>
<p>其中，<span class="math inline">\(|\)</span>表示方向反转。当等式(3)和(4)中的<span class="math inline">\(C\)</span>被替换为<span class="math inline">\(C = L\)</span>或<span class="math inline">\(C=R\)</span>，共有48种字段，以<span class="math inline">\(L^\pm,R^\pm,S^\pm\)</span>的形式表示。这48个字段中的一些对于字段类型的实际路径存在两种公式。对于给定的任意情形，至多68个公式。</p>
<p>任何长度小于<span class="math inline">\(\pi/8\)</span>的最佳路径一定是<span class="math inline">\(CSC\)</span>形式。很容易得出结论，任何最佳路径一定是由<span class="math inline">\(C\)</span>和<span class="math inline">\(S\)</span>的字段组成。使用一系列的特殊参数，可将所有有限的字段简化为<span class="math inline">\(CCC\)</span>或<span class="math inline">\(CSC\)</span>的形式。</p>
<h4 id="充分集合">充分集合</h4>
<p>下表列出了充分集合中的48个字段，以及相应的缩写形式<span class="math inline">\(C \mid C\)</span>和<span class="math inline">\(C^\pm\)</span>，最后一列给出了给定字段的长度公式。</p>
<table>
<colgroup>
<col style="width: 40%" />
<col style="width: 43%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="header">
<th>形式<span class="math inline">\(C\mid C\)</span></th>
<th>形式<span class="math inline">\(C^\pm\)</span></th>
<th>明确表示</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math display">\[ \begin{array}{cl} C\mid C \mid C \end{array} \]</span></td>
<td><span class="math display">\[ \begin{array}{cl} &amp;C^+C^-C^+ \\&amp;C^-C^+C^- \end{array} \]</span></td>
<td><span class="math display">\[ \begin{array}{cl}&amp;L^+R^-L^+ &amp;R^+L^-R^+ \\ &amp;L^-R^+L^- &amp;R^-L^+R^- \end{array} \]</span></td>
</tr>
<tr class="even">
<td><span class="math display">\[ \begin{array}{cl}C \mid CC \end{array}\]</span></td>
<td><span class="math display">\[ \begin{array}{cl}&amp;C^+C^-C^- \\&amp;C^-C^+C^+ \end{array} \]</span></td>
<td><span class="math display">\[ \begin{array}{cl}&amp;L^+R^-L^- &amp;R^+L^-R^-\\&amp;L^-R^+L^+  &amp;R^-L^+R^+ \end{array} \]</span></td>
</tr>
<tr class="odd">
<td><span class="math display">\[ CC \mid C \]</span></td>
<td><span class="math display">\[ \begin{array}{cl}&amp;C^+C^+C^- \\&amp;C^-C^-C^+ \end{array} \]</span></td>
<td><span class="math display">\[ \begin{array}{cl}&amp;L^+R^+L^- &amp;R^+L^+R^-\\&amp;L^-R^-L^+  &amp;R^-L^-R^+ \end{array} \]</span></td>
</tr>
<tr class="even">
<td><span class="math display">\[ CC_u \mid C_uC \]</span></td>
<td><span class="math display">\[ \begin{array}{cl}&amp;C^+C^+_uC^-_{-u}C^- \\&amp;C^-C^-_{-u}C^+_uC^+ \end{array} \]</span></td>
<td><span class="math display">\[ \begin{array}{cl}&amp;L^+R^+_uL^-_{-u}R^- &amp;R^+L^+_uR^-_{-u}L^-\\&amp;L^-R^-_{-u}L^+_uR^+  &amp;R^-L^-_{-u}R^+_uL^+ \end{array} \]</span></td>
</tr>
<tr class="odd">
<td><span class="math display">\[ C \mid C_uC_u \mid C \]</span></td>
<td><span class="math display">\[ \begin{array}{cl}&amp;C^+C^-_{-u}C^-_{-u}C^+ \\&amp;C^-C^+_{u}C^+_uC^- \end{array} \]</span></td>
<td><span class="math display">\[ \begin{array}{cl}&amp;L^+R^-_{-u}L^-_{-u}R^+ &amp;R^+L^-_{-u}R^-_{-u}L^+\\&amp;L^-R^+_{u}L^+_uR^-  &amp;R^-L^+_{u}R^+_uL^-\end{array} \]</span></td>
</tr>
<tr class="even">
<td><span class="math display">\[ CSC \]</span></td>
<td><span class="math display">\[ \begin{array}{cl}&amp;C^+C^+C^+ \\&amp;C^-C^-C^-\end{array} \]</span></td>
<td><span class="math display">\[ \begin{array}{cl}&amp;L^+S^+L^+ &amp;R^+S^+R^+\\&amp;L^+S^+R^+  &amp;R^+S^+L^+\\&amp;L^-S^-L^- &amp;R^-S^-R^-\\&amp;L^-S^-R^-  &amp;R^-S^-L^-\end{array} \]</span></td>
</tr>
<tr class="odd">
<td><span class="math display">\[ C \mid C_{\pi/2}SC \]</span></td>
<td><span class="math display">\[ \begin{array}{cl}&amp;C^+C^-_{-\pi/2}S^-C^- \\&amp;C^-C^+_{\pi/2}S^+C^+\end{array} \]</span></td>
<td><span class="math display">\[ \begin{array}{cl}&amp;L^+R^-_{-\pi/2}S^-L^- &amp;R^+L^-_{-\pi/2}S^-R^-\\&amp;L^+R^-_{-\pi/2}S^-R^- &amp;R^+L^-_{-\pi/2}S^-L^-\\&amp;L^-R^+_{\pi/2}S^+L^+ &amp;R^-L^+_{\pi/2}S^+R^+\\&amp;L^-R^+_{\pi/2}S^+R^+ &amp;R^-L^+_{\pi/2}S^+L\\\end{array} \]</span></td>
</tr>
<tr class="even">
<td><span class="math display">\[ CSC_{\pi/2} \mid C \]</span></td>
<td><span class="math display">\[ \begin{array}{cl}&amp;C^+S^+C^+_{\pi/2}C^- \\&amp;C^-S^-C^-_{\pi/2}C^+\end{array}\]</span></td>
<td><span class="math display">\[\begin{array}{cl}&amp;L^+S^+R^+_{\pi/2}L^- &amp;R^+S^+L^+_{\pi/2}R^-\\&amp;R^+S^+R^+_{\pi/2}L^- &amp;L^+S^+L^+_{\pi/2}R^-\\&amp;L^-S^-R^-_{-\pi/2}L^+ &amp;R^-S^-L^-_{-\pi/2}R^+\\&amp;R^-S^-R^-_{-\pi/2}L^+ &amp;L^-S^-L^-_{-\pi/2}R^+ \end{array} \]</span></td>
</tr>
<tr class="odd">
<td><span class="math display">\[ C\mid C_{\pi/2}SC_{\pi/2}C \]</span></td>
<td><span class="math display">\[ \begin{array}{cl}&amp;C^+C^-_{-\pi/2}S^-C^-_{-\pi/2}C^+ \\&amp;C^-C^+_{\pi/2}S^+C^+_{\pi/2}C^-\end{array}\]</span></td>
<td><span class="math display">\[\begin{array}{cl}&amp;L^+R^-_{-\pi/2}S^-L^-_{-\pi/2}R^+ &amp;R^+L^-_{-\pi/2}S^-R^-_{-\pi/2}L^+\\&amp;L^-R^+_{\pi/2}S^+L^+_{\pi/2}R^-  &amp;R^-L^+_{\pi/2}S^+R^+_{\pi/2}L^-\end{array} \]</span></td>
</tr>
</tbody>
</table>
<h2 id="允许路径">允许路径</h2>
<p>根据车辆运动学模型的微分方程如下：</p>
<p><span class="math display">\[
\begin{array}{cl}
\dot{x}(t) &amp;= V(t)\cos\bigl(\psi(t)\bigr) \quad\\
\dot{y}(t) &amp;= V(t)\sin\bigl(\psi(t)\bigr) \quad\\
\dot{\psi}(t) &amp;= \dfrac{V(t)}{R(t)}
\end{array}\tag{5}
\]</span></p>
<p>为了更好的表示路径，对车辆行驶路径进行归一化处理，简化路径的表示方法。即限制<span class="math inline">\(V(t)= \pm1\)</span>、<span class="math inline">\(|\dot{\psi}(t)| =1\)</span>，所以车辆只能在自身方向<span class="math inline">\(\psi(t)\)</span>上以速度<span class="math inline">\(|V(t)=1|\)</span>前进或后退，并且变化率<span class="math inline">\(\dot{\psi}(t)\leq1\)</span><strong>rad/s</strong>。对于车辆的转弯半径可以通过缩放变换到1，即车辆绕单位圆行驶。这样表示的好处在于车辆行驶的弧长与变化的角度一致。如果直线行驶，则<span class="math inline">\(\dot{\psi}(t) = 0\)</span>，令<span class="math inline">\(\dot{\psi}\)</span></p>
<p>其积分形式如下：</p>
<p><span class="math display">\[
\begin{array}{cl}
x(t) &amp;= x(0) + \int^t_0V(\tau)\cos\bigl(\psi(\tau)\bigr)d\tau\\
y(t) &amp;= y(0) + \int^t_0V(\tau)\sin\bigl(\psi(\tau)\bigr)d\tau\\
\psi(t) &amp;= \psi(0) + \int^t_0\dot{\psi}(\tau)d\tau
\end{array}\tag{6}
\]</span></p>
<p>一个允许的路径或者曲线可以表示成函数<span class="math inline">\(\gamma(t) = \bigl(x(t),y(t),\psi(t)\bigr)\)</span>的形式。对于任意曲线从<span class="math inline">\(t_0\)</span>到<span class="math inline">\(t_1\)</span>，其中<span class="math inline">\(t_0 &lt; t_1\)</span>，<span class="math inline">\(\gamma(t_0) = a\)</span>，<span class="math inline">\(\gamma(t_1)=b\)</span>，则路径的长度为<span class="math inline">\(L(\gamma)= t_1 - t_0\)</span>。所以关于最短路径的问题，就转换为求取对于任意a和b<span class="math inline">\(\in \Re^3\)</span>,使得<span class="math inline">\(L(\gamma)\)</span>最小的<span class="math inline">\(\gamma\)</span>。</p>
<h3 id="可行路径">可行路径</h3>
<p>对于时间<span class="math inline">\(t \in \Re\)</span>，使用</p>
<p><span class="math display">\[
\begin{array}{cl}
L_t:\Re^3 \to \Re^3\\
R_t: \Re^3 \to \Re^3\\
S_t: \Re^3 \to \Re^3
\end{array}\tag{7}
\]</span></p>
<p>表示单位圆<span class="math inline">\(L_t\)</span>或<span class="math inline">\(R_t\)</span>和线段<span class="math inline">\(S_t\)</span>的位置和方向信息，起始坐标表示为<span class="math inline">\((x,y,\psi)\)</span>，所以经过时间<span class="math inline">\(t\)</span>，根据等式(6)积分得：</p>
<p><span class="math display">\[
\begin{array}{cl}
x(t) &amp;= x + \sin(\tau)|^{\psi+t}_{\psi}\\
y(t) &amp;= y - \cos(\tau)|^{\psi+t}_{\psi}\\
\psi(t) &amp;= t
\end{array}
\]</span></p>
<p>对应的路径如下：</p>
<p><span class="math display">\[
\begin{array}{cl}
L_t^+(x,y,\psi) &amp;= \bigl(x + \sin(\psi+t)- \sin(\psi),y - \cos(\psi+t)+\cos(\psi),\psi + t\bigr)\\
R_t^+(x,y,\psi) &amp;= \bigl(x - \sin(\psi-t)+ \sin(\psi),y + \cos(\psi-t)-\cos(\psi),\psi - t\bigr)\\
S_t^+(x,y,\psi) &amp;= (x+t\cos(\psi),y + t\sin(\psi),\psi)
\end{array}\tag{8}
\]</span></p>
<p><span class="math display">\[
\begin{array}{cl}
L_t^-(x,y,\psi) &amp;= \bigl(x - \sin(\psi-t)+ \sin(\psi),y + \cos(\psi-t)-\cos(\psi),\psi - t\bigr)\\
R_t^-(x,y,\psi) &amp;= \bigl(x + \sin(\psi+t)- \sin(\psi),y - \cos(\psi+t)+\cos(\psi),\psi + t\bigr)\\
S_t^-(x,y,\psi) &amp;= (x-t\cos(\psi),y - t\sin(\psi),\psi)
\end{array}
\]</span></p>
<ul>
<li>举例</li>
</ul>
<p>假设一个曲线<span class="math inline">\(L^+_tR^-_uS^-_vL^-_w\)</span>，起始于点<span class="math inline">\((0,0,0)\)</span>，一定终止于</p>
<p><span class="math display">\[
\bigl(X(t,u,v,w),Y(t,u,v,w),\Psi(t,u,v,w)\bigr)= R_w(S_v(R_u(L_t(0,0,0))))
\]</span></p>
<p>其长度为<span class="math inline">\(L(t,u,v,w) = |t|+ |u| + |v| + |w|\)</span>。</p>
<h3 id="位置姿态统一">位置姿态统一</h3>
<p>由于车辆的起始位置和终点位置无法穷举，所以一般在计算路径之前，需要将车辆的位置和姿态作归一化：</p>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>坐标</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>起始姿态</td>
<td><span class="math inline">\(( 0, 0, 0 )\)</span></td>
</tr>
<tr class="even">
<td>目标姿态</td>
<td><span class="math inline">\((x, y, \psi )\)</span></td>
</tr>
<tr class="odd">
<td>转弯半径</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>假设起始姿态为<span class="math inline">\(q_i=(x_1,y_1,\psi_1)\)</span>，目标姿态为<span class="math inline">\(q_g=(x_2,y_2,\psi_2)\)</span>，车辆转弯半径为<span class="math inline">\(r=\rho\)</span>。</p>
<ul>
<li>平移</li>
</ul>
<p>首先将向量<span class="math inline">\(\vec{q_iq_g}\)</span>平移到远点<span class="math inline">\((0,0)\)</span>，平移向量为<span class="math inline">\((-x_1,-y_1)\)</span>。则<span class="math inline">\(q_i\)</span>平移到<span class="math inline">\((0,0)\)</span>，<span class="math inline">\(q_g\)</span>平移到<span class="math inline">\((x_2-x_1,y_2-y_1)\)</span>，最终得到的平移向量：</p>
<p><span class="math display">\[
\vec{q_iq_g}=
\left[
\begin{array}{cl}
x_2-x_1\\
y_2-y_1
\end{array}\right]=
\left[
\begin{array}{cl}
x\\
y
\end{array}
\right]\tag{9}
\]</span></p>
<ul>
<li>旋转</li>
</ul>
<p>应用旋转矩阵，将车辆的起始点朝向转到x轴正向，对应得旋转角度为<span class="math inline">\(\psi_1\)</span>，旋转矩阵如下：</p>
<p><span class="math display">\[
\left[
\begin{array}{cl}
\cos(\psi_1) &amp;\sin(\psi_1)\\
-\sin(\psi_1) &amp;\cos(\psi_1)
\end{array}
\right]\tag{10}
\]</span></p>
<p>则向量<span class="math inline">\(\vec{q_iq_g}\)</span>旋转后得</p>
<p><span class="math display">\[
\vec{q_iq_g}=
\left[
\begin{array}{cl}
x\\
y
\end{array}
\right]=
\left[
\begin{array}{cl}
\cos(\psi_1) &amp;\sin(\psi_1)\\
-\sin(\psi_1) &amp;\cos(\psi_1)
\end{array}
\right]
\left[
\begin{array}{cl}
x\\
y
\end{array}
\right]=
\left[
\begin{array}{cl}
x\cos(\psi_1) + y\sin(\psi_1)\\
-x\sin(\psi_1)+y\cos(\psi_1)
\end{array}
\right]
\tag{11}
\]</span></p>
<p>通过上述旋转后，目标位置朝向为<span class="math inline">\(\psi = \psi_2 - \psi_1\)</span>。</p>
<ul>
<li>缩放</li>
</ul>
<p>对于车辆的转弯半径<span class="math inline">\(\rho\)</span>，将车辆转向半径缩放到1，得到最终的车辆其实姿态为:</p>
<p><span class="math display">\[
q_i=
\left[
\begin{array}{cl}
0\\
0\\
0
\end{array}
\right]\tag{12}
\]</span></p>
<p>目标姿态为：</p>
<p><span class="math display">\[
q_g=
\left[
\begin{array}{cl}
\bigl(x\cos(\psi_1) + y\sin(\psi_1)\bigr)/\rho\\
\bigl(-x\sin(\psi_1)+y\cos(\psi_1)\bigr)/\rho\\
\psi_2-\psi_1
\end{array}
\right]\tag{13}
\]</span></p>
<h2 id="类型转换">类型转换</h2>
<p>上述48个字段中的某些方程的最小值拥有两个解，所以实际公式将达到68个。凭经验观察，似乎只要48个表达式在任何情况下都需要，一些表达式无疑是方程的虚假解。在可以考虑的48种不同的字符模式中，由于存在一些基本变换，没有必要给出所有的形式。下面列出3种常见的转换模式：</p>
<h3 id="时间变换timeflip">时间变换(timeflip)</h3>
<p>时间变换通过交换字母上标符号<span class="math inline">\(+\)</span>和<span class="math inline">\(-\)</span>，即车取反辆的行进方向。也就是说，<span class="math inline">\(L^-R^+S^+L^+\)</span>表达式可以通过<span class="math inline">\(L^+R^-S^-L^-\)</span>表达式通过时间变换获得。其中<span class="math inline">\(+\)</span>和<span class="math inline">\(-\)</span>交换。如果原始路径从<span class="math inline">\((0,0,0)\)</span>到<span class="math inline">\((x,y,\psi)\)</span>，显而易见时间变换的路径将从<span class="math inline">\((0,0,0)\)</span>到<span class="math inline">\((-x,y,-\psi)\)</span>。因此，如果一个路径表达式<span class="math inline">\(L^+_tR^-_{-\pi/2}S^-_uL^-_v\)</span>从点<span class="math inline">\((0,0,0)\)</span>到<span class="math inline">\((-x,y,-\psi)\)</span>，查找的合适弧长为t、u、v。这就等效于路径表达式<span class="math inline">\(L^-_tR^+_{\pi/2}S^+_uL^+_v\)</span>从点<span class="math inline">\((0,0,0)\)</span>到<span class="math inline">\((x,y,\psi)\)</span>查找相应的弧长。所以，通过时间变换将上述列表中第一个字母符号为"<span class="math inline">\(-\)</span>"的字段消除。</p>
<h3 id="反射变换reflect">反射变换(reflect)</h3>
<p>反射变换通过交换字母<span class="math inline">\(L\)</span>和<span class="math inline">\(R\)</span>，即取反车辆转向。也就是说，一个路径表达式<span class="math inline">\(R^+L^-S^-R^-\)</span>的解可以通过反射变换从路径表达式<span class="math inline">\(L^+R^-S^-L^-\)</span>的解中获得，即沿着该路径交换<span class="math inline">\(L\)</span>和<span class="math inline">\(R\)</span>。相应的参考路径由<span class="math inline">\((x,y,\psi)\)</span>变为<span class="math inline">\((x,-y,-\psi)\)</span>。</p>
<p>假设已知路径<span class="math inline">\(L^+_tR^-_{-\pi/2}S^-_uL^-_v\)</span>解的表达式，从点<span class="math inline">\((0,0,0) \to (x,-y,-\psi)\)</span>的最优弧长为t、u、v。</p>
<p><span class="math display">\[
\begin{array}{cl}
&amp;L^+_tR^-_{-\pi/2}S^-_uL^-_v :(0,0,0) \to (x,-y,-\psi)\\
\end{array}
\]</span></p>
<p>则从点<span class="math inline">\((0,0,0) \to (x,y,\psi)\)</span>的最优弧长为t、u、v，对应路径<span class="math inline">\(R^+_tL^-_{-\pi/2}S^-_uR^-_v\)</span>的解，</p>
<p><span class="math display">\[
\begin{array}{cl}
&amp;R^+_tL^-_{-\pi/2}S^-_uR^-_v :(0,0,0) \to (x,y,\psi)\\
\end{array}
\]</span></p>
<p>所以，通过反射变换可以将上述列表中以<span class="math inline">\(L^+\)</span>开头的字段消除。</p>
<h3 id="逆向变换backwards">逆向变换(backwards)</h3>
<p>逆向变换通过将原路径按照相反方向行走。也就是说，路径<span class="math inline">\(L^-S^-R^-L^+\)</span>的公式可以使用逆向变换从路径<span class="math inline">\(L^+R^-S^-L^-\)</span>的公式中获得，即按照相反的顺序运动。</p>
<p>逆向变换将目标点<span class="math inline">\((x,y,\psi)\)</span>转化为<span class="math inline">\(\bigl(x\cos(\psi)+y\sin(\psi),x\sin(\psi)-y\cos(\psi),\psi\bigr)\)</span>。所以可以通过公式<span class="math inline">\(L^+R^-S^-L^-\)</span>到达点<span class="math inline">\(\bigl(x\cos(\psi)+y\sin(\psi),x\sin(\psi)-y\cos(\psi),\psi\bigr)\)</span>，从而获得<span class="math inline">\(L^-S^-R^-L^+\)</span>到达点<span class="math inline">\((x,y,\psi)\)</span>的解。</p>
<p>通过这个变换可以消除上述列表中一些字段，最终保留9个字段讨论如下。</p>
<h2 id="公式计算">公式计算</h2>
<h3 id="概述-1">概述</h3>
<p>通过上述3种变换，还剩9个公式需要求解。这9个表达式都是从点<span class="math inline">\((0,0,0)\)</span>到点<span class="math inline">\((x,y,\psi)\)</span>，为了更加方便表述，定义如下符号：</p>
<ul>
<li>极坐标</li>
</ul>
<p>由笛卡尔坐标系<span class="math inline">\((x,y)\)</span>与极坐标系的转化可以写为<span class="math inline">\((r,\theta) = R(x,y)\)</span>，展开如下：</p>
<p><span class="math display">\[
\begin{array}{cl}
x = r \cdot\cos(\theta)\\
y = r \cdot\sin(\theta)
\end{array}\leftrightharpoons
\begin{array}{cl}
r &amp;= \sqrt{x^2 + y^2}\\
\theta &amp;= \arctan(\dfrac{y}{x})
\end{array}
\]</span></p>
<p>其中，<span class="math inline">\(r \geq 0\)</span>，<span class="math inline">\(-\pi \leq \theta &lt; \pi\)</span>。</p>
<ul>
<li>偏航角标准化</li>
</ul>
<p>通过标准化符号<span class="math inline">\(M\)</span>，即<span class="math inline">\(\psi = M(\theta)\)</span>，将<span class="math inline">\(\psi\)</span>的范围限制在<span class="math inline">\(-\pi \leq \psi&lt; \pi\)</span>。</p>
<h3 id="公式-l_ts_ul_v">公式 <span class="math inline">\(L^+_tS^+_uL^+_v\)</span></h3>
<ul>
<li>推导</li>
</ul>
<p>第一个公式详细推导计算过程，后面的公式由于原理相同，就不详细推导，直接给出结论。</p>
<p>推导过程，主要结合等式(8)种的结论:</p>
<p><span class="math display">\[
\begin{array}{cl}
L_t^+(x,y,\psi) &amp;= \bigl(x + \sin(\psi+t)- \sin(\psi),y - \cos(\psi+t)+\cos(\psi),\psi + t\bigr)\\
R_t^+(x,y,\psi) &amp;= \bigl(x - \sin(\psi-t)+ \sin(\psi),y + \cos(\psi-t)-\cos(\psi),\psi - t\bigr)\\
S_t^+(x,y,\psi) &amp;= (x+t\cos(\psi),y + t\sin(\psi),\psi)
\end{array}
\]</span></p>
<p>起始坐标<span class="math inline">\((0,0,0)\)</span>，目标坐标<span class="math inline">\((x,y,\psi)\)</span></p>
<table>
<thead>
<tr class="header">
<th>操作</th>
<th><span class="math inline">\(x\)</span></th>
<th><span class="math inline">\(y\)</span></th>
<th><span class="math inline">\(\psi\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>起始坐标</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>移动弧长<strong>t</strong></td>
<td><span class="math inline">\(\sin{t}\)</span></td>
<td><span class="math inline">\(1 - \cos{t}\)</span></td>
<td><span class="math inline">\(t\)</span></td>
</tr>
<tr class="odd">
<td>移动弧长<strong>u</strong></td>
<td><span class="math inline">\(\sin{t} + u\cos{t}\)</span></td>
<td><span class="math inline">\(1 - \cos{t} + u\sin{t}\)</span></td>
<td><span class="math inline">\(t\)</span></td>
</tr>
<tr class="even">
<td>移动弧长<strong>v</strong></td>
<td><span class="math inline">\(u\cos{t} + \sin{(t+v)}\)</span></td>
<td><span class="math inline">\(1 + u\sin{t} - \cos{(t + v)}\)</span></td>
<td><span class="math inline">\(t + v\)</span></td>
</tr>
<tr class="odd">
<td>终点坐标</td>
<td><span class="math inline">\(x\)</span></td>
<td><span class="math inline">\(y\)</span></td>
<td><span class="math inline">\(\psi\)</span></td>
</tr>
</tbody>
</table>
<p>从上述表格可知</p>
<p><span class="math display">\[
\begin{array}{cl}
x &amp;=   u\cos{t} + \sin{(t+v)} \\
y &amp;=   1 + u\sin{t} - \cos{(t + v)} \\
\psi &amp;=   t + v 
\end{array}
\]</span></p>
<p>将$= t + v $带入得</p>
<p><span class="math display">\[
\begin{array}{cl}
x &amp;=   u\cos{t} + \sin{\psi} \\
y &amp;=   1 + u\sin{t} - \cos{\psi}
\end{array}
\]</span></p>
<p>移项得</p>
<p><span class="math display">\[
\begin{array}{cl}
u\cos{t} &amp;=  x  - \sin{\psi} \\
u\sin{t} &amp;=  y  + \cos{\psi}- 1
\end{array}
\]</span></p>
<p>使用极坐标表示得</p>
<p><span class="math display">\[
(u,t) = R(x  - \sin{\psi},y  + \cos{\psi}- 1)
\]</span></p>
<p>则</p>
<p><span class="math display">\[
v = M(\psi - t)
\]</span></p>
<ul>
<li>结论</li>
</ul>
<p>已知起始坐标<span class="math inline">\((0,0,0)\)</span>和目标坐标<span class="math inline">\((x,y,\psi)\)</span>，则<span class="math inline">\(L^+_tS^+_uL^+_v\)</span>的最优解为</p>
<p><span class="math display">\[
\begin{array}{cl}
(u,t) &amp;= R(x  - \sin{\psi},y  + \cos{\psi}- 1)\\
v &amp;= M(\psi - t)
\end{array}
\]</span></p>
<p>总长度为<span class="math inline">\(L = |t| + |u| + |v|\)</span>。</p>
<h3 id="公式-l_ts_ur_v">公式 <span class="math inline">\(L^+_tS^+_uR^+_v\)</span></h3>
<p>下表描述了计算过程：</p>
<table style="width:100%;">
<colgroup>
<col style="width: 12%" />
<col style="width: 35%" />
<col style="width: 41%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr class="header">
<th>操作</th>
<th><span class="math inline">\(x\)</span></th>
<th><span class="math inline">\(y\)</span></th>
<th><span class="math inline">\(\psi\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>起始坐标</td>
<td><span class="math inline">\(0\)</span></td>
<td><span class="math inline">\(0\)</span></td>
<td><span class="math inline">\(0\)</span></td>
</tr>
<tr class="even">
<td>移动弧长<strong>t</strong></td>
<td><span class="math inline">\(\sin{t}\)</span></td>
<td><span class="math inline">\(1 - \cos{t}\)</span></td>
<td><span class="math inline">\(t\)</span></td>
</tr>
<tr class="odd">
<td>移动弧长<strong>u</strong></td>
<td><span class="math inline">\(\sin{t} + u\cos{t}\)</span></td>
<td><span class="math inline">\(1 - \cos{t} + u\sin{t}\)</span></td>
<td><span class="math inline">\(t\)</span></td>
</tr>
<tr class="even">
<td>移动弧长<strong>v</strong></td>
<td><span class="math inline">\(u\cos{t} - \sin{(t-v)}+2\sin{t}\)</span></td>
<td><span class="math inline">\(1 + u\sin{t} + \cos{(t - v)}-2\cos{t}\)</span></td>
<td><span class="math inline">\(t - v\)</span></td>
</tr>
<tr class="odd">
<td>终点坐标</td>
<td><span class="math inline">\(x\)</span></td>
<td><span class="math inline">\(y\)</span></td>
<td><span class="math inline">\(\psi\)</span></td>
</tr>
</tbody>
</table>
<p>整理得</p>
<p><span class="math display">\[
\begin{array}{cl}
x &amp;= u\cos{t} - \sin{(t-v)}+2\sin{t}   \\
y &amp;= u\sin{t} + \cos{(t - v)}-2\cos{t} +1 \\
\psi &amp;=    t - v 
\end{array}
\]</span></p>
<p>将<span class="math inline">\(\psi = t -v\)</span>带入得</p>
<p><span class="math display">\[
\begin{array}{cl}
x &amp;= u\cos{t} - \sin{\psi}+2\sin{t}   \\
y &amp;= u\sin{t} + \cos{\psi}-2\cos{t} +1
\end{array}
\]</span></p>
<p>移项得</p>
<p><span class="math display">\[
\begin{array}{cl}
u\cos{t} &amp;= x + \sin{\psi} - 2\sin{t}   \\
u\sin{t} &amp;= y - \cos{\psi} + 2\cos{t} -1
\end{array}
\]</span></p>
<p>令$ P_1(u_1,t_1) = R(x + ,y - ) <span class="math inline">\(，\)</span>P_2(2,t-)=R(2,-2)<span class="math inline">\(，\)</span>P(u,t)=R(u,u)$。</p>
<p>由等式得</p>
<p><span class="math display">\[
P(u,t) = P_1(u_1,t_1) - P_2(2,t-\frac{\pi}{2})
\]</span></p>
<p>由上式可知，极向量<span class="math inline">\(P\)</span>与<span class="math inline">\(P_2\)</span>必须垂直，由于向量<span class="math inline">\(P_2\)</span>的长度为2，为了满足上述关系，向量<span class="math inline">\(P_1\)</span>的长度不能小于2，否则无解。</p>
<ul>
<li>如果<span class="math inline">\(u_1^2 &lt; 4\)</span></li>
</ul>
<p>无解，<span class="math inline">\(L = \infty\)</span>。</p>
<ul>
<li>如果<span class="math inline">\(u_1^2 \geq 4\)</span></li>
</ul>
<p>已知起始坐标<span class="math inline">\((0,0,0)\)</span>和目标坐标<span class="math inline">\((x,y,\psi)\)</span>，可以求出<span class="math inline">\(P_1(u_1,t_1) = R(x + \sin\psi,y + \cos\psi -1)\)</span>，且<span class="math inline">\(P_2(2,t-\frac{\pi}{2})\)</span>已知。根据上述极向量<span class="math inline">\(P\)</span>、<span class="math inline">\(P_1\)</span>、<span class="math inline">\(P_2\)</span>之间的直角三角形关系，可得<span class="math inline">\(u^2 + 2^2 = u_1^2 \to u = \sqrt{u_1^2 - 4}\)</span>。极向量<span class="math inline">\(P\)</span>与<span class="math inline">\(P_1\)</span>之间的夹角<span class="math inline">\(\beta = \arctan{\dfrac{2}{u}}\)</span>，故<span class="math inline">\(t = M(t_1 + \beta)\)</span>，<span class="math inline">\(v = M(t - \psi)\)</span>。弧长<span class="math inline">\(L = |t| + |u| + |v|\)</span>。</p>
<p><img data-src="https://i.loli.net/2021/08/30/yCQc9YA6UNxbdqH.png" style="zoom:80%;" /></p>
<h3 id="公式-l_tr-_ul_v">公式 <span class="math inline">\(L^+_tR^-_uL^+_v\)</span></h3>
<p>下表是路径的计算过程。</p>
<table>
<thead>
<tr class="header">
<th>操作</th>
<th><span class="math inline">\(x\)</span></th>
<th><span class="math inline">\(y\)</span></th>
<th><span class="math inline">\(\psi\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>起始坐标</td>
<td><span class="math inline">\(0\)</span></td>
<td><span class="math inline">\(0\)</span></td>
<td><span class="math inline">\(0\)</span></td>
</tr>
<tr class="even">
<td>移动弧长<strong>t</strong></td>
<td><span class="math inline">\(\sin{t}\)</span></td>
<td><span class="math inline">\(1 - \cos{t}\)</span></td>
<td><span class="math inline">\(t\)</span></td>
</tr>
<tr class="odd">
<td>移动弧长<strong>u</strong></td>
<td><span class="math inline">\(\sin(t + u)\)</span></td>
<td><span class="math inline">\(1 - \cos{(t + u)}\)</span></td>
<td><span class="math inline">\(t + u\)</span></td>
</tr>
<tr class="even">
<td>移动弧长<strong>v</strong></td>
<td><span class="math inline">\(\sin{(t+u + v)}\)</span></td>
<td><span class="math inline">\(1 - \cos{(t + u + v)}\)</span></td>
<td><span class="math inline">\(t +u+ v\)</span></td>
</tr>
<tr class="odd">
<td>终点坐标</td>
<td><span class="math inline">\(x\)</span></td>
<td><span class="math inline">\(y\)</span></td>
<td><span class="math inline">\(\psi\)</span></td>
</tr>
</tbody>
</table>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://ompl.kavrakilab.org/ReedsSheppStateSpace_8cpp_source.html">参考源码</a></li>
<li><a href="http://www.banbeichadexiaojiubei.com/index.php/2020/03/23/%e8%87%aa%e5%8a%a8%e9%a9%be%e9%a9%b6%e8%bf%90%e5%8a%a8%e8%a7%84%e5%88%92-reeds-shepp%e6%9b%b2%e7%ba%bf/">自动驾驶运动规划-Reeds Shepp曲线</a></li>
<li><a href="https://projecteuclid.org/download/pdf_1/euclid.pjm/1102645450">算法论文</a></li>
</ul>
]]></content>
      <categories>
        <category>路径规划</category>
        <category>几何路径</category>
      </categories>
      <tags>
        <tag>路径规划</tag>
        <tag>ReedsSheep</tag>
        <tag>RS曲线</tag>
        <tag>Dubins曲线</tag>
      </tags>
  </entry>
  <entry>
    <title>车辆术语缩写</title>
    <url>/2020/01/07/%E8%BD%A6%E8%BE%86%E6%9C%AF%E8%AF%AD%E7%BC%A9%E5%86%99/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>本文总结了汽车领域常用汽车术语的缩写，后续会继续补偿完善。</p>
<h2 id="泊车辅助系统">泊车辅助系统</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">缩写</th>
<th>英文名称</th>
<th>中文名称</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>APA</strong></td>
<td>Auto Parking Assistant</td>
<td>自动泊车辅助系统</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>RPA</strong></td>
<td>Remote Parking Assist</td>
<td>遥控泊车辅助</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>HPA</strong></td>
<td>Home zone Parking Assist</td>
<td>家庭区域泊车辅助</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>PIC</strong></td>
<td>Parking In Control</td>
<td>泊入控制</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>POC</strong></td>
<td>Pull Out Control</td>
<td>泊出控制</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>L-ASP</strong></td>
<td>Low Speed Autonomous Searching Parking slot</td>
<td>低速自动寻找车位</td>
</tr>
</tbody>
</table>
<span id="more"></span>
<h2 id="纵向辅助系统">纵向辅助系统</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">缩写</th>
<th>英文名称</th>
<th>中文名称</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>L-AEB</strong></td>
<td>Low speed Automatic Emergency Brake</td>
<td>低速自动紧急制动</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>L-ACC</strong></td>
<td>Low speed Adaptive Cruise Control</td>
<td>低速自适应巡航</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>ACC</strong></td>
<td>Adaptive Cruise Control</td>
<td>自适应巡航控制</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>LSC</strong></td>
<td>Longitudinal speed control</td>
<td>纵向速度控制</td>
</tr>
</tbody>
</table>
<h2 id="感知系统">感知系统</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">缩写</th>
<th>英文名称</th>
<th style="text-align: left;">中文名称</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>RRS</strong></td>
<td>Reversing Radar System</td>
<td style="text-align: left;">倒车雷达系统</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>SDW</strong></td>
<td>Side Distance Warning</td>
<td style="text-align: left;">侧边距离报警</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>SVA</strong></td>
<td>Side View Assist</td>
<td style="text-align: left;">侧视辅助</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>CTA</strong></td>
<td>Cross Traffic Assist</td>
<td style="text-align: left;">倒车横向告警</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>BSD</strong></td>
<td>Blind spot Detection</td>
<td style="text-align: left;">盲区监测系统</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>HD-AVM</strong></td>
<td>High Definition Around view Monitor</td>
<td style="text-align: left;">高画质环视监控</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>LDW</strong></td>
<td>Lane Departure Warning</td>
<td style="text-align: left;">低速车道偏离报警</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>DVR</strong></td>
<td>Driving Video Record</td>
<td style="text-align: left;">行车记录仪</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>RM</strong></td>
<td>Remote Monitoring</td>
<td style="text-align: left;">远程监控</td>
</tr>
</tbody>
</table>
<h2 id="检测系统">检测系统</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">缩写</th>
<th>英文名称</th>
<th>中文名称</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>MOD</strong></td>
<td>Moving Object Detection</td>
<td>移动目标检测</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>PD</strong></td>
<td>Pedestrian Detection</td>
<td>行人检测</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>3-DOD</strong></td>
<td>3D Object Detection</td>
<td>3D 目标检测</td>
</tr>
</tbody>
</table>
<h2 id="执行器">执行器</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">缩写</th>
<th>英文名称</th>
<th>中文名称</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>ACM</strong></td>
<td>Actuator Control Module</td>
<td>执行器控制系统</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>EPS</strong></td>
<td>Electronic Power Steering</td>
<td>电子助力转向系统</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>TCU</strong></td>
<td>Transmission Control Unit</td>
<td>变速器控制单元</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>EMS</strong></td>
<td>Engine Management System</td>
<td>发动机管理系统</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>SAS</strong></td>
<td>Steering Angle Sensor</td>
<td>转角传感器</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>BCM</strong></td>
<td>Body Control Module</td>
<td>车身控制器</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>ESC</strong></td>
<td>Electronic Stability Control</td>
<td>电子稳定控制</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>VCU</strong></td>
<td>Vehicle Control Unit</td>
<td>车辆控制单元</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>EPB</strong></td>
<td>Electronic Parking Brake</td>
<td>电子驻车</td>
</tr>
</tbody>
</table>
<h2 id="其它">其它</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">缩写</th>
<th style="text-align: left;">英文名称</th>
<th style="text-align: left;">中文名称</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>SEA</strong></td>
<td style="text-align: left;">Side Exit Alert</td>
<td style="text-align: left;">开门告警</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>HMI</strong></td>
<td style="text-align: left;">Human-Machine Interface</td>
<td style="text-align: left;">人机交互接口</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>IP</strong></td>
<td style="text-align: left;">Instrument Panel</td>
<td style="text-align: left;">仪表</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>HU</strong></td>
<td style="text-align: left;">Head Unit</td>
<td style="text-align: left;">主机</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>AC</strong></td>
<td style="text-align: left;">Air Condition</td>
<td style="text-align: left;">空调</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>车辆基础</category>
      </categories>
      <tags>
        <tag>车辆术语</tag>
        <tag>名称缩写</tag>
      </tags>
  </entry>
  <entry>
    <title>Home Assistant(Supervisor)安装</title>
    <url>/2022/12/26/Home-Assistant-Supervised-%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="概述">概述</h1>
<p>本文讲述 <strong>Home Assistant Supervisor</strong> 的安装步骤，虽然官方有详细的安装指导，但是由于软件源大都在国外，某些步骤可能需要科学上网才能解决。本文实际部署的硬件平台是 Raspberry Pi 3 Model，请参考 做好硬件和软件环境的准备。</p>
<p><img data-src="https://s3.bmp.ovh/imgs/2023/01/01/eca88d886cc33e9a.jpg" /></p>
<span id="more"></span>
<h1 id="前期准备">前期准备</h1>
<h2 id="系统确认">系统确认</h2>
<p>参考官方说明文档 <a href="https://www.home-assistant.io/more-info/unsupported/os">Operating System</a> 确认目前支持的系统。目前 Home Assistant Supervisor 支持的操作系统类型是 Debian 11 (Bullseye)，可以支持</p>
<h2 id="apparmor配置">Apparmor配置</h2>
<p>默认树莓派最新的发布版本是安装了 apparmor 工具的，Supervisor 要求系统开机时激活apparmor 服务，需要在<code>/boot/cmdline.txt</code>文件中，追加 <code>apparmor=1 security=apparmor</code> 内容。详细参考 <a href="https://github.com/Kanga-Who/home-assistant/issues/25">how to enable apparmor</a> 内容。</p>
<h2 id="cgroup配置">cgroup配置</h2>
<p>打开 <code>/etc/default/grub</code> 文件，如果不存该文件则创建，并在文件中写入 <code>systemd.unified_cgroup_hierarchy=false</code> 内容。</p>
<p>打开 <code>/boot/cmdline.txt</code> 文件，并追加 <code>systemd.unified_cgroup_hierarchy=false</code> 内容。</p>
<h2 id="networkmanager配置">NetworkManager配置</h2>
<p>由于Home Assistant Supervisor 需要 <code>NetworkManager</code> 的支持，而树莓派官方系统默认采用 <code>dhcpcd</code>网络配置工具。所以需要通过<strong>raspi-config</strong>工具切换网络配置工具。</p>
<p>通过如下命令，打开树莓派配置工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo raspi-config</span><br></pre></td></tr></table></figure>
<p>如下图所示，选择 <mark>Advanced Options</mark></p>
<p><img data-src="https://s3.bmp.ovh/imgs/2023/01/01/ff1e0866079cc9e0.png" title="" alt="" data-align="center"></p>
<p>选择 <mark>Network Config</mark></p>
<p><img data-src="https://s3.bmp.ovh/imgs/2023/01/01/25b0190151f2570f.png" title="" alt="" data-align="center"></p>
<p>最后将网络配置器切换到 <mark>NetworkManager</mark>，按下回车键 Enter 保存配置，此时需要会提示是否 reboot ,请选择yes，重启树莓派。</p>
<p><img data-src="https://s3.bmp.ovh/imgs/2023/01/01/b9281b0f4fd84e7a.png" title="" alt="" data-align="center"></p>
<h1 id="supervisor-安装步骤">Supervisor 安装步骤</h1>
<h2 id="依赖软件安装">依赖软件安装</h2>
<p>通过如下命令安装依赖软件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install \</span><br><span class="line">apparmor \</span><br><span class="line">jq \</span><br><span class="line">wget \</span><br><span class="line">curl \</span><br><span class="line">udisks2 \</span><br><span class="line">libglib2.0-bin \</span><br><span class="line">network-manager \</span><br><span class="line">dbus \</span><br><span class="line">lsb-release \</span><br><span class="line">systemd-journal-remote -y</span><br></pre></td></tr></table></figure>
<h2 id="docker-ce-安装">Docker-CE 安装</h2>
<p>下载安装脚本，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL get.docker.com</span><br></pre></td></tr></table></figure>
<p>国内用户建议通过阿里镜像源进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh get-docker.sh --mirror Aliyun</span><br></pre></td></tr></table></figure>
<p>将当前用户添加进dockert组中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure>
<h2 id="os-agent-安装">OS-Agent 安装</h2>
<p>由于Supervisor依赖 <strong>OS-Agent</strong> 软件包，但该软件不在Debian官方软件源内，需要前往Github仓库 <a href="https://github.com/home-assistant/os-agent">os-agent</a> 下载。</p>
<p><img data-src="https://s3.bmp.ovh/imgs/2023/01/01/99f64464d0d1f039.png" /></p>
<p>通过如下指令查看芯片架构类型：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uname</span> -m</span></span><br></pre></td></tr></table></figure>
<p>如果输出 <code>aarch64</code> ，则下载 <code>os-agent_1.4.1_linux_aarch64.deb</code> 软件包。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget -c https://github.com/home-assistant/os-agent/releases/download/1.4.1/os-agent_1.4.1_linux_aarch64.deb</span></span><br></pre></td></tr></table></figure>
<p>然后使用 <code>dpkg</code>命令安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo dpkg -i os-agent_1.4.1_linux_aarch64.deb</span><br></pre></td></tr></table></figure>
<p>判断是否安装成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdbus introspect --system --dest io.hass.os --object-path /io/hass/os</span></span><br></pre></td></tr></table></figure>
<p>上述命令如果不输出错误信息，而是输出包含 <code>interface</code> 字段的信息则说明安装成功，树莓派安装后输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node /io/hass/os &#123;</span><br><span class="line">  interface org.freedesktop.DBus.Introspectable &#123;</span><br><span class="line">    methods:</span><br><span class="line">      Introspect(out s out);</span><br><span class="line">    signals:</span><br><span class="line">    properties:</span><br><span class="line">  &#125;;</span><br><span class="line">  interface org.freedesktop.DBus.Properties &#123;</span><br><span class="line">    methods:</span><br><span class="line">      Get(in  s interface,</span><br><span class="line">          in  s property,</span><br><span class="line">          out v value);</span><br><span class="line">      GetAll(in  s interface,</span><br><span class="line">             out a&#123;sv&#125; props);</span><br><span class="line">      Set(in  s interface,</span><br><span class="line">          in  s property,</span><br><span class="line">          in  v value);</span><br><span class="line">    signals:</span><br><span class="line">      PropertiesChanged(s interface,</span><br><span class="line">                        a&#123;sv&#125; changed_properties,</span><br><span class="line">                        as invalidates_properties);</span><br><span class="line">    properties:</span><br><span class="line">  &#125;;</span><br><span class="line">  interface io.hass.os &#123;</span><br><span class="line">    methods:</span><br><span class="line">    signals:</span><br><span class="line">    properties:</span><br><span class="line">      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;invalidates&quot;)</span><br><span class="line">      readonly s Version = &#x27;1.4.1&#x27;;</span><br><span class="line">      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;true&quot;)</span><br><span class="line">      readwrite b Diagnostics = false;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="supervisor-安装">Supervisor 安装</h2>
<p>前往 <a href="https://github.com/home-assistant/supervised-installer/releases">Releases · home-assistant/supervised-installer · GitHub</a>下载与 OS-Agent版本匹配的Debian包。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget -c https://github.com/home-assistant/supervised-installer/releases/download/1.4.1/homeassistant-supervised.deb</span><br></pre></td></tr></table></figure>
<p>执行安装命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo dpkg -i homeassistant-supervised.deb</span><br></pre></td></tr></table></figure>
<p>安装过程中会弹出配置窗口，根据实际硬件和系统位宽选择对应的即可。</p>
<p>安装成功后，需要等待一段时间，时间长短由实际网络情况决定。如果想确认系统是否在运行相关安装操作，可查看系统进程，如果出现下图中的进程，则说明正在下载相关的docker镜像。</p>
<p><img data-src="https://s3.bmp.ovh/imgs/2023/01/01/27828012ad450222.png" /></p>
<p>通过如下指令可以查看docker镜像的下载情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker images | grep ghcr.io/home-assistant</span><br></pre></td></tr></table></figure>
<p>如下镜像列表，说明 <strong>Supervisor</strong> 需求的所有基础镜像都下载完成。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ghcr.io/home-assistant/raspberrypi3-64-homeassistant   2022.12.8   bdb17d6196f1   10 days ago     1.42GB</span><br><span class="line">ghcr.io/home-assistant/aarch64-hassio-supervisor       latest      274d5e89d465   12 days ago     314MB</span><br><span class="line">ghcr.io/home-assistant/aarch64-hassio-cli              2022.11.0   a3ff4e00a9a0   8 weeks ago     116MB</span><br><span class="line">ghcr.io/home-assistant/aarch64-hassio-audio            2022.07.0   c4435f74fa3c   5 months ago    152MB</span><br><span class="line">ghcr.io/home-assistant/aarch64-hassio-dns              2022.04.1   362b749494ab   8 months ago    96.7MB</span><br><span class="line">ghcr.io/home-assistant/aarch64-hassio-multicast        2022.02.0   3ce91958464c   10 months ago   81.5MB</span><br><span class="line">ghcr.io/home-assistant/aarch64-hassio-observer         2021.10.0   9c3593efc7e1   14 months ago   89.2MB</span><br></pre></td></tr></table></figure>
<p>另外可以使用如下命令查看相关容器是否创建成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker ps</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CONTAINER ID   IMAGE                                                            COMMAND   CREATED        STATUS        PORTS                                   NAMES</span><br><span class="line">8a35d1671da0   ghcr.io/home-assistant/aarch64-hassio-multicast:2022.02.0        <span class="string">&quot;/init&quot;</span>   21 hours ago   Up 21 hours                                           hassio_multicast</span><br><span class="line">fe5d313af4a6   ghcr.io/home-assistant/aarch64-hassio-audio:2022.07.0            <span class="string">&quot;/init&quot;</span>   21 hours ago   Up 21 hours                                           hassio_audio</span><br><span class="line">af22688c8288   ghcr.io/home-assistant/aarch64-hassio-dns:2022.04.1              <span class="string">&quot;/init&quot;</span>   21 hours ago   Up 21 hours                                           hassio_dns</span><br><span class="line">b5255dbcb17d   ghcr.io/home-assistant/aarch64-hassio-cli:2022.11.0              <span class="string">&quot;/init&quot;</span>   21 hours ago   Up 21 hours                                           hassio_cli</span><br><span class="line">7acff09641e5   ghcr.io/home-assistant/aarch64-hassio-observer:2021.10.0         <span class="string">&quot;/init&quot;</span>   6 days ago     Up 21 hours   0.0.0.0:4357-&gt;80/tcp, :::4357-&gt;80/tcp   hassio_observer</span><br><span class="line">cb3b24d10901   ghcr.io/home-assistant/raspberrypi3-64-homeassistant:2022.12.8   <span class="string">&quot;/init&quot;</span>   7 days ago     Up 21 hours                                           homeassistant</span><br><span class="line">7e49186c9adf   ghcr.io/home-assistant/aarch64-hassio-supervisor:latest          <span class="string">&quot;/init&quot;</span>   7 days ago     Up 21 hours                                           hassio_supervisor</span><br></pre></td></tr></table></figure>
<p>进一步访问 <code>IP:4357</code> 端口，确认 Supervisor 工作状态是否正常。 <img data-src="https://s3.bmp.ovh/imgs/2023/01/01/c8b095d572622e38.png" alt="supervisor状态" /></p>
<p>最后通过访问 <code>IP:8123</code> 端口，进行 <strong>Home Assisistant</strong> 的相关配置。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><p><a href="https://github.com/home-assistant/supervised-installer">supervised-installer: Installer for a generic Linux system</a></p></li>
<li><p><a href="https://github.com/home-assistant/os-agent/tree/main#using-home-assistant-supervised-on-debian">os-agent: Daemon allowing to control OS features through D-Bus</a></p></li>
<li><p><a href="https://www.mintimate.cn/2022/03/29/raspberryInsatllHAS/#%E5%89%8D%E8%A8%80">详解树莓派上如何安装Home Assistant Supervised - 雨月空间站</a></p></li>
<li><p><a href="https://www.home-assistant.io/more-info/unsupported/network_manager">Network Manager - Home Assistant</a></p></li>
</ol>
]]></content>
      <categories>
        <category>Home Assistant</category>
      </categories>
      <tags>
        <tag>Home Assistant</tag>
        <tag>Supervised</tag>
        <tag>安装教程</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派系统安装</title>
    <url>/2022/12/26/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="section"></h2>
<h1 id="概述">概述</h1>
<p>本文讲述了树莓派系统的安装过程，并描述系统环境的配置，让其可以满足基本开发需求。</p>
<span id="more"></span>
<h1 id="硬件环境准备">硬件环境准备</h1>
<h2 id="卡片计算机">卡片计算机</h2>
<p>本文演示所用的计算机是 Raspberry Pi 3 Model B，其参数如下：</p>
<ul>
<li>Quad Core 1.2GHz Broadcom BCM2837 64bit CPU</li>
<li>1GB RAM</li>
<li>BCM43438 wireless LAN and Bluetooth Low Energy (BLE) on board</li>
<li>100 Base Ethernet</li>
<li>40-pin extended GPIO</li>
<li>4 USB 2 ports</li>
<li>4 Pole stereo output and composite video port</li>
<li>Full size HDMI</li>
<li>CSI camera port for connecting a Raspberry Pi camera</li>
<li>DSI display port for connecting a Raspberry Pi touchscreen display</li>
<li>Micro SD port for loading your operating system and storing data</li>
<li>Upgraded switched Micro USB power source up to 2.5A</li>
</ul>
<h2 id="电源适配器">电源适配器</h2>
<p>根据官方推荐参数，请选用输出电流可达2.5A的电源适配器，如果电源适配的输出功率不够，可能会导致系统不稳定的情况。例如在使用ssh连接卡片计算机时，如果计算机负载过高，会出现ssh连接断开的的情况。</p>
<h2 id="sd卡">SD卡</h2>
<p>推荐选用SD卡的容量至少32GB，该容量可以满足大部分场景需求。</p>
<h1 id="软件环境准备">软件环境准备</h1>
<h2 id="系统下载">系统下载</h2>
<p>首先从 <a href="https://www.raspberrypi.com/software/operating-systems/">树莓派官网</a> 下载最新的系统镜像，本文演示的系统镜像信息如下：</p>
<ul>
<li><p>Raspberry Pi OS Lite</p></li>
<li><p>Release date: September 22nd 2022</p></li>
<li><p>System: 64-bit</p></li>
<li><p>Kernel version: 5.15</p></li>
<li><p>Debian version: 11 (bullseye)</p></li>
<li><p>Size: 289MB：72c773781a0a57160eb3fa8bb2a927642fe60c3af62bc980827057bcecb7b98b</p></li>
</ul>
<h2 id="镜像烧录工具下载">镜像烧录工具下载</h2>
<p>从树莓派官网下载 <a href="https://www.raspberrypi.com/software/">Raspberry Pi Imager</a> 工具，进行系统镜像的烧录。</p>
<p><img data-src="https://s3.bmp.ovh/imgs/2022/12/26/a6df9e3221c7bd5d.png" /></p>
<p>点击右下角的设置按钮，开启SSH功能并创建用户名和密码，如果希望通过wifi连接，可以配置wifi热点名和密码。</p>
<h2 id="系统准备">系统准备</h2>
<h3 id="更换镜像源">更换镜像源</h3>
<p>参考 <a href="https://mirrors.tuna.tsinghua.edu.cn/help/raspbian/">清华树莓派镜像站</a> 配置系统镜像源。</p>
<p>备份镜像源文件，通过如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> /etc/apt/sources.list /tmp/sources.list.backup</span></span><br></pre></td></tr></table></figure>
<p>通过下面的指令替换原文件的内容并更新到系统镜像源。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed -e <span class="string">&#x27;s/http:\/\/deb.debian.org/https:\/\/mirrors.tuna.tsinghua.edu.cn/;</span></span></span><br><span class="line">        s/http:\/\/security.debian.org/https:\/\/mirrors.tuna.tsinghua.edu.cn/&#x27; \</span><br><span class="line">        /tmp/sources.list.backup &gt; /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p>同理，执行下述命令，替换为清华镜像源:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> /etc/apt/sources.list.d/raspi.list /tmp/raspi.list.backup</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed -e <span class="string">&#x27;s/http:\/\/archive.raspberrypi.org\/debian/https:\/\/mirrors.tuna.tsinghua.edu.cn\/raspberrypi/&#x27;</span> \</span></span><br><span class="line"><span class="language-bash">        /tmp/raspi.list.backup &gt; /etc/apt/sources.list.d/raspi.list</span></span><br></pre></td></tr></table></figure>
<p>执行下述命令，更新系统镜像源:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">apt-get update --fix-missing</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">apt-get upgrade -y</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>安装教程</tag>
        <tag>Raspberry Pi</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
</search>
